{"meta":{"title":"AmebaLab","subtitle":null,"description":"생각과 학습의 아카이브","author":"Sooyoung Jeong","url":"http://codeameba.github.io","root":"/"},"pages":[{"title":"Category","date":"2020-01-31T10:41:42.313Z","updated":"2020-01-31T10:41:42.313Z","comments":true,"path":"category/index.html","permalink":"http://codeameba.github.io/category/index.html","excerpt":"","text":""},{"title":"🤔 Contact","date":"2020-03-17T08:58:54.066Z","updated":"2020-03-17T08:58:54.066Z","comments":true,"path":"contact/index.html","permalink":"http://codeameba.github.io/contact/index.html","excerpt":"","text":"✍ 그날 그날의 생각과 새롭게 알게된 것들을 기록합니다.📧 aprilgreenery@gmail.com GitHub Instagram Photography Portfolio Front-End Practice"},{"title":"Tag","date":"2020-02-01T14:12:53.986Z","updated":"2020-02-01T14:12:53.986Z","comments":true,"path":"tag/index.html","permalink":"http://codeameba.github.io/tag/index.html","excerpt":"","text":""}],"posts":[{"title":"[TIL] 화살표 함수는 편리하지만 메서드에는 자제할 것!","slug":"programming/arrow-function-dont-using-method","date":"2020-04-12T11:12:42.000Z","updated":"2020-04-12T11:22:55.891Z","comments":true,"path":"2020/04/12/programming/arrow-function-dont-using-method/","link":"","permalink":"http://codeameba.github.io/2020/04/12/programming/arrow-function-dont-using-method/","excerpt":"","text":"일급객체 자바스크립트 함수자바스크립트에서 함수는 일급객체이기에 어디든 들어갈 수 있다. 값으로도 들어가고, 파라미터로도 들어가고, 배열에도 들어가며, 객체에도 들어갈 수 있다. JavaScript Preview 함수는 퍼스트 클래스? | AmebaLab 편리한 화살표 함수ES6에서 등장한 여러 문법들이 있지만, 여러모로 인상적이고 사랑 받는 문법은 단연 화살표 함수(Arrow Function) 이 아닐까 싶다. 조금만 익숙해지면, 배열 메서드 등에 편리하게 쓸 수 있으니 말이다. 1234567const nums = [3, 5, 7, 15, 37, 42, 68, 73];const underOfFifty = nums.filter(num =&gt; num &lt; 50);const multiplyTen = nums.map(num =&gt; num * 10);console.log(`Under Of 50: $&#123;underOfFifty&#125;, Multiply 10: $&#123;multiplyTen&#125;`);// Under Of 50: 3,5,7,15,37,42, Multiply 10: 30,50,70,150,370,420,680,730 메서드와 생성자에는 참아주세요!이토록 편리한 화살표 함수지만 사용을 자제해야 하는 경우가 더러 있다. 1. 메서드에는 화살표 함수 금지12345678910const robot = &#123; name: ‘Coderoid’, sayHi: () =&gt; &#123; console.log(`Hi, $&#123;this.name&#125;`) &#125;, sayBye: function() &#123; console.log(`Bye, $&#123;this.name&#125;`) &#125;&#125;;robot.sayHi(); // Hi,robot.sayBye(); // Bye, Coderoid 위와 같이 function키워드를 사용한 메서드는 일반적으로 알려진대로 this가 점(.) 앞의 객체에 제대로 바인딩 되어 있지만, 화살표 함수로 만들어진 메서드는 그렇지 않다. 그렇다면, 화살표 함수의 this는 어디에 바인딩 되어있는 것일까? 아래의 코드를 통해 알아보자. 12345678Object.defineProperty(robot, ‘sayHi’, &#123; get: () =&gt; &#123; console.log(this); &#125;&#125;);robot[‘sayHi’];// Window &#123;parent: Window, opener: null, top: Window, length: 0, frames: Window, …&#125; 그렇다, 호출한 객체가 아닌 window 전역객체를 가리키고 있다. 2. 생성자에는 화살표 함수 금지생성자에서 화살표 함수를 쓰게 되면 아래와 같은 오류가 발생한다. 123const Robot = () =&gt; &#123;&#125;;const robot = new Robot();// Uncaught TypeError: Robot is not a constructor 3. 화살표 함수에는 프로토타입(prototype)이 없다또한, 프로토타입 체인을 통한 프로퍼티의 위임 등을 할 수 있는 프로토타입이 화살표 함수에는 없다. 12345const Robot = () =&gt; &#123;&#125;;console.log(Robot.prototype); // undefinedconst Rocket = function() &#123;&#125;;console.log(Rocket.prototype); // &#123;constructor: ƒ&#125; 위와 같이 화살표 함수의 프로토타입은 undefined가 출력되고, 일반 함수의 프로토타입은 존재하는 것을 확인할 수 있다. 4. yield 키워드를 쓸 수 없다yield 키워드는 제너레이터(generator) 함수 내부의 여러 값을 필요에 따라 하나씩 반환할 수 있게 해주는데, 이러한 yield 키워드를 화살표 함수에서는 사용할 수가 없다. 그 말은 곧 화살표 함수는 제너레이터로 쓸 수 없다는 말 이기도 하다. 참고: 화살표 함수 - JavaScript | MDN 제너레이터","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://codeameba.github.io/categories/JavaScript/"}],"tags":[{"name":"til","slug":"til","permalink":"http://codeameba.github.io/tags/til/"},{"name":"TIL","slug":"TIL","permalink":"http://codeameba.github.io/tags/TIL/"},{"name":"Today I Learned","slug":"Today-I-Learned","permalink":"http://codeameba.github.io/tags/Today-I-Learned/"},{"name":"오늘배운것들","slug":"오늘배운것들","permalink":"http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Javascript","slug":"Javascript","permalink":"http://codeameba.github.io/tags/Javascript/"}]},{"title":"[TIL] 자주 쓰지 않지만 알면 유용한 배열 메서드","slug":"programming/til-some-every","date":"2020-04-11T15:41:42.000Z","updated":"2020-04-11T15:41:12.740Z","comments":true,"path":"2020/04/12/programming/til-some-every/","link":"","permalink":"http://codeameba.github.io/2020/04/12/programming/til-some-every/","excerpt":"","text":".every() every() 메서드는 배열 안의 모든 요소가 주어진 판별 함수를 통과하는지 테스트합니다. (MDN) 간단히 말하자면, 요소 하나라도 조건식을 통과하지 못하면 false를 반환하고, 모든 요소가 조건식을 만족하면 true를 반환한다. 빈 배열일 경우에는 무조건 true를 반환한다.123456const animals = ['bears', 'cats', 'dogs', 'elephants', 'giraffes'];animals.every(animal =&gt; animal.length &lt; 5); // falseanimals.every(animal =&gt; animal.length &lt; 10); // trueconst beers = [];beers.every(beer =&gt; beer === ‘beer’); // true 참고: Array.prototype.every() - JavaScript | MDN .some() every() 메서드와 비슷하면서 다르다. 배열의 요소 중 단 하나라도 조건식을 통과하면 true 를 반환한다. 빈 배열의 경우는 무조건 false를 반환한다.123456const nums = [1, 4, 23, 37, 55];nums.some(num =&gt; num &gt; 50); // truenums.some(num =&gt; num &gt; 60); // falseconst beers = [];beers.some(beer =&gt; beer === 'beer'); // false 참고: Array.prototype.some() - JavaScript | MDN","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://codeameba.github.io/categories/JavaScript/"}],"tags":[{"name":"til","slug":"til","permalink":"http://codeameba.github.io/tags/til/"},{"name":"TIL","slug":"TIL","permalink":"http://codeameba.github.io/tags/TIL/"},{"name":"Today I Learned","slug":"Today-I-Learned","permalink":"http://codeameba.github.io/tags/Today-I-Learned/"},{"name":"오늘배운것들","slug":"오늘배운것들","permalink":"http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Javascript","slug":"Javascript","permalink":"http://codeameba.github.io/tags/Javascript/"}]},{"title":"JavaScript Fundamental 04(마지막 업데이트: 20.04.08)","slug":"programming/js-fundamental-04","date":"2020-04-07T09:30:42.000Z","updated":"2020-04-08T10:21:36.691Z","comments":true,"path":"2020/04/07/programming/js-fundamental-04/","link":"","permalink":"http://codeameba.github.io/2020/04/07/programming/js-fundamental-04/","excerpt":"","text":"JS Study 자바스크립트를 다시 공부하며 놓쳤던 개념들을 정리함. 교재: 모던 자바스크립트 입문(이소 히로시 지음) 프로토타입 체인(prototype chain) 자바스크립트의 모든 객체는 [[Prototype]]이라고 하는 내부 슬롯(internal slot)을 지닌다. 하위 객체는 상위 객체의 prototype을 상속받으며, 상속받은 데이터는 __proto__에 저장된다.123456789101112131415const myCat = &#123; name: 'Lucy', sayHello: function() &#123; console.log('Hello! ' + this.name); &#125;&#125;;const yourCat = &#123; name: 'Tom'&#125;;yourCat.__proto__ = myCat;const whoseCat = &#123;&#125;;whoseCat.__proto__ = yourCat;whoseCat.sayHello(); // Hello! Tom 위와 같이 __proto__를 통해 하위 객체와 상위 객체가 이어져 있으며, 이를 프로토타입 체인 이라고 한다. 그리고, 자신과 가까운 객체의 프로퍼티부터 위로 거슬러 올라가며 검색하게 된다. Object.getPrototypeOF() ES 명세에서나 브라우저에서나 __proto__를 통한 접근은 권장하지 않는다. 따라서 프로토타입 메서드에 접근해야 할 때에는 Object.getPrototypeOf() 또는 Object.creat()를 활용하도록 하자. 참고: poiemaweb - 프로토타입 poiemaweb - 클래스 코어자바스크립트 - 프로토타입 상속 접근자 프로퍼티 일반적으로 값 을 가져올 때 쓰는 접근자 프로퍼티를 getter, 값을 수정할 때 쓰는 접근자 프로퍼티를 setter라고 부른다. 접근자 프로퍼티를 사용하는 이유 객체 밖에서 객체의 프로퍼티를 직접적으로 읽거나 쓰는 행위는 데이터의 유지 보수성을 해친다. 따라서, 객체가 가진 프로퍼티 값을 읽고 쓸 수 있는 특정 프로퍼티가 getter와 setter이다.1234567891011121314const person = &#123; _name: 'Tom', get name() &#123; return this._name; &#125;, set name(value) &#123; const str = value.charAt(0).toUpperCase() + value.substring(1); this._name = str; &#125;&#125;;console.log(person.name); // Tomperson.name = 'jane';console.log(person.name); // Jane 접근자 프로퍼티가 없는 객체에 접근자 프로퍼티를 추가하거나 정의할 때에는 Object.defineProperty나 Object.defineProperties 메서드를 사용한다. 12345678910111213141516171819let user = &#123;&#125;;Object.defineProperty(user, 'name', &#123; get() &#123; return this._name; &#125;, set(value) &#123; if (value.length &lt; 4) &#123; console.log('Too short! more than 4 characters'); return; &#125; this._name = value; &#125;&#125;);user.name = 'Peter';console.log(user.name); // Peteruser.name = 'Li'; // Too short! more than 4 characters 참고: 프로퍼티 getter와 setter","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://codeameba.github.io/categories/JavaScript/"}],"tags":[{"name":"til","slug":"til","permalink":"http://codeameba.github.io/tags/til/"},{"name":"TIL","slug":"TIL","permalink":"http://codeameba.github.io/tags/TIL/"},{"name":"Today I Learned","slug":"Today-I-Learned","permalink":"http://codeameba.github.io/tags/Today-I-Learned/"},{"name":"오늘배운것들","slug":"오늘배운것들","permalink":"http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Javascript","slug":"Javascript","permalink":"http://codeameba.github.io/tags/Javascript/"}]},{"title":"JavaScript Fundamental 03(마지막 업데이트: 20.03.24)","slug":"programming/js-fundamental-03","date":"2020-03-24T09:30:42.000Z","updated":"2020-04-07T09:21:16.345Z","comments":true,"path":"2020/03/24/programming/js-fundamental-03/","link":"","permalink":"http://codeameba.github.io/2020/03/24/programming/js-fundamental-03/","excerpt":"","text":"JS Study 자바스크립트를 다시 공부하며 놓쳤던 개념들을 정리함. 교재: 모던 자바스크립트 입문(이소 히로시 지음) 실행 컨텍스트(Execution Centext) 자바스크립트 엔진은 실행 가능한 코드(Executable Code)를 만나면 그 코드를 평가(Evaluation)하여 실행 컨텍스트(Execution Context)를 만든다. 실행 컨텍스트는, 실행 가능한 코드가 실제로 실행되고 관리되는 영역이다. 실행에 필요한 모든 정보를 여러 컴포넌트에 나누어서 관리함. 렉시컬 환경(Lexical Environment) 환경 레코드(Environment Record) 선언적 환경 레코드(Declarative Environment Record) 객체 환경 레코드(Object Environment Record) 외부 렉시컬 환경 참조(Outer Lexical Environment Reference) 변수 환경(Variable Environment) 디스 바인딩(This Binding) 실행 컨텍스트의 구조를 의사 코드로 표현하면 아래와 같다. 123456789101112// 실행 컨텍스트의 구조를 보여주는 pseudo codeExecutionContext = &#123; LexicalEnvironment: &#123; EnvironmentRecord: &#123; DeclarativeEnvironmentRecord: &#123;&#125;, ObjectEnvironmentRecord: &#123;&#125; &#125;, OuterLexicalEnvironmentReference: &#123;&#125; &#125;, VariableEnvironment: &#123;&#125;, ThisBinding: null&#125; 참고: (JavaScript) 함수의 범위(scope) - lexical scoping - ZeroCho Blog (JavaScript) 실행 컨텍스트 - 클로저와 호이스팅 - ZeroCho Blog 클로저 - JavaScript | MDN Execution context and the call stack — visually illustrated by a slice of tasty cake Understanding Execution Context and Execution Stack in Javascript 렉시컬 환경(Lexical Environment) 자바스크립트 엔진이 코드를 실행하기 위해 자원을 모아 둔 곳 해당 유효 범위(Scope) 안에 있는 식별자와 식별자가 가리키는 값을 key : value의 형태로 바인드하여 렉시컬 환경 컴포넌트에 기록한다. 1234LexicalEnvironment: &#123; EnvironmentRecord: &#123;&#125;, OuterLexicalEnvironmentReference: &#123;&#125;&#125; 렉시컬 환경 컴포넌트에는 위와 같이 환경 레코드(Environment Record) 와 외부 렉시컬 환경 참조(Outer Lexical Environment Reference) 가 있다. 환경 레코드: 유효 범위 내의 식별자와 값이 기록되어 있으며, 함수가 호출되면 1차적으로 이곳에서 식별자를 탐색한다. 외부 렉시컬 환경 참조: 유효 범위 너머의 식별자와 값이 기록되어 있는 곳으로, 환경 레코드에서 해당 식별자를 찾을 수 없을 때 외부 렉시컬 환경 참조를 탐색하게 된다. 최상위의 렉시컬 환경은 전역 환경(Global Environment) 과 바인딩되어 있으며, 이곳에서의 외부 렉시컬 환경 참조는 null이다. 결국 호이스팅(Hoisting)은, 자바스크립트의 식별자들이 해당 스코프의 렉시컬 환경에 등록된 결과라고 볼 수 있다. 콜 스택(Call Stack) 후입선출(LIFO, Last In First Out) 방식으로 아래부터 데이터를 쌓아 올려 가장 마지막에 추가된 데이터부터 내보내는 자료구조를 스택(Stack) 이라고 한다.이때, 데이터를 쌓는 행위를 push 라고 하고, 스택의 가장 윗부분에서 데이터를 꺼내는 행위를 pop 이라고 한다. 실행 컨텍스트(Execution Context)는 프로그램 실행 중 스택에 push되어 실행이 된다. 이때, 전역 코드(Global Execution Context)는 브라우저의 시작과 동시에 실행되어 브라우저를 종료할 때까지 스택의 가장 아래에 위치한다. 함수가 호출되면, 해당 실행 컨텍스트가 스택에 push 되어 실행되며, 해당 함수의 작업이 끝나면 호출했던 부분으로 제어권이 돌아오면서 스택에서 pop 된다. 이처럼 함수가 호출(Call)될 때마다 스택에 쌓인다 하여 콜 스택(Call Stack) 이라고 부른다. 참고: 자바스크립트의 동작원리: 엔진, 런타임, 호출 스택 • Captain Pangyo 스코프 체인(Scope Chain) 내부 스코프의 렉시컬 환경에서 필요한 식별자를 찾을 수 없을 때 외부 스코프의 렉시컬 환경을 점진적으로 탐색하게 되는데, 이처럼 렉시컬 환경을 매개로 내부와 외부의 스코프가 이어진 것을 스코프 체인(Scope Chain) 이라고 부른다.12345678910var a = 'A';function f() &#123; var b = 'B'; function g() &#123; var c = 'C'; console.log(a + b + c); &#125; g();&#125;f(); // ABC 위와 같은 중첩 함수가 있을 때, 식별자 탐색 과정을 단계별로 알아보자면 다음과 같다. g()의 렉시컬 환경의 선언적 환경 레코드(Declarative Environment Record)에서 식별자 c를 찾는다. g()의 선언적 환경 레코드에서 식별자 b를 찾지만 못 찾고, g()의 외부 렉시컬 환경 참조(Outer Lexical Environment Reference)에 기록된 상위 함수 f()로 이동하여 탐색한다. f()의 렉시컬 환경의 선언적 환경 레코드에서 식별자 b를 찾는다. f()의 선언적 환경 레코드에서 식별자 a를 찾지만 못 찾고, f()의 외부 렉시컬 환경 참조에 기록된 전역 렉시컬 환경(Global Lexical Environment)로 이동하여 탐색한다. 전역 렉시컬 환경의 객체 환경 레코드(Object Environment Record)에서 식별자 a를 발견한다. 이때의 외부 렉시컬 환경 참조는 null이다. 참고: Scope | PoiemaWeb 스코프(scope)와 실행 컨텍스트(execution context)의 차이 스코프는 변수의 유효 범위 이며, 실행 컨텍스트는 실행되는 코드 덩어리라는 추삭적 개념. 스코프는 함수가 정의될 때 결정되며, 실행 컨텍스트는 함수가 실행될 때 생성된다. 함수의 실행 절차12345678910111213141516var a = 1;function outer() &#123; console.log(a); // 1 function inner() &#123; console.log(a); // undefined var a = 3; &#125; inner(); console.log(a); // 1&#125;outer();console.log(a); // 1 위와 같은 코드가 있을 때 내부적인 실행 절차는 다음과 같다. 전역 실행 컨텍스트 생성 전역 변수 a 선언(호이스팅) 외부 함수 outer 선언(호이스팅) 변수 a에 1 할당 outer 함수 호출 및 outer 실행 컨텍스트 생성 함수 inner 선언(outer 스코프에서 호이스팅) outer 스코프에서 a 탐색하지만 찾을 수 없으므로 전역 스코프에서 재탐색 후 1 출력 중첩 함수 inner 호출 및 inner 실행 컨텍스트 생성 지역 변수 a 선언(inner 스코프에서 호이스팅) inner 스코프에서 a 탐색 후 출력하지만 호이스팅만 된 단계이므로 undefined 출력 지역 변수 a에 3 할당 inner 실행 컨텍스트 종료 제어권이 outer 실행 컨텍스트로 돌아오며 전역 스코프에서 변수 a 탐색 후 1 출력 outer 실행 컨텍스트 종료 전역 스코프에서 변수 a 탐색 후 1 출력 가비지 컬렉션(garbage collection) 자바스크립트 엔진 내부에는 가비지 컬렉터(garbage collector) 가 쉬지 않고 동작하며, 참조가 없는 객체를 메모리에서 해제한다. 그리고, 이러한 매커니즘을 가비지 컬렉션이라고 한다. 가비지 컬렉터 덕분에 메모리의 공간 확보를 직접 하지 않아도 되는 만큼 메모리에는 크게 신경 쓰지 않아도 되지만, 메모리 누수로 인해 퍼포먼스가 저하될 가능성이 없지 않기 때문에 전혀 고려하지 않아도 되는 것은 아니다. 참고: 가비지 컬렉션 클로저(closure) 클로저의 주 사용 목적은 외부로부터 내부의 상태를 숨기는 캡슐화(encapsulation) 에 있다.123456789101112function makeCounter() &#123; var count = 0; return f; function f() &#123; // 보통은 익명함수를 사용하지만, 편의를 위해 이름을 붙임 return count++; &#125;&#125;var counter = makeCounter();console.log(counter()); // 0console.log(counter()); // 1console.log(counter()); // 2 위와 같은 클로저가 있을 때 다음과 같은 특징을 알 수 있다. 외부 함수 makeCounter는 중첩 함수 f의 참조를 반환한다. 중첩 함수 f는 외부 함수 makeCounter의 지역 변수 count를 참조한다. 전역 변수 counter에 함수 makeCounter를 할당하였으므로, 전역 변수 counter는 중첩 함수 f의 함수 객체를 참조한다. f의 함수 객체는 함수 makeCounter의 렉시컬 환경 컴포넌트를 참조한다. 결과적으로, 전역 변수 counter는 중첩 함수 f의 함수 객체를 통해 간접적으로 외부 함수 makeCounter의 렉시컬 환경 컴포넌트를 참조한다. 클로저의 핵심: 외부 함수를 호출하면 해당 함수의 렉시컬 환경 컴포넌트가 생성되며, 중첩 함수의 함수 객체를 생성 및 반환한다. 외부 함수는 클로저를 생성하는 팩토리 함수이며, 클로저의 주 기능은 중첩 함수에 담겨있다. 외부 함수가 속한 렉시컬 환경 컴포넌트는 클로저 내부 상태 자체이며, 외부 함수가 호출될 때마다 새로 생성된다.123456789var counter = makeCounter();console.log(counter()); // 0console.log(counter()); // 1console.log(counter()); // 2var counter2 = makeCounter();console.log(counter2()); // 0console.log(counter2()); // 1console.log(counter2()); // 2 중첩 함수의 함수 객체가 있는 한 외부 함수가 속한 렉시컬 환경 컴포넌트는 지워지지 않으며, 외부 함수의 함수 객체가 사라져도 지워지지 않는다. 클로저 내부 상태(외부 함수의 지역 변수, 선언적 환경 레코드)는 외부로부터 은폐되어 있으며 중첩 함수 안에서만 읽거나 쓸 수 있다. 참고: 클로저 - 생활코딩 클로저 - JavaScript | MDN Closure | PoiemaWeb 네임 스페이스(Name space) 오염을 줄이는 방법전역 변수와 전역 함수 등을 남발하게 되면 라이브러리를 쓴다거나 협업을 할 때 식별자가 충돌할 수가 있다. 따라서 전역 변수의 사용이 불가피할 경우에는 소스 코드 상단에 모아서 한눈에 파악할 수 있게 하는 것이 좋다. 그리고, 네임 스페이스의 오염을 최소화 하기 위한 방법으로는 다음과 같은 것들이 있다. 객체를 네임 스페이스로 활용하기 프로그램을 대표할만한 이름의 전역 변수를 하나 생성하여 객체를 값으로 할당하고, 프로그램에서 필요한 모든 변수와 함수를 프로퍼티로 정의한다.12345678910var myApp = myApp || &#123;&#125;;myApp.name = 'Tom';myApp.showName = function() &#123; // something&#125;;myApp.view = &#123;&#125;; // 내부에 또 다른 네임 스페이스를 만들 수도 있다.myApp.view.draw = function() &#123; // something&#125;; 즉시 실행 함수로 감싸기 일시적인 처리를 수행하는 내용들을 즉시 실행 함수로 감싸면 중복된 이름이 있더라도 전역 네임 스페이스를 오염시키지 않고 실행이 가능하다. 모듈 패턴 모듈(module)은 여러 기능을 하나로 묶은 것으로, 클로저(closure)를 즉시 실행 함수(IIFE)로 감싼 형태다. 이를 통하여 내부의 변수나 함수는 은폐하고, 원하는 함수만 공개할 수 있다.1234567891011121314151617var Module = Module || &#123;&#125;;(function(_Module) &#123; var name = 'NoName'; // 프라이빗 변수 function getName() &#123; // 프라이빗 함수 return name; &#125; _Module.showName = function() &#123; // 퍼블릭 함수 console.log(getName()); &#125;; _Module.setName = function(x) &#123; // 퍼블릭 함수 name = x; &#125;;&#125;)(Module)Module.setName('Tom');Module.showName(); // Tom 참고: JavaScript 자바스크립트 모듈 패턴을 이용한 캡슐화 :: 심플한 코딩 백과사전 Object-Oriented Programming | PoiemaWeb (JavaScript) 디자인 패턴(싱글턴, 모듈, 생성자) - ZeroCho Blog apply, call, bind Function 객체의 메서드에는 apply와 call이 있으며, this 값과 함수의 인수를 사용하여 함수를 실행하는 메서드다. apply와 call은 동일하게 동작하며, 유일한 차이점은 인수를 넘기는 방식이다. apply는 배열로 인수를 넘기고, call은 쉼표로 구분한 값의 목록으로 인수를 넘긴다. 12345678function say(greetings, honorifics) &#123; console.log(greetings + '' + honorifics + this.name);&#125;const tom = &#123; name: 'Tom Sawyer' &#125;;const becky = &#123; name: 'Becky Thatcher' &#125;;say.apply(tom, ['Hello! ', 'Mr.']); // Hello! Mr.Tom Sawyersay.call(becky, 'Hi ', 'Ms.'); // Hi Ms.Becky Thatcher bind 역시 Function 객체의 메서드이며, 객체에 함수를 바인드하는 역할을 한다. 1234567function say(greetings, honorifics) &#123; console.log(greetings + '' + honorifics + this.name);&#125;const tom = &#123; name: 'Tom Sawyer' &#125;;const sayToTom = say.bind(tom);sayToTom('hello~ ', 'Mr.'); // hello~ Mr.Tom Sawyer 화살표 함수(arrow function)ES6에서는 익명함수의 단축 표현인 화살표 함수 표현식이 추가되었다. 화살표 함수 표현식은 아래와 같이 다양한 방법으로 작성이 가능하다. 1234567const square = (x) =&gt; &#123;return x*x&#125;; // 함수 표현식const f = (x, y, z) =&gt; &#123;...&#125;; // 인수가 여럿이라면 쉼표로 구분const square = x =&gt; &#123;return x*x&#125;; // 인수가 하나라면 괄호 생략 가능const f = () =&gt; &#123;...&#125;; // 인수가 없을 때에는 빈 괄호 필수const square = x =&gt; x*x; // 함수 바디에 return문만 있으면 return 생략 가능const f = (a, b) =&gt; (&#123;x:a, y:b&#125;); // 반환값이 객체 리터럴이라면 괄호 필수(x =&gt; x*x)(3); // 즉시실행함수(IIFE)로 화살표 함수 사용 가능 일반 함수와 화살표 함수의 차이. this 함수 리터럴로 정의한 함수는 this의 값이 함수를 호출할 때 결정되지만, 화살표 함수의 this값은 함수를 정의할 때 결정된다. arguments 변수가 없음 화살표 함수 안에는 arguments 변수가 정의되어 있지 않아 사용할 수 없다.12345const f = () =&gt; console.log(arguments);f(); // Uncaught ReferenceError: arguments is not definedconst s = function() &#123;console.log(arguments);&#125;;s(); // Arguments [callee: ƒ, Symbol(Symbol.iterator): ƒ] 생성자로 사용 불가 화살표 함수 앞에는 new 연산자를 붙여 호출할 수 없다.1234567const Person = (name, age) =&gt; &#123;this.name = name; this.age = age;&#125;;const Tom = new Person('Tom', 25); // Uncaught TypeError: Person is not a constructorconst Coffee = function(name, price) &#123;this.name = name; this.price = price;&#125;;const americano = new Coffee('Americano', 4100);console.log(americano); // Coffee &#123;name: \"Americano\", price: 4100&#125;console.log(americano.price); // 4100 yield 키워드를 쓸 수 없다 화살표 함수 안에서는 yield 키워드를 쓸 수 없으며, 따라서 화살표 함수는 제너레이터의 기능을 수행할 수 없다. 참고: 화살표 함수 - JavaScript | MDN Arrow function | PoiemaWeb 화살표 함수 기초 화살표 함수에 대한 재고 메서드와 ‘this’ 제너레이터 이터레이터(iterator) 이터레이터는 반복 처리(iteration)가 가능한 객체 를 말한다. [Symbol.iterator] 메서드를 갖고 있는 객체를 반복 가능(iterable) 한 객체 라고 한다. 주의해야 할 것은 이터레이터 객체 != 이터러블 객체 라는 점이다. 또한 이터러블 != 유사 배열 역시 다르다. 유사 배열에는 index와 length 프로퍼티가 있다. 이터러블이라고 해서 꼭 유사 배열인 것은 아니며, 유사 배열이라고 해서 꼭 이터러블인 것도 아니다. 그러나 이터러블과 유사 배열의 특성을 동시에 갖는 객체도 있다. 대표적으로 문자열(String)이 그렇다.1234567const str = 'string';// 아래와 같이 이터러블의 [Symbol.iterator] 메서드와// 유사 배열의 index, length 프로퍼티를 동시에 지닌다.str[Symbol.iterator](); // StringIterator &#123;&#125;str.length; // 6str[0]; // \"s\" 참고: iterable 객체 제너레이터(generator) 반복 가능한 이터레이터를 값으로 반환 작업의 일시 정지와 재시작이 가능하며 자신의 상태를 관리 제너레이터는 아래와 같이 function* 문으로 정의하며, 하나 이상의 yield 표현식을 포함한다.1234567891011function* gen() &#123; yield 1; yield 2; yield 3;&#125;const iter = get();console.log(iter.next()); // &#123;value: 1, done: false&#125;console.log(iter.next()); // &#123;value: 2, done: false&#125;console.log(iter.next()); // &#123;value: 3, done: false&#125;console.log(iter.next()); // &#123;value: undefined, done: true&#125; 위와 같이 제너레이터 함수의 yield는 프로그램이 일시적으로 정지하는 위치라고 할 수 있다. yield 표현식은 지정된 표현식을 값으로 갖고, 이를 변수에 대입할 수 있다.1const a = yield 2; 제너레이터로 생성한 이터레이터는 이터러블이므로 for..of문을 쓸 수 있다. 참고: yield - JavaScript | MDN ES6의 제너레이터를 사용한 비동기 프로그래밍 : TOAST Meetup 제너레이터","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://codeameba.github.io/categories/JavaScript/"}],"tags":[{"name":"til","slug":"til","permalink":"http://codeameba.github.io/tags/til/"},{"name":"TIL","slug":"TIL","permalink":"http://codeameba.github.io/tags/TIL/"},{"name":"Today I Learned","slug":"Today-I-Learned","permalink":"http://codeameba.github.io/tags/Today-I-Learned/"},{"name":"오늘배운것들","slug":"오늘배운것들","permalink":"http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Javascript","slug":"Javascript","permalink":"http://codeameba.github.io/tags/Javascript/"}]},{"title":"JavaScript Fundamental 02(마지막 업데이트: 20.03.21)","slug":"programming/js-fundamental-02","date":"2020-03-21T09:30:42.000Z","updated":"2020-03-24T10:24:24.825Z","comments":true,"path":"2020/03/21/programming/js-fundamental-02/","link":"","permalink":"http://codeameba.github.io/2020/03/21/programming/js-fundamental-02/","excerpt":"","text":"JS Study 자바스크립트를 다시 공부하며 놓쳤던 개념들을 정리함. 교재: 모던 자바스크립트 입문(이소 히로시 지음) 함수를 사용하는 이유 재사용이 가능하다. 동일한 작업이 반복될 경우 해당 작업을 하는 함수를 만들어 필요한 곳에서 호출만 하면 되기 때문에 코드가 간결해진다. 프로그램을 이해하기 쉽다. 함수의 이름을 알아보기 쉽게 지으면, 함수명만 보고도 프로그램의 흐름을 파악하기 쉽다. 프로그램의 수정이 간단해진다. 수정해야 할 일이 있을 때 해당되는 함수만 수정하면 된다. 함수를 정의하는 방법 함수 선언문123function square(x) &#123; return x * x;&#125; 함수 리터럴123const square = function(x) &#123; return x * x;&#125;; Function 생성자1const square = new Function('x', 'return x * x); 화살표(arrow) 함수 표현식1const square = x =&gt; x * x; 함수 선언문을 제외한 세 가지 방법은 호이스팅이 되지 않기 때문에 변수에 할당 후에 사용이 가능 하며, 따라서 호출하는 코드보다 상단에 위치해야 한다. 생성자 함수 Java나 C++ 등의 객체지향 언어에는 클래스(class) 라는 객체 생성 방법이 있다. 자바스크립트에는 클래스가 없지만, 대신 프로토타입(prototype) 이 있기 때문에 클래스와 유사한 방식으로 객체를 생성할 수 있다. 생성자 함수를 통해 동일한 이름에 프로퍼티 값이 다른 객체 를 효율적으로 생성할 수 있다. 1234567function Card(suit, rank) &#123; this.suit = suit; this.rank = rank;&#125;const card = new Card('Heart', 'A');console.log(card); // Card &#123; suit: 'Heart', rank: 'A' &#125; 이때, 통상적으로 생성자 함수라는 것을 알리기 위해 파스칼 케이스를 쓴다. 이와 같이 생성된 객체를 인스턴스 라고 부르는데, 본래 객체지향 언어에서의 인스턴스와는 차이가 있지만, 일반 객체와 구분하기 위해 편의상 인스턴스라고 부른다. this 는 생성자가 생성하는 객체를 가리킨다. 즉, 생성자 함수 내부의 this 는 인스턴스를 가리킨다고 볼 수 있다. 참고: ‘new’ 연산자와 생성자 함수 클래스와 기본 문법 Classes - JavaScript | MDN 자바스크립트의 객체 자바스크립트의 객체는 크게 세 종류 로 구분할 수 있다. 네이티브 객체 ECMAScript 스펙에 따라 정의된 객체를 네이티브 객체(native object)다. Array, Function, Number 등의 내장 생성자로 생성된 객체와 JSON, Math, Reflect 등이 네이티브 객체에 포함된다. 호스트 객체 자바스크립트 실행 환경에 정의된 객체를 호스트 객체(host object)라고 한다. Window, Navigator, History, Screen 등 브라우저 객체와 DOM 객체, Ajax를 위한 XMLHttpRequest 객체, HTML5의 여러 API에 이르기까지 클라이언트 측 자바스크립트에 정의된 객체들이 포함된다. 사용자 정의 객체 사용자가 직접 정의한 코드의 실행 결과로 생성된 객체를 말한다. 희소 배열(sparse array)123456const a = ['A', 'B', 'C'];a[4] = 'E';console.log(a); // [\"A\", \"B\", \"C\", empty, \"E\"]console.log(a[3]); // undefinedconsole.log(a.length); // 5a.hasOwnProperty(\"3\"); // false 위와 같이 length가 요소의 개수보다 클 때 희소 배열 이라고 부른다. 이때 배열은 내부적으로 객체 의 형태로 저장되어 있으며, 리터럴로 표현하자면 아래와 같다.123456const a = &#123; '0':'A', '1':'B', '2':'C', '4':'E'&#125;; 표현식(expression) 표현식이란 결과적으로 어떤 값으로 평가(evaluation)되는 것 number, string, boolean 등의 원시 값(primitive value)은 그 자체로 가장 간단한 표현식이라고 할 수 있다.12343.14\"hello\"truenull 변수, 프로퍼티, 배열 요소, 함수 호출, 메서드 호출 등 또한 표현식이라고 할 수 있다.12345sumcircle.radiusa[3]square(5)card.getSum() 연산자가 더해지더라도 결과적으로 값으로 평가된다면 역시 표현식이다. 단항 연산자, 이항 연산자, 삼항 연산자 모두 그렇다.1234const a = 1;const b = 2;const c = a !== b ? 'hello' : 'world';console.log(c); // hello 자바스크립트의 문자열은 불변(immutable) 자바스크립트는 원시 값을 처리할 때 원시 값을 래퍼(wrapper) 객체로 자동 변환한다. 문자열은 String 객체, 숫자는 Number 객체, 논리값은 Boolean 객체 null과 undefined는 래퍼 객체가 없음. 래핑은 일시적으로 진행되며 처리가 끝나면 곧바로 메모리에서 삭제된다. 따라서 문자열을 직접 객체화 하지 않더라도 String 객체의 메서드를 사용할 수 있다. 또한, 자바스크립트의 문자열은 불변 이므로 메서드를 통해 반환되는 새로운 문자열은 원본 문자열과 별개의 값이다.1234const randomString = 'microsoft';const newString = randomString.replace('soft', 'hard');console.log(randomString); // microsoftconsole.log(newString); // microhard 참고 문자열 truthy와 falsy true나 false로 명시되어 있지 않더라도 논리값으로 평가되는 피연산자들이 있다. true로 평가되는 피연산자 0을 제외한 숫자, 빈 문자열을 제외한 문자열, 모든 객체, 심벌 false로 평가되는 피연산자 0, -0, 빈 문자열(“”), NaN, null, undefined truthy와 falsy에 각각 속한 피연산자들을 보면 나름대로의 일관성이 보이는 것을 알 수 있다. 대체적으로 없음 의 뉘앙스가 강한 쪽이 false로 평가된다. 암묵적 타입 변환 자바스크립트에서는 암묵적으로 타입을 변환하는 방법이 있다. 대표적으로 아래와 같은 방법으로 string을 number로 변환이 가능하다.1234var s = '2';console.log(s, typeof(s)); // 2 stringconsole.log(s-0, typeof(s-0)); // 2 numberconsole.log(+s, typeof(+s)); // 2 number 간단하고 편리한 방법이긴 하지만, 놓치고 지나칠 가능성이 농후하므로 되도록 parseInt(), Number()와 같은 명시적인 방법으로 타입을 변환하는 게 좋다고 생각한다. 대화상자의 종류 웹 브라우저의 전역 객체 window에는 대화상자 를 띄울 수 있는 방법이 세 가지가 있다. window.alert() 경고 대화상자를 표시 확인을 누르면 undefiend 반환 window.prompt() 사용자의 문자열 입력을 받을 수 있는 대화상자를 표시 문자열 입력 후 확인을 누르면 해당 문자열 반환 문자열을 입력하지 않고 확인을 누르면 빈 문자열(“”) 반환 취소를 누르면 null 반환 window.confirm() ‘확인’ 버튼과 ‘취소’ 버튼이 있는 대화상자를 표시 ‘확인’을 누르면 true를, ‘취소’를 누르면 false가 반환 for 문 실행순서123for (let i = 0; i &lt; 10; i++) &#123; console.log(i);&#125; 위와 같은 일반적인 for 문이 있을 때, 실행 순서는 다음과 같다. 변수 i를 선언 및 0으로 초기화 let i = 0 i가 10 보다 작은지 확인 i &lt; 10 블록문 실행 console.log(i) i의 값이 1 증가 i++ i의 값이 10이 될 때까지 1번 내용을 제외하고 반복 객체 지향 프로그래밍의 의미객체 지향 프로그래밍(OOP: Object Oriented Programming) 이란, 프로그램을 작성하는 방법 중 하나로 프로그램을 객체라고 부르는 부품 여러 개로 구성하여 만드는 방법이다. 이때, 객체란 데이터와 데이터를 처리하는 함수(메서드)를 한곳에 모아둔 덩어리를 말한다. 즉시 실행 함수(Immediately-invoked function) 자바스크립트에는 익명 함수를 정의하는 동시에 실행되는 즉시 실행 함수 라는 것이 있다. 즉시 실행 함수는 전역 유효 범위(global scope)를 오염시키지 않는 이름 공간(name space)를 생성할 때 사용한다. 즉시 실행 함수는 아래와 같이 정의한다.1234567891011121314151617181920// 첫 번째 방법(function() &#123; // something&#125;)();// 두 번째 방법(function() &#123; // something&#125;());// 인수를 넣을 수도 있음(function fact(n) &#123; if (n &lt;= 1) return 1; return n * fact(n - 1);&#125;)(5); // 120// 변수에 할당 가능const x = (function() &#123; // something&#125;)(); 인수의 생략 함수 정의식에서 요구하는 인자의 개수보다 적은 인수를 전달할 경우 생략된 부분은 undefined가 된다.1234function(x, y) &#123; console.log(`x = $&#123;x&#125;, y = $&#123;y&#125;`);&#125;f(2); // x = 2, y = undefined 만약 두 개 이상의 인자를 연산하여 반환해야 할 때에는 undefined가 나오는 것을 막기 위해 아래와 같이 or 연산자(||)를 활용할 수 있다.123456function multiply(a, b) &#123; b = b || 1; // b가 falsy값이면 1을 할당 return a * b;&#125;multiply(2, 3); // 6multiply(2); // 2 재귀함수 함수가 자기 자신을 호출하는 행위를 재귀 호출(recursive call)이라고 한다. 재귀 호출을 수행하는 함수를 재귀 함수 라고 한다.123456// 팩토리얼 재귀함수function fact(n) &#123; if (n &lt;= 1) return 1; return n * fact(n - 1);&#125;fact(5); // 120 재귀 함수를 정의할 때 유의해야 하는 사항 재귀 호출은 반드시 멈춰야 한다. 재귀 함수가 멈추는 조건이 반드시 있어야 하며, 그렇지 않으면 스택 오버플로우(stact overflow)를 일으키게 된다. 재귀 호출을 통해 문제를 간단히 해결할 수 있을 때만 사용한다. 재귀 함수는 메모리를 많이 차지하는 작업이다. 따라서 while문이나 for문으로 해결 가능하다면 재귀 함수를 지양하는 것이 좋다.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://codeameba.github.io/categories/JavaScript/"}],"tags":[{"name":"til","slug":"til","permalink":"http://codeameba.github.io/tags/til/"},{"name":"TIL","slug":"TIL","permalink":"http://codeameba.github.io/tags/TIL/"},{"name":"Today I Learned","slug":"Today-I-Learned","permalink":"http://codeameba.github.io/tags/Today-I-Learned/"},{"name":"오늘배운것들","slug":"오늘배운것들","permalink":"http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Javascript","slug":"Javascript","permalink":"http://codeameba.github.io/tags/Javascript/"}]},{"title":"유용한 웹사이트 모음(마지막 업데이트 2020.04.6)","slug":"programming/tip-useful-site","date":"2020-03-20T09:13:42.000Z","updated":"2020-04-06T09:16:46.091Z","comments":true,"path":"2020/03/20/programming/tip-useful-site/","link":"","permalink":"http://codeameba.github.io/2020/03/20/programming/tip-useful-site/","excerpt":"","text":"JavaScript JavaScript | MDN 코어 자바스크립트 웹 프로그래밍 튜토리얼 | PoiemaWeb Illustrated.dev JavaScript Event KeyCodes https://www.30secondsofcode.org/ Learn Startup - Build a successful business and change the world JavaScript 재입문하기 (JS ​튜토리얼) | MDN CSS Flexbox Froggy - A game for learning CSS flexbox CSS3 Patterns Gallery mydevice.io : web devices capabilities https://www.colorzilla.com/gradient-editor/ Mastering the :nth-child | CSS3 pseudo classes and :nth-child ranges A Complete Guide to Flexbox | CSS-Tricks Fresh Background Gradients | WebGradients.com 💎 Transition Timing Functions &lt; CSS | The Art of Web cubic-bezier.com Animate.css CSSBattle The Simpsons in CSS Griddy Autoprefixer CSS online http://gridcalculator.dk/ http://www.colors.commutercreative.com/grid/ uiGradients - Beautiful colored gradients Subtle Patterns | Free textures for your next web project CSS 레이아웃을 배웁시다 CSS 레이아웃 데모 HTML BEM Can I use… Support tables for HTML5, CSS3, etc Tool Git - Book Oven - HTML5-Powered Web/App Prototyping Tool Conventional Commits React velopert (Minjun Kim) - velog Content 개발자스럽다 44BITS 기술 블로그: 클라우드 컴퓨팅, 프로그래밍, 컨테이너, 리눅스 NAVER D2 Blog - 리디주식회사 RIDI Corporation TOAST Meetup VCNC Engineering Blog 우아한형제들 기술 블로그 DRAMA&amp;COMPANY | DReam And MAke it happen tech.kakao.com – 카카오는 사람과 사람, 사람과 기술을 한층 가깝게 연결함으로써, 어제보다 더 나은 세상을 만들어 갑니다. ZeroCho Blog 10 Amazing JavaScript Games In Under 13kB of Code - Tutorialzine","categories":[{"name":"tip","slug":"tip","permalink":"http://codeameba.github.io/categories/tip/"}],"tags":[{"name":"tip","slug":"tip","permalink":"http://codeameba.github.io/tags/tip/"},{"name":"유용한사이트","slug":"유용한사이트","permalink":"http://codeameba.github.io/tags/%EC%9C%A0%EC%9A%A9%ED%95%9C%EC%82%AC%EC%9D%B4%ED%8A%B8/"},{"name":"북마크","slug":"북마크","permalink":"http://codeameba.github.io/tags/%EB%B6%81%EB%A7%88%ED%81%AC/"},{"name":"즐겨찾기","slug":"즐겨찾기","permalink":"http://codeameba.github.io/tags/%EC%A6%90%EA%B2%A8%EC%B0%BE%EA%B8%B0/"}]},{"title":"JavaScript Fundamental 01(마지막 업데이트: 20.03.14)","slug":"programming/js-fundamental-01","date":"2020-03-14T09:30:42.000Z","updated":"2020-03-24T10:24:17.189Z","comments":true,"path":"2020/03/14/programming/js-fundamental-01/","link":"","permalink":"http://codeameba.github.io/2020/03/14/programming/js-fundamental-01/","excerpt":"","text":"JS Study 자바스크립트를 다시 공부하며 놓쳤던 개념들을 정리함. 교재: 모던 자바스크립트 입문(이소 히로시 지음) 자바스크립트의 재탄생 자바스크립트는 기존의 다른 프로그래밍 언어들과 달리 불확실한 요소가 많아 외면 당했었다. 구글 지도에서 선보인 Ajax라는 비동기 통신 기술 덕분에 자바스크립트가 재탄생하며, 관심을 받게 되었다. HTML5와 ES5의 등장은 자바스크립트에 날개를 달아주었다. 변수(variable) 변수는 값이 저장된 특정 메모리 영역을 가리키는 이름이다. 변수에 값을 할당하지 않고 선언만 하면 undefined가 담겨있다. var, let, const 등의 키워드 없이 선언된 변수는 전역변수로 취급한다. 변수 호이스팅(hoisting)123console.log(a); // undefinedvar a = 3;console.log(a); // 3 프로그램 중간에서 변수를 선언하더라도 첫머리에 선언된 것처럼 작동하는데, 이것을 호이스팅 이라고 한다. 단, 호이스팅이 되는 것은 선언문 뿐이며, 자동으로 undefined로 초기화 된다. getMonth() 메서드에 +1을 해야 하는 이유 new Date() 메서드 사용 시 getMonth() 는 0~11이기 때문에 +1을 해줘야 한다.1234const now = new Date();console.log(`오늘은 $&#123;now.getMonth()+1&#125; 월 $&#123;now.getDate()&#125; 일입니다.`); //오늘은 2 월 19 일입니다.console.log(now.getMonth()); //1 함수(function)의 동작원리 함수를 호출하며 인수(argument)를 전달하면, 함수 정의문의 인자(parameter)로 받아 실행 결과를 반환(return)한다. 자판기의 이미지가 연상됨. 특정 음료의 가격에 맞는 금액 투입(argument) 특정 음료의 버튼 누름(call) 투입된 금액과 호출된 음료의 값을 비교 가격이 맞으면 해당 음료 반환(return) 자바스크립트의 함수는 일급객체 함수를 값으로 쓸 수 있음. -&gt; 변수에 할당 가능 다른 함수의 인수(argument)로 전달 가능 함수 선언문의 호이스팅 변수와 마찬가지로 호이스팅이 됨 아래와 같은 함수선언문 은 전체가 통째로 호이스팅 됨123456console.log(square(5)); // 25// 함수선언문function square(x) &#123; return x * x;&#125; return이 없으면 undefined1234567console.log(square(5)); // undefinedfunction square(x) &#123; x * x;&#125;console.log(square(3)); // undefined 변수와 마찬가지로 선언문 만 호이스팅이 되기 때문에, 아래와 같은 함수표현식 은 변수명만 호이스팅이 됨.123456789// 기명 함수표현식const b = function bb() &#123; return 'bb';&#125;// 익명 함수표현식const c = function() &#123; return 'c';&#125; 함수의 호이스팅은 코드의 순차실행을 저해하고 예측을 어렵게 하기 때문에 되도록 함수표현식 의 사용을 권함 값의 전달, 참조의 전달12345678function add1(x) &#123; return x = x + 1;&#125;var a = 3;var b = add1(a);console.log(`a = $&#123;a&#125;, b = $&#123;b&#125;`); // a = 3, b = 4 위와 같이 인수로 원시값(primitive-type)을 전달하면, 해당 값 자체가 복사되어 전달된다. 이것을 값의 전달 또는 깊은 복사(deep copy) 라고 한다. 별도의 메모리 공간에 복사되는 것이기 때문에 변수 a와 인자 x는 별개의 값이며, x의 값이 바뀌더라도 a가 영향을 받지 않는다. 12345678910function add1(p) &#123; p.x = p.x + 1; p.y = p.y + 1; return p;&#125;var a = &#123;x:3, y:4&#125;;var b = add1(a);console.log(a, b); // &#123; x: 4, y: 5 &#125; &#123; x: 4, y: 5 &#125; 반면에 인수로 객체(object-type)을 전달했을 때에는 참조(reference)가 전달되는 것으로 이를 참조 전달 또는 얕은 복사(shallow copy) 라고 한다. 하나의 메모리 공간에 있는 객체를 각기 다른 곳에서 가리키고 있다는 이미지로 이해할 수 있으며, 따라서 p의 값이 바뀌자 a의 값도 바뀐 것이다. 스코프12345678910var a = 'global';function f() &#123; var b = 'local'; console.log(a); // global return b;&#125;f();console.log(b); // ReferenceError: b is not defined 위와 같이 함수 내부의 변수가 출력되지 않는 이유는 스코프(scope) 때문이다. 기본적으로 내부에서는 외부를 볼 수 있지만, 외부에서는 내부를 볼 수 없다 는 개념으로 이해할 수 있다. 코드가 작성되는 시점에 구문만으로 정해지는 스코프를 어휘적 스코프(lexical scope)라고 하며, 코드가 실행되는 와중에 정해지는 스코프를 동적 스코프(dynamic scope)라고 한다. 자바스크립트는 lexical scope를 따른다 스코프가 존재하는 가장 큰 이유는 식별자(identifier)의 충돌을 막기 위함이다. 메서드(method)123456789101112131415var circle = &#123; center: &#123; x:1.0, y:2.0 &#125;, // 원의 중심 radius: 2.5, // 원의 반지름 area: function () &#123; // 원의 넓이를 구하는 메서드 return Math.PI * this.radius * this.radius; &#125;&#125;;circle.translate = function(a, b) &#123; // 새로운 메서드를 추가하여 원을 이동 this.center.x = this.center.x + a; this.center.y = this.center.y + b;&#125;;circle.translate(1, 2);circle.center; // &#123;x: 2, y: 4&#125; 자바스크립트에서는 객체 내부의 데이터는 모두 프로퍼티(property)이며, 프로퍼티가 함수를 값으로 가질 때, 일반 프로퍼티와 구분하기 위해 메서드(method) 라고 칭한다. 일반적으로 메서드는, 메서드가 속한 객체의 내부 데이터(프로퍼티 값) 상태를 바꾸는 용도로 사용한다.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://codeameba.github.io/categories/JavaScript/"}],"tags":[{"name":"til","slug":"til","permalink":"http://codeameba.github.io/tags/til/"},{"name":"TIL","slug":"TIL","permalink":"http://codeameba.github.io/tags/TIL/"},{"name":"Today I Learned","slug":"Today-I-Learned","permalink":"http://codeameba.github.io/tags/Today-I-Learned/"},{"name":"오늘배운것들","slug":"오늘배운것들","permalink":"http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Javascript","slug":"Javascript","permalink":"http://codeameba.github.io/tags/Javascript/"}]},{"title":"불안의 이유","slug":"blog/do-it-now","date":"2020-02-20T09:05:42.000Z","updated":"2020-02-20T10:00:21.772Z","comments":true,"path":"2020/02/20/blog/do-it-now/","link":"","permalink":"http://codeameba.github.io/2020/02/20/blog/do-it-now/","excerpt":"","text":"대개의 경우 불안을 느끼는 이유는 부족함에 있다. 공부가 부족하여 아는 게 없을 때, 돈이 부족하여 할부금을 낼 수 없을 때, 시간이 부족하여 일을 마무리 할 수 없을 때 등. 그런데 재미있는 것은, ‘과거의 나’는 ‘지금의 나’의 불안을 예상 가능했다는 것이다. 그 말은 곧, 대부분의 불안은 ‘예측 가능한 미래보다 현재의 귀찮음이 앞설 때’ 이미 정해진다는 것이다. 불안이 싫다면, 지금 움직이자.","categories":[{"name":"생각정리","slug":"생각정리","permalink":"http://codeameba.github.io/categories/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/"}],"tags":[{"name":"블로그","slug":"블로그","permalink":"http://codeameba.github.io/tags/%EB%B8%94%EB%A1%9C%EA%B7%B8/"},{"name":"blog","slug":"blog","permalink":"http://codeameba.github.io/tags/blog/"},{"name":"생각정리","slug":"생각정리","permalink":"http://codeameba.github.io/tags/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/"},{"name":"불안의이유","slug":"불안의이유","permalink":"http://codeameba.github.io/tags/%EB%B6%88%EC%95%88%EC%9D%98%EC%9D%B4%EC%9C%A0/"}]},{"title":"[TIL] list와 tuple의 차이 그리고 dictionary","slug":"programming/python-til-01","date":"2020-02-18T04:40:42.000Z","updated":"2020-02-19T13:00:43.752Z","comments":true,"path":"2020/02/18/programming/python-til-01/","link":"","permalink":"http://codeameba.github.io/2020/02/18/programming/python-til-01/","excerpt":"","text":"리스트(list) 리스트는 재할당(assignment)이 가능 1234x = [1, 2, 3]x[0] = 5print(x) #[5, 2, 3] 튜플(tuple) 튜플은 재할당 불가능 1234x = (1, 2, 3)x[0] = 5print(x) #TypeError: 'tuple' object does not support item assignment 딕셔너리(dictionary) key : value 한 쌍으로 이루어진 자료구조 자바스크립트의 객체와 유사 12345678x = &#123; “hello”: “world”, “beer”: “good”, 3: “what”&#125;print(x[“beer”]) #goodprint(x[3]) #what 리스트와 딕셔너리의 활용 리스트에서 중복된 요소들을 딕셔너리로 정리 123456789101112fruit = [“사과”, “사과”, “바나나”, “바나나”, “딸기”, “키위”, “복숭아”, “복숭아”, “복숭아”]d = &#123;&#125;for f in fruit: if f in d: d[f] = d[f] + 1 else: d[f] = 1print(d)#&#123;'사과': 2, '바나나': 2, '딸기': 1, '키위': 1, '복숭아': 3&#125;","categories":[{"name":"Python","slug":"Python","permalink":"http://codeameba.github.io/categories/Python/"}],"tags":[{"name":"til","slug":"til","permalink":"http://codeameba.github.io/tags/til/"},{"name":"TIL","slug":"TIL","permalink":"http://codeameba.github.io/tags/TIL/"},{"name":"Today I Learned","slug":"Today-I-Learned","permalink":"http://codeameba.github.io/tags/Today-I-Learned/"},{"name":"오늘배운것들","slug":"오늘배운것들","permalink":"http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"},{"name":"python","slug":"python","permalink":"http://codeameba.github.io/tags/python/"},{"name":"파이썬","slug":"파이썬","permalink":"http://codeameba.github.io/tags/%ED%8C%8C%EC%9D%B4%EC%8D%AC/"}]},{"title":"Hexo 블로그에 디스커스(Disqus) 코드 추가하여 댓글 기능 넣기","slug":"blog/disqus-setting","date":"2020-02-14T16:00:42.000Z","updated":"2020-02-20T22:13:53.702Z","comments":true,"path":"2020/02/15/blog/disqus-setting/","link":"","permalink":"http://codeameba.github.io/2020/02/15/blog/disqus-setting/","excerpt":"","text":"디스커스(Disqus)네이버 블로그나 티스토리 같은 블로그 서비스에는 자체적인 댓글 기능이 있지만, Hexo, Jekyll, Gatsby 등의 정적 사이트로 블로그를 만든 경우에는 손수 댓글 기능을 추가해야만 한다. 내 경우에는 Hexo를 쓰고 있다. 물론, 테마에 따라서는 yml에 디스커스 ID를 추가하는 것만으로도 손쉽게 추가할 수도 있지만, 내가 쓰는 테마에는 없었기에 약간의 시행착오가 필요했다. 그리고, 마침내 코드를 추가하는 방식으로 디스커스 댓글 기능을 사용할 수 있게 되었고, 만약 나처럼 테마에 디스커스 항목이 없어서 당황할 사람들을 위해 기록을 남겨둔다.뭐, 미래의 내가 다시 보고 따라해야 할 수도 있고… 디스커스 코드 구하러 가기가입은 했다 치고, 디스커스에 접속한다. 그리고, GET STARTED를 클릭한다. 아래와 같은 페이지 넘어가게 되는데, 아이콘만 보더라도 댓글 기능처럼 보이는 위의 것을 선택한다. 그리고, 홈이 나오면, 우측 상단의 설정 메뉴에서 Admin을 눌러 이동한다. 이어서 나오는 페이지에서는 Installing Disqus를 클릭한다. ‘어라? 뭔가 잘못 찾아온 거 아닌가’ 싶을 것이다. 이어진 페이지에서 등장하는 아이콘들은 디스커스와 모종의 관계를 맺고 간단히 댓글 기능을 추가할 수 있는 자본의 노예들이다. 당황하지 말고 스크롤을 내리자.그리고, ‘난 너희랑 달라~’ 라는 생각을 하며 당당하게 Universal Code를 얻으러 간다. 이것이 디스커스 댓글 기능이 담긴 코드다. 12345678910111213141516171819&lt;div id=\"disqus_thread\"&gt;&lt;/div&gt;&lt;script&gt;/*** RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*//*var disqus_config = function () &#123;this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variablethis.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable&#125;;*/(function() &#123; // DON'T EDIT BELOW THIS LINEvar d = document, s = d.createElement('script');s.src = 'https://본인블로그URL/embed.js';s.setAttribute('data-timestamp', +new Date());(d.head || d.body).appendChild(s);&#125;)();&lt;/script&gt;&lt;noscript&gt;Please enable JavaScript to view the &lt;a href=\"https://disqus.com/?ref_noscript\"&gt;comments powered by Disqus.&lt;/a&gt;&lt;/noscript&gt; 디스커스 코드 추가하기코드는 구했으니 이제 정적 페이지 소스 코드에 추가해야 한다.내 경우에는 블로그를 구성하는 테마의 확장자가 ejs로 되어 있으며, 파일명을 통해 어느 페이지와 파트를 구성하는 지 대략 확인 가능하다. 댓글의 위치가 가장 하단이라고 해서 자칫 footer.ejs에 코드를 추가하는 불상사는 없길 바란다. 메인 페이지부터 컨텍 페이지까지 댓글이 달리게 되는 수가 있다. 물론, 그것이 바라던 바라면 그렇게 해도 무방하다.하지만, 나는 포스트에만 댓글이 추가되길 바라기 떄문에 pose.ejs에 코드를 추가했다. 디스커스 스타일 변경아마 디스커스 코드만 추가하고 잘 붙었나~ 확인해보면, 아래와 같이 너비가 100%일 것이다. 이대로 마음에 든다면 그냥 써도 되겠지만, 내 포스트는 모두 최대 너비를 780px로 통일했기 때문에 조정이 필요했다. 따라서 블로그 테마의 CSS를 조금 만져야 했다. 이 또한 경우에 따라 다를 수 있겠지만, 대개의 경우 나처럼 styl(스타일러스)로 되어 있을 것이며, 만약 아니더라도 사용상의 차이는 크지 않을 것이다. 이 중에서 건드려야 할 것은 custom.styl이다. 디스커스 코드의 ID는 disqus_thread이며, 아래와 같이 스타일을 변경하였고, 1234#disqus_thread &#123; max-width: 780px; margin: 50px auto; &#125; 결과적으로 지금의 형태가 되었다.","categories":[{"name":"tip","slug":"tip","permalink":"http://codeameba.github.io/categories/tip/"}],"tags":[{"name":"댓글기능구현","slug":"댓글기능구현","permalink":"http://codeameba.github.io/tags/%EB%8C%93%EA%B8%80%EA%B8%B0%EB%8A%A5%EA%B5%AC%ED%98%84/"},{"name":"디스커스","slug":"디스커스","permalink":"http://codeameba.github.io/tags/%EB%94%94%EC%8A%A4%EC%BB%A4%EC%8A%A4/"},{"name":"disqus","slug":"disqus","permalink":"http://codeameba.github.io/tags/disqus/"},{"name":"hexo","slug":"hexo","permalink":"http://codeameba.github.io/tags/hexo/"},{"name":"블로그","slug":"블로그","permalink":"http://codeameba.github.io/tags/%EB%B8%94%EB%A1%9C%EA%B7%B8/"},{"name":"blog","slug":"blog","permalink":"http://codeameba.github.io/tags/blog/"}]},{"title":"2020년은 황금시대일지도 모른다","slug":"blog/golden-age","date":"2020-02-06T08:41:42.000Z","updated":"2020-02-06T08:53:13.697Z","comments":true,"path":"2020/02/06/blog/golden-age/","link":"","permalink":"http://codeameba.github.io/2020/02/06/blog/golden-age/","excerpt":"","text":"과거를 동경하는 문화는 어느 시대에나 있었을 것이다. 지금 80-90년대의 레트로 문화가 성행하듯이 말이다. 르네상스, 황금시대 등의 이름 역시 당대에 붙여진 이름이 아닌, 후대의 사람들이 과거를 동경하며 불렀을 이름이다. 현재가 아무리 최악의 시대라고 불리며, 살아가기에 녹록지 않긴 하지만, 먼 훗날 누군가는 2020년을 황금시대라며 동경할지도 모를 일이다.","categories":[{"name":"생각정리","slug":"생각정리","permalink":"http://codeameba.github.io/categories/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/"}],"tags":[{"name":"블로그","slug":"블로그","permalink":"http://codeameba.github.io/tags/%EB%B8%94%EB%A1%9C%EA%B7%B8/"},{"name":"blog","slug":"blog","permalink":"http://codeameba.github.io/tags/blog/"},{"name":"생각정리","slug":"생각정리","permalink":"http://codeameba.github.io/tags/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/"},{"name":"황금시대","slug":"황금시대","permalink":"http://codeameba.github.io/tags/%ED%99%A9%EA%B8%88%EC%8B%9C%EB%8C%80/"},{"name":"미드나잇인파리","slug":"미드나잇인파리","permalink":"http://codeameba.github.io/tags/%EB%AF%B8%EB%93%9C%EB%82%98%EC%9E%87%EC%9D%B8%ED%8C%8C%EB%A6%AC/"}]},{"title":"허니와 클로버","slug":"blog/honey-and-clovar","date":"2020-02-05T09:05:42.000Z","updated":"2020-02-06T08:51:58.272Z","comments":true,"path":"2020/02/05/blog/honey-and-clovar/","link":"","permalink":"http://codeameba.github.io/2020/02/05/blog/honey-and-clovar/","excerpt":"","text":"20대 초반에 우연히 보게 된 허니와 클로버는 당시 혼란스러웠던 내 마음을 대변해주는 것 같았고, 10년이 훌쩍 지난 지금까지도 마음이 꺾일 것 같을 때면 다시 정주행을 하며 의욕을 재충전하는 나의 최애 콘텐츠로 자리 잡았다. 또, 수차례 정주행 하며 알게 된 또 하나의 사실은, 내 나이와 상황에 따라 감정이입을 하게 되는 캐릭터가 달라진다는 점이다. 처음에는 진로와 자아에 대해 고민하며 뛰어난 재능 앞에 열등감을 느끼는 타케모토에게서 나를 봤다면, 다음에는 얽히고설킨 인간관계 사이에서 망설이는 마야마에게서, 그리고 지금은 어른이 되어서도 여전히 과거의 고민으로부터 벗어나지 못하는 하나모토 교수에게서 내 모습이 보인다. 그리고 아무리 마음에 와닿는 장면이라도 담담하게 볼 수 있던 예전과는 달리, 몇 번씩 울컥하게 된다. 이것은 내가 감정적으로 성숙했다는 긍정적인 의미로 해석하면 될까.","categories":[{"name":"생각정리","slug":"생각정리","permalink":"http://codeameba.github.io/categories/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/"}],"tags":[{"name":"블로그","slug":"블로그","permalink":"http://codeameba.github.io/tags/%EB%B8%94%EB%A1%9C%EA%B7%B8/"},{"name":"blog","slug":"blog","permalink":"http://codeameba.github.io/tags/blog/"},{"name":"생각정리","slug":"생각정리","permalink":"http://codeameba.github.io/tags/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/"},{"name":"허니와클로버","slug":"허니와클로버","permalink":"http://codeameba.github.io/tags/%ED%97%88%EB%8B%88%EC%99%80%ED%81%B4%EB%A1%9C%EB%B2%84/"}]},{"title":"종이책으로의 회귀","slug":"blog/return-to-text","date":"2020-02-04T05:43:42.000Z","updated":"2020-02-05T09:10:11.882Z","comments":true,"path":"2020/02/04/blog/return-to-text/","link":"","permalink":"http://codeameba.github.io/2020/02/04/blog/return-to-text/","excerpt":"","text":"콘텐츠의 포맷에 따라 여백의 비중이 다르다. 여기서 말하는 여백이란, 독자가 전•후 사정과 배경을 상상할 수 있는 여지를 뜻한다. 예를 들어 텍스트 콘텐츠의 여백이 50% 라면, 이미지 콘텐츠는 30%, 동영상 콘텐츠는 10% 쯤 될 것이다. 그런 점에서 동영상 콘텐츠의 이용률이 월등한 지금의 세대는 본인의 상상으로 채울 수 있는 여지가 지극히 적을 수밖에 없다. 사람은 기본적으로 상상을 기반으로 자신만의 세계관을 구축하고자 하는 욕구가 있으며, 이들은 결국 동영상 콘텐츠가 채워주지 못하는 여백에 대한 갈증을 채우기 위해 텍스트 콘텐츠를 찾게 될 것이다. 나아가 종이책에서만 느낄 수 있는 온기와 질감을 동경하여 종이책으로 회귀하게 될 것이다. 이것은, 종이책을 사랑하는 사람의 예측 혹은 바람이다.","categories":[{"name":"생각정리","slug":"생각정리","permalink":"http://codeameba.github.io/categories/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/"}],"tags":[{"name":"블로그","slug":"블로그","permalink":"http://codeameba.github.io/tags/%EB%B8%94%EB%A1%9C%EA%B7%B8/"},{"name":"blog","slug":"blog","permalink":"http://codeameba.github.io/tags/blog/"},{"name":"생각정리","slug":"생각정리","permalink":"http://codeameba.github.io/tags/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/"}]},{"title":"내가 생각하는 좋은 콘텐츠","slug":"blog/what-is-good-content","date":"2020-02-03T07:19:42.000Z","updated":"2020-02-03T07:49:23.254Z","comments":true,"path":"2020/02/03/blog/what-is-good-content/","link":"","permalink":"http://codeameba.github.io/2020/02/03/blog/what-is-good-content/","excerpt":"","text":"첫째, 조금이라도 나은 사람이 되었다고 스스로 느낄 수 있는 콘텐츠가 좋은 콘텐츠의 기준이다. 모든 사람은 기본적으로 어제보다 오늘, 오늘보다 내일 더 나아지고자 하는 마음 즉, 향상심을 갖고 있다고 생각한다. 따라서 향상심을 충족시킬 수 있어야 좋은 콘텐츠다. 여기서 의미하는 향상심은 비단 지식적 측면만이 아닌, 감정적, 정신적 측면까지 포괄하는 개념이다. 둘째, 저자의 경험에서 비롯된 스토리가 더해진 콘텐츠는 더욱 좋은 콘텐츠다. 똑같은 인사이트를 전달하려는 콘텐츠라고 해도 콘텐츠 제작자의 경험을 바탕으로 한 스토리가 더해진 콘텐츠가 진정성 있는 콘텐츠이며, 그런 콘텐츠는 독자의 기억에 오랫동안 긍정적으로 남을 수 있다고 생각한다. 셋째, 기존에 몰랐던 새로운 시각까지 깨닫게 해주는 콘텐츠는 가장 좋은 콘텐츠다. 의도적으로 취향에 반하는 콘텐츠를 접하지 않는 이상, 사람들은 비슷한 성격의 콘텐츠를 이용하려는 관성이 있고, 콘텐츠 플랫폼의 추천 알고리즘은 이러한 관성에 더욱 힘을 싣고 있다. 물론, 자신만의 취향을 구축하고, 확고히 하는 것도 중요하지만, 취향에 갇혀 다른 시각과 경험의 기회를 놓치는 것은 결과적으로 안타까운 일이다. 만약, 세 가지 기준에 모두 만족하는 콘텐츠라면, 독자에게 ‘유쾌한 터닝포인트’를 선사할 수 있다고 생각한다. 개인적 경험을 바탕으로 좋은 콘텐츠라고 느꼈던 것들에는, 무라카미 하루키의 에세이 ‘이렇게 작지만 확실한 행복’, 벤 스틸러의 영화 ‘월터의 상상은 현실이 된다’, 우미노 치카의 만화 ‘허니와 클로버’가 있다. 이러한 콘텐츠들을 접했을 때, 고양감과 진정성을 느꼈으며, 새로운 시각으로 자신과 세상을 바라볼 수 있었다. 하지만 아무리 좋은 콘텐츠라도 독자에게 닿을 수 없으면, 가치를 인정받을 수 없다. 따라서 콘텐츠를 만드는 사람은, ‘좋은 콘텐츠를, 필요로 하는 독자에게 보기 좋은 형태로 제시할 수 있어야’ 한다고 생각한다.","categories":[{"name":"생각정리","slug":"생각정리","permalink":"http://codeameba.github.io/categories/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/"}],"tags":[{"name":"블로그","slug":"블로그","permalink":"http://codeameba.github.io/tags/%EB%B8%94%EB%A1%9C%EA%B7%B8/"},{"name":"blog","slug":"blog","permalink":"http://codeameba.github.io/tags/blog/"},{"name":"생각정리","slug":"생각정리","permalink":"http://codeameba.github.io/tags/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/"}]},{"title":"오류의 이해","slug":"blog/understanding-error","date":"2020-02-01T11:50:42.000Z","updated":"2020-02-03T07:54:34.369Z","comments":true,"path":"2020/02/01/blog/understanding-error/","link":"","permalink":"http://codeameba.github.io/2020/02/01/blog/understanding-error/","excerpt":"","text":"프로그래밍을 배울 때 들었던 말 중 가장 기억에 남는 말이, ‘오류를 이해하라’ 는 말이었다. 코딩을 하다 보면 다양한 형태의 오류가 다양한 상황에서 등장하는데, 구글에 복붙하여 찾아보고, 대강 수정하여 넘어가다 보면 동일한 오류가 다시 등장했을 때 대처를 못 하기 때문이다. 따라서 오류의 원인과 결과를 충분히 이해하고 넘어가야 한다는 것이다. 조금 더 부연설명을 하자면, 동일한 상황을 조성하여 의도적으로 동일한 오류를 발생시킬 수 있을 정도의 수준을 진정한 의미의 ‘오류의 이해’라고 할 수 있다. 그리고, ‘오류의 이해’가 필요한 곳은 비단 프로그래밍에만 국한된 것이 아니라고 생각한다. 삶을 살아가면서도 ‘나의 진짜 관심분야’, ‘다양한 상황에서의 인간관계’ 등 가설과 검증을 통한 ‘오류의 이해’가 유의미한 경우들이 있다. 물론, 극단적 가설에 의한 테스팅은 조금 곤란할지도…","categories":[{"name":"생각정리","slug":"생각정리","permalink":"http://codeameba.github.io/categories/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/"}],"tags":[{"name":"블로그","slug":"블로그","permalink":"http://codeameba.github.io/tags/%EB%B8%94%EB%A1%9C%EA%B7%B8/"},{"name":"blog","slug":"blog","permalink":"http://codeameba.github.io/tags/blog/"},{"name":"생각정리","slug":"생각정리","permalink":"http://codeameba.github.io/tags/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/"}]},{"title":"취향이 사람을 만든다","slug":"blog/taste-maketh-man","date":"2019-12-23T05:43:42.000Z","updated":"2020-02-05T09:02:05.909Z","comments":true,"path":"2019/12/23/blog/taste-maketh-man/","link":"","permalink":"http://codeameba.github.io/2019/12/23/blog/taste-maketh-man/","excerpt":"","text":"남들은 어떤지 모르겠지만 내 경우에는 서로의 취향을 하나씩 던지며 대화가 이어진다. 그것이 내 취향과 겹치면 공통된 이야기가 생겨서 좋고, 겹치지 않으면 내가 모르던 것을 알게 되니 좋다. 그래서 취향이 분명하지 않은 사람과 가까운 관계로 발전하기란 썩 쉽지 않다. 즐겨 듣는 음악, 좋아하는 작가, 사용하는 카메라의 브랜드, 혼자 시간을 보내는 방법 등 취향을 드러낼만한 것들은 참 많다. 꼭 고상한 것일 필요는 없다. 하다 못해 점심 메뉴를 고르는 확고한 기준이라도 좋다. 뭐라도 좋으니 “난 이게 좋고 저건 싫다”라고 분명하게 말할 수 있는 영역을 지닌 사람이 좋다. 취향은 곧 취미로 연결되고, 취미에 들이는 시간만큼 부정적인 생각에 사로잡힐 기회는 줄어든다. 물론 혼자 사색을 하는 시간도 소중하지만, 취향이 없는 사색은 알맹이 없는 몽상이 되기 쉽다. 그리고 그렇게 나이 드는 것은 너무나도 쓸쓸하지 않겠는가. 물론, 취향을 유지하기가 썩 쉽지 않은 시대라는 것은 잘 알고있다. 단지 취향일 뿐인데 손가락질을 받기도 하고, 적지 않은 돈이 들기도 하며, 때로는 이렇게까지 할 가치가 있는 건가… 싶을 때도 있다. 그럼에도 불구하고, 그런 시대이기에 더욱, 내 취향을 공고히 해야 할 필요가 있다. 취향은 곧, 나를 이루는 필수요소이며, 취향이 없이는 타인과 다른 ‘나’를 온전히 유지할 수도 없다.","categories":[{"name":"생각정리","slug":"생각정리","permalink":"http://codeameba.github.io/categories/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/"}],"tags":[{"name":"블로그","slug":"블로그","permalink":"http://codeameba.github.io/tags/%EB%B8%94%EB%A1%9C%EA%B7%B8/"},{"name":"blog","slug":"blog","permalink":"http://codeameba.github.io/tags/blog/"},{"name":"생각정리","slug":"생각정리","permalink":"http://codeameba.github.io/tags/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/"}]},{"title":"[Book Review] 마켓 4.0 : 소비자를 소비자로만 보면 안 되는 시대","slug":"blog/book-review-market-4","date":"2019-11-14T16:00:42.000Z","updated":"2020-02-06T08:51:44.821Z","comments":true,"path":"2019/11/15/blog/book-review-market-4/","link":"","permalink":"http://codeameba.github.io/2019/11/15/blog/book-review-market-4/","excerpt":"","text":"필립 코틀러의 마켓 4.0 필립 코틀러 저4차 산업혁명 시대, 시장과 소비자는 어떻게 바뀌나 그리고 기업은 어떤 전략을 세워야 할까 ‘불확실한’ ‘복잡한’ ‘혼란스러운’…. 아쉽게도 이런 단어들만큼 요즘의 경제 환경을 잘 표현해준 말은 없을 것이다. 자동화, 기계화로 대변되는 ICT의 발달은 ‘4차 산업혁명’이라 부를 수 있을 만큼 광범위한 변화를... 마케팅의 아버지라고 불리우는 필립 코틀러의 신간이다. 마켓 3.0 이후 7년만(정식 번역본 기준)에 출간하였는데, 그리 길지 않은 시간이었지만 스마트폰이 보급되어 초연결 사회가 도래한 만큼 마케팅의 방법 또한 바뀌어야 한다고 말하는 책이다. 그 배경에는 디지털이 가장 큰 원인으로 자리잡고 있겠지만, 그로 말미암아 주류 고객층까지 바뀌었다는 것에 의의가 있겠다. 과거에는 주류 고객이 연장자, 남성, 시티즌이었다면, 이제는 디지털 네이티브 세대라고 불리우는 젊은이, 여성, 네티즌이 시장을 주도한다. 그리고, 이 책은 그러한 변화에 마케터들이 어떻게 전략을 세울 것인가에 대한 친절한 조언을 건낸다. 이 책은, 크게 3개의 파트로 나누어져 있다. 1부에서는 필립 코틀러가 현재 우리가 살고 있는 세계를 관찰하고 알아낸 결과물들에 대해 말하고 있다. 조금 더 자세히 말하자면, 세계의 변화와 트렌드에 영향을 주는 힘의 세 가지 변화가 어떻게 일어났는지 짚어주고 있다. 2부에서는 이러한 변화 속에서 마케터로서 생산성을 높이기 위해 무엇을 해야 하는지 이야기 하고 있다. 끝으로 3부에서는 마켓 4.0 시대에 필수적인 주요 전술들을 설명하고 있다. 사실 개인적으로 느끼기에는 1부-1장에 마켓 4.0의 핵심이 담겨있다고 생각한다. 디지털 시대를 맞아 시장이 어떻게 변하였는지 단, 세 문장으로 말해주고 있다. 배타적에서 포용적으로수직적에서 수평적으로개인적에서 사회적으로 디지털화를 통해 초연결 사회가 되면서 전세계가 실시간으로 소통할 수 있는 시대가 열렸고, 자연스럽게 다양성을 존중하는 문화가 만들어졌다. 그에 발맞춰 다양한 소비자들의 집단 즉, 커뮤니티가 등장했고, 결국, 자본을 지닌 개인보다 연결된 전체가 강한 힘을 갖게 되었다. 이런 시대라서 벌어지는 또 다른 재미있는 구경거리들도 있는데, 경쟁 관계에 있는 기업들 또한, 수직적이 아닌 수평적 관계로 변화하고 있다는 점이다. 과거에는 빠르게 시장을 선점한 기업이 후발주자들을 저만치 떨어뜨린 채 독주를 하는 그림이 흔했다. 하지만, 요즘에는 그 어떤 기업도 영원한 1위로 남을 수 있다고 장담하지 못 한다. 불과 몇 개월 전까지 세상에 없던 기업이 ‘공유경제’라느니, ‘중간 유통 마진 제로’라느니 하는 등의 과거에는 상상도 못 했던 아이디어들로 금방 글로벌 기업 반열에 드는 시대인 것이다. 우버, 에어비앤비, 넷플릭스 등 디지털 시대를 맞아 급성장한 기업들이 이전까지 그 누구도 시도하지 않았던 아이디어를 들고 나온 것도 물론 맞지만, 그에 앞서 디지털 시대의 소비자들을 이해 했기 때문에 나올 수 있던 아이디어라고 할 수 있다. 지금의 그리고, 앞으로의 소비자들은 더 이상 기업이 일방적으로 타겟팅 할 수 있는 대상이 아니다. 브랜드와 소비자의 관계가 단순히 물건을 팔고, 사는 관계로 남는다면, 그 브랜드에게 미래는 없다고 볼 수 있다. 그 어느 때보다 가족처럼 친구처럼 진정성 있고 투명한 관계가 요구되는 시기라고 생각한다.","categories":[{"name":"내가 읽은 책","slug":"내가-읽은-책","permalink":"http://codeameba.github.io/categories/%EB%82%B4%EA%B0%80-%EC%9D%BD%EC%9D%80-%EC%B1%85/"}],"tags":[{"name":"마케팅","slug":"마케팅","permalink":"http://codeameba.github.io/tags/%EB%A7%88%EC%BC%80%ED%8C%85/"},{"name":"book review","slug":"book-review","permalink":"http://codeameba.github.io/tags/book-review/"},{"name":"마켓4.0","slug":"마켓4-0","permalink":"http://codeameba.github.io/tags/%EB%A7%88%EC%BC%934-0/"},{"name":"독후감","slug":"독후감","permalink":"http://codeameba.github.io/tags/%EB%8F%85%ED%9B%84%EA%B0%90/"}]},{"title":"[Book Review] 내가 했던 모든 일이 마케터의 일이었다","slug":"blog/book-review-work-of-marketer","date":"2019-10-09T07:38:42.000Z","updated":"2020-02-07T07:50:30.863Z","comments":true,"path":"2019/10/09/blog/book-review-work-of-marketer/","link":"","permalink":"http://codeameba.github.io/2019/10/09/blog/book-review-work-of-marketer/","excerpt":"","text":"마케터의 일 장인성 저/김규림 그림‘직업으로서의 마케터’를 이야기합니다오늘도 치열하게 목표를 세우고 방법을 찾고 계획을 실현하는 마케터들을 위한 책『마케터의 일』은 비슷한 고민을 거쳐 성장해온 선배 마케터가 후배 마케터들에게 전하는 이야기다. 저자는 마케터가 하는 일은 회사마다 개인마다 다르지만, 그럴수록 마케팅의 본질을 놓치지 말아... 현 시점 국내 기업 중 가장 핫한 마케팅을 하는 '배달의 민족'. 그곳의 CBO 장인성 님의 책이다. 저자는, 책을 쓰게 된 계기에 대하여 다음과 같이 말한다. “이 책은 어떤 IT서비스 회사에서 마케터들이 일상적으로 주고받는 이야기이자 마케터 장인성의 개인적 경험에 기반한 본격 ‘저는 이렇던데요’ 이야기 묶음집입니다. 어쩌면 이 책의 숨은 제목은 ‘마케터 장인성의 일’인지도 모릅니다. 처음에는 함께 일하는 주니어 마케터들에게 제 잔소리이자 경험자산을 나눠주려고 글을 쓰기 시작했습니다. 그렇데 쓰다 보니, 같이 일하는 마케터들뿐 아니라 옆 회사, 다른 회사, 경쟁사의 마케터들에게도 읽을 만한 글이 될 수 있겠다는 용감한(?) 생각이 들더라고요. 그래서 씁니다. 마케터의 일” 비록 내가 지금은 백수(또는 전업 집사)로 하루하루 즐겁게(?) 지내는 중이긴 하지만, 2014년부터 2018년까지는 마케터였다. 아니, 정확하게 말하자면 ‘나의 명함에 적혀있던 직함이 마케터’였다. 당시의 나는 마케팅에 대한 공부는 커녕 관심조차 없었는데 우연한 기회에 마케팅대행사에 들어가게 되었다. 지금 생각해보면 관심도 없는 일은 왜 했나 싶기도 하지만, 아마 조급했던 것 같다. 20대 중반, 군대를 다녀오고, 대학을 졸업하고, 전공(플라워디자인)을 살려 1년 정도 일을 해봤지만 이 길은 아니다 싶었다. 그렇다고 다른 일을 해보자니 막막하여 국비지원으로 편집디자인을 배우며 어설픈 포트폴리오를 만들었었다. 그렇게 만들어진 포트폴리오를 첨부하여 취업포탈사이트 몇 군데에 이력서를 등록했었는데 이를 본 마케팅대행사에서 먼저 연락이 온 것이었다. 근데 재밌는 것은, 당연히 디자이너로 뽑힌 줄 알았는데 마케터로 뽑았다는 점이다. 마케터가 무엇인지, 무슨 일을 하는지도 몰랐지만 앞서 말했듯 나는 조급했기에 어떤 이유였든 단지 나를 뽑아주었다는 그 호의를 고맙게 받았다. 내게 주어진 일들은 상당히 다양했다. 블로그에 장문의 글을 쓰거나 매월 콘텐츠 스케쥴을 짜기도 하고, 프로모션에 쓰일 포스터를 디자인 하기도 하고, 행사를 준비하기도 했으며, 인터뷰 질문을 구상하기도 하고, 제품이나 인물 사진을 찍기도 하고, 심지어 일본어나 영어로 된 원문을 번역하기도 했다. 이 외에도 모두 떠올리기 어려울 정도로 다양한 일을 했다. 기본적으로 다양한 분야에 관심이 있고, 새로운 것을 좋아하는 나로서는 무척 재미있게 일을 했었다. 3년차까지는. 자칫 3개월로 끝날 수 있었을 수습직원은 정직원이 되고, 주임이 되고, 3년차 쯤에는 대리가 되었다. 그렇다. 직장인들이 권태기라 부르는 ‘마의 3년차’였다. 나 역시 마의 3년차를 피할 수 없었는데, 당시 내 나이가 29살이라는 점도 큰 기여를 했던 것 같다. 단순히 일이 재미 없다기 보다는 목표의 부재와 미래에 대한 불안함. 뭐 그런 복합적인 상황이었는데, 지금 생각해보면, ‘마케터의 일’이 무엇인지 모르기 때문에 느꼈던 불안함이었던 것 같다. 막 성장하는 스타트업이었고, ‘이것이 마케터의 일이다!’라며 확신을 주는 백전노장 같은 사수가 없었다. 그들에게도 나에게도 대부분의 일들이 처음이었다. 그런 배경 속에서 자연스럽게 드는 생각이었다. ‘내가 지금 제대로 하고 있는 걸까?’‘여기에 과연 전문성이 있는 걸까?’‘굳이 내가 아니어도 누구나 심지어 갓 입사한 신입이라도 할 수 있는 일 아닐까?’ 생각이 많고 결단력이 있는 사람이라면 이런 상황에 놓였을 때 즉시 그만 두고 다른 길을 가거나 확신을 갖고 초심으로 돌아갈 것이다. 반면에 생각이 많고 우유부단한 사람은 이도 저도 아닌 상태로 고민만 지속할 뿐 이렇다 할만한 행동을 취하지 못 한다. 안타깝게도 난 후자였다. 물론 경우에 따라 신중함이라는 좋은 말로 포장할 수도 있긴 하지만, 그렇다 하더라도 나의 고민은 너무 길었다. 결국 답을 얻지 못한채 껍데기 뿐인 마케터로 지냈으며, 해가 넘어가기 직전에서야 퇴사를 결심했다. 서론부터 지지부진하고 재미없는 이야기를 길게 늘어놨는데, 그나마 글로 적어서 이 정도다. 내가 체감한 고민의 시간은 ‘내가 지금 시간과 정신의 방에 갇힌 게 아닐까’ 하는 생각이 들 정도로 길었다. 그리고, 100% 내 경험담인 이 이야기가 ‘마케터의 일’ 도입부에 등장한다. 물론 저자와 일면식도 없으니 내 사례를 가져가 쓴 것은 아닐 것이다. 그럼에도 불구하고 내가 놓였던 상황, 내가 했던 고민들과 놀랍도록 닮았다. 나는 허탈감과 동시에 개운함을 느꼈다. 내가 특수한 상황에 놓인 것도 아니었고, 내 고민이 이상한 것도 아니었던 것이다. 아, 좀 더 일찍 읽었더라면…… 마케터가 하는 일이 무엇인지 모르면서 그저 다양한 경험에 즐거워하고, 새로운 경험에 설레던 20대의 나. 마찬가지로 마케터가 하는 일이 무엇인지 모르기 때문에 불안해하고 고민하던 30대의 나. 이제야 알았다. 내가 했던 모든 일이 마케터의 일이었다. 마침내 내 방황에도 끝이 보이는 것 같다.","categories":[{"name":"내가 읽은 책","slug":"내가-읽은-책","permalink":"http://codeameba.github.io/categories/%EB%82%B4%EA%B0%80-%EC%9D%BD%EC%9D%80-%EC%B1%85/"}],"tags":[{"name":"마케팅","slug":"마케팅","permalink":"http://codeameba.github.io/tags/%EB%A7%88%EC%BC%80%ED%8C%85/"},{"name":"book review","slug":"book-review","permalink":"http://codeameba.github.io/tags/book-review/"},{"name":"독후감","slug":"독후감","permalink":"http://codeameba.github.io/tags/%EB%8F%85%ED%9B%84%EA%B0%90/"},{"name":"마케터의 일","slug":"마케터의-일","permalink":"http://codeameba.github.io/tags/%EB%A7%88%EC%BC%80%ED%84%B0%EC%9D%98-%EC%9D%BC/"}]},{"title":"TIL(190918) - Vue.js 01","slug":"programming/vue-til-01","date":"2019-09-17T16:00:42.000Z","updated":"2020-02-03T07:47:26.950Z","comments":true,"path":"2019/09/18/programming/vue-til-01/","link":"","permalink":"http://codeameba.github.io/2019/09/18/programming/vue-til-01/","excerpt":"","text":"TIL(190918) - Vue.js 01 Vue.js 시작하기 - Age of Vue.js를 보고 정리함 Vue.js Documents Vue.js Vue.js는 무엇인가? MVVM 패턴의 뷰모델 레이어에 해당하는 화면단 라이브러리 Model–view–viewmodel - Wikipedia DOM(View)을 조작하면 Vue.js(ViewModel) 내부의 DOM Listeners가 이를 인지하여 자바스크립트(Model)에 전달하고, 자바스크립트는 다시 Vue.js 내부의 Data Bindings를 통해 DOM에 데이터를 전달한다. 결과적으로 화면에 보여지는 내용 역시 변경된다. Vue.js를 쓰는 이유 Vue.js와 같은 프레임워크를 사용하지 않고 html, css, JavaScript만 사용한 기본적인 웹개발에서는 View를 바꾸려면 직접적으로 코드를 손봐야만 했다. 하지만 매번 변경할 때마다 사람이 손수 고치는 것은 무리가 있기 때문에 Vue.js같은 프레임워크를 사용한다. 결론적으로, View의 내용을 변경하면 내부의 코드가 자동적으로 변경되고 그 상태가 유지 될 수 있도록 하는 것에 의의가 있다. 이러한 것이 Vue.js의 핵심 사상인 Reactivity 반응형에 대해 깊이 알아보기 — Vue.js","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://codeameba.github.io/categories/JavaScript/"}],"tags":[{"name":"til","slug":"til","permalink":"http://codeameba.github.io/tags/til/"},{"name":"TIL","slug":"TIL","permalink":"http://codeameba.github.io/tags/TIL/"},{"name":"Today I Learned","slug":"Today-I-Learned","permalink":"http://codeameba.github.io/tags/Today-I-Learned/"},{"name":"오늘배운것들","slug":"오늘배운것들","permalink":"http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Javascript","slug":"Javascript","permalink":"http://codeameba.github.io/tags/Javascript/"},{"name":"vue.js","slug":"vue-js","permalink":"http://codeameba.github.io/tags/vue-js/"},{"name":"뷰","slug":"뷰","permalink":"http://codeameba.github.io/tags/%EB%B7%B0/"}]},{"title":"[ReactJS] 무비앱 만들기 Day 06","slug":"programming/react-movie-app-06","date":"2019-09-08T16:00:42.000Z","updated":"2020-02-03T07:47:26.945Z","comments":true,"path":"2019/09/09/programming/react-movie-app-06/","link":"","permalink":"http://codeameba.github.io/2019/09/09/programming/react-movie-app-06/","excerpt":"","text":"[ReactJS] 무비앱 만들기 Day 06 5.0 Container Presenter Pattern part One Container Presenter Pattern에서 컨테이너는 data와 state를 지니고, api를 불러온다. 그리고 모든 로직을 처리. 그 다음, 프레젠터가 그 data들을 보여주는 역할.(프레젠터에는 state가 없고, api도 모르며 클래스도 없고 단지 함수형 컴포넌트) 쉽게 말해서 프레젠터는 ‘스타일’, 컨테이너는 ‘데이터’ 각 컨테이너별 폴더를 따로 구성 폴더마다 index.js가 있어야 함. 컨테이너를 export해야 하기 때문. 이렇게 정리하는 게 혼란을 줄일 수 있음. index.js가 HomeContainer를 import / export하는 역할을 하고 HomeContainer는 state를 가진 모든 리액트 컴포넌트가 된다. src - Routes - Home - HomeContainer.js 12345678910111213141516171819202122232425import React from 'react';import HomePresenter from './HomePresenter';export default class extends React.Component &#123; state = &#123; nowPlaying: null, upcoming: null, popular: null, error: null, loading: true &#125;; render() &#123; const &#123; nowPlaying, upcoming, popular, error, loading &#125; = this.state; return ( &lt;HomePresenter nowPlaying=&#123;nowPlaying&#125; upcoming=&#123;upcoming&#125; popular=&#123;popular&#125; error=&#123;error&#125; loading=&#123;loading&#125; /&gt; ); &#125;&#125; 5.1 Container Presenter Pattern part Two search container는 상호작용이 필요하기 때문에 조금 까다로움 loading의 경우 기본값은 false 유저가 아무런 행동을 취하지 않았는데 로딩이 되면 안 되니까 12345678910111213141516171819202122232425import React from 'react';import SearchPresenter from './SearchPresenter';export default class extends React.Component &#123; state = &#123; MovieResults: null, TvResults: null, SearchTerm: '', error: null, loading: false &#125; render() &#123; const &#123; MovieResults, TvResults, SearchTerm, error, loading &#125; = this.state; return ( &lt;SearchPresenter MovieResults=&#123;MovieResults&#125; TvResults=&#123;TvResults&#125; SearchTerm=&#123;SearchTerm&#125; error=&#123;error&#125; loading=&#123;loading&#125; /&gt; ); &#125;&#125; 5.2 Home Container 두 가지 옵션이 있음 componentDidMount()를 통해 전체 api 요청을 할 수 있고 각각의 요청을 분리된 함수로 따로 요청할 수도 있음. ex) getNowPlaying(), getUpComing() 등등 이번 경우엔 굳이 분리할 필요가 없으므로 componentDidMount()를 사용함 try - catch try가 먼저 실행되고, 작동하지 않으면 error를 catch 한다. async / await 준비가 될 때까지 기다려달라는 의미 예를 들어 아래와 같은 상황에서 async/await이 없으면, nowPlaying 데이터를 가져오기 시작한다. 하지만 api가 리턴할 때까지 자바스크립트는 기다려주지 않음. 12345678910111213async componentDidMount() &#123; try &#123; await MoviesApi.nowPlaying(); &#125; catch &#123; this.setState(&#123; error: \"Can't find movis information.\" &#125;); &#125; finally &#123; this.setState(&#123; loading: false &#125;); &#125;&#125; 하지만, async/await을 쓰면 데이터가 준비될 때까지 자바스크립트가 기다려줌. 비구조화 할당 변수명에 data를 정할 때 비구조화 할당을 쓰면 보기 좋음1234567891011121314async componentDidMount() &#123; try &#123; const &#123; data: &#123; results: nowPlaying &#125;&#125; = await MoviesApi.nowPlaying(); console.log(nowPlaying); &#125; catch &#123; this.setState(&#123; error: \"Aw, Snap!\" &#125;); &#125; finally &#123; this.setState(&#123; loading: false &#125;); &#125;&#125; 5.3 TV Container Movies와 동일 5.4 Search Container 모든 로직을 갖는다. 첫 번째 로직은 handleSubmit 입력 폼에 text를 입력한 뒤 엔터키를 누르면 Submit이 됨 searchTerm이 공백이 아닌지 체크하고 search 함수를 실행할 것 특히 try는 다른 컨테이너와 다름 검색을 시도했을 때 로딩을 true로 만든다(기본값은 false).1234567891011121314151617181920212223242526272829handleSubmit = () =&gt; &#123; const &#123; searchTerm &#125; = this.state; if (searchTerm !== '') &#123; this.searchByTerm(); &#125;&#125;;searchByTerm = async() =&gt; &#123; const &#123; searchTerm &#125; = this.state; try &#123; const &#123; data: &#123; results: movieResults &#125;&#125; = await MoviesApi.search(searchTerm); const &#123; data: &#123; results: tvResults &#125;&#125; = await TvApi.search(searchTerm); this.setState(&#123; movieResults, tvResults &#125;) this.setState(&#123; loading: true &#125;) &#125; catch &#123; this.setState(&#123; error: \"Can't find results.\" &#125;); &#125; finally &#123; this.setState(&#123; loading: false &#125;); &#125;&#125;; 5.5 Detail Container part One Router Component에 Detail을 추가해야 함. Movie나 TV의 id를 가져와서 보여주는 방식 123456789101112131415export default () =&gt; ( &lt;Router&gt; &lt;&gt; &lt;Header /&gt; &lt;Switch&gt; &lt;Route path=\"/\" exact component=&#123;Home&#125; /&gt; &lt;Route path=\"/tv\" component=&#123;TV&#125; /&gt; &lt;Route path=\"/search\" component=&#123;Search&#125; /&gt; &lt;Route path=\"/movie/:id\" component=&#123;Detail&#125; /&gt; &lt;Route path=\"/tv/:id\" component=&#123;Detail&#125; /&gt; &lt;Redirect from=\"*\" to=\"/\" /&gt; &lt;/Switch&gt; &lt;/&gt; &lt;/Router&gt;); :id는 해당 위치는 랜덤한 id가 올 수 있음을 의미 id는 url에서 가져올 예정 Header component는 라우터의 위치를 알고 있음. withRouter로 감쌌기 때문에 id가 보기에는 숫자지만, typeof를 해보면 string으로 나옴 따라서 parseInt를 해줘야 함 id가 숫자가 아닌 경우에는 home으로 보냄 1234567async componentDidMount() &#123; const &#123; match: &#123; params: &#123; id &#125;&#125;, history: &#123; push &#125;&#125; = this.props; const parseId = parseInt(id); if(isNaN(parseId)) &#123; push('/'); &#125;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://codeameba.github.io/categories/JavaScript/"}],"tags":[{"name":"til","slug":"til","permalink":"http://codeameba.github.io/tags/til/"},{"name":"TIL","slug":"TIL","permalink":"http://codeameba.github.io/tags/TIL/"},{"name":"Today I Learned","slug":"Today-I-Learned","permalink":"http://codeameba.github.io/tags/Today-I-Learned/"},{"name":"오늘배운것들","slug":"오늘배운것들","permalink":"http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"리액트","slug":"리액트","permalink":"http://codeameba.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"react","slug":"react","permalink":"http://codeameba.github.io/tags/react/"},{"name":"노마드코더","slug":"노마드코더","permalink":"http://codeameba.github.io/tags/%EB%85%B8%EB%A7%88%EB%93%9C%EC%BD%94%EB%8D%94/"},{"name":"nomadcoders","slug":"nomadcoders","permalink":"http://codeameba.github.io/tags/nomadcoders/"}]},{"title":"[ReactJS] 무비앱 만들기 Day 05","slug":"programming/react-movie-app-05","date":"2019-09-04T16:00:42.000Z","updated":"2020-02-03T07:47:26.920Z","comments":true,"path":"2019/09/05/programming/react-movie-app-05/","link":"","permalink":"http://codeameba.github.io/2019/09/05/programming/react-movie-app-05/","excerpt":"","text":"[ReactJS] 무비앱 만들기 Day 05 4.0 Introduction to The Movie DB API 데이터가 오는 곳이 API(Application Programming Interface) Nomflix에서는 the movie db를 이용함(가입 필요). https://www.themoviedb.org/ setting -&gt; API -&gt; API KEY copy 4.1 Sexy Networking with Axios Instances API Verbs Now playing (Movie Top Rated (TV, Movie) Popular (TV, Movie) Upcoming (Movie) Airing Today (TV) 요청 방식 이전 강의들에서는 주로 fetch를 썼음 라우터에서 호출하고, fetch 하고, 나머지 모든 작업들을 하는 방식인데 효율적이지 않음. 왜냐하면 url의 동일한 내용이 반복되기 때문 따라서 네트워킹과 API만 다루는 별도의 파일을 따로 만들고 호출할 것 또한, fetch가 아닌, axios를 사용 Axios GitHub - axios/axios: Promise based HTTP client for the browser and node.js 별도 모듈 설치 필요 yarn add axios axios의 장점은, 직접 인스턴스를 configure(설정)할 수 있다는 점. axios.create([config]) 12345const instance = axios.create(&#123; baseURL: 'https://some-domain.com/api/', timeout: 1000, headers: &#123;'X-Custom-Header': 'foobar'&#125;&#125;); 위의 axios.create를 통해 반복을 최소화 할 수 있음. parameter에 api_key와 language 전달 12345678910111213import axios from 'axios';const api = axios.create(&#123; baseURL: 'https://api.themoviedb.org/3/', params: &#123; api_key: 'b8e07a1bc39775b44d7ad690b461e764', language: 'en-US' &#125;&#125;);api.get('tv/popular');export default api; index.js에 api.js를 import하고 실행해보면 아래와 같이 데이터가 들어오는 것을 확인할 수 있음. 주의) api.get에서 tv/popular로 작성해야 상대경로로 접근함 /tv/popular로 작성하면 절대경로가 됨 4.2 API Verbs part One API Verbs Now playing (Movie) Upcoming (Movie) Top Rated (TV) Popular (TV, X) Airing Today (TV) TV Show Detail Movie Detail TV와 Movies 각각의 api 요청 123456789101112131415161718192021import axios from 'axios';const api = axios.create(&#123; baseURL: 'https://api.themoviedb.org/3/', params: &#123; api_key: 'b8e07a1bc39775b44d7ad690b461e764', language: 'en-US' &#125;&#125;);export const MoviesApi = &#123; nowPlaying: () =&gt; api.get('movie/now_playing'), upcoming: () =&gt; api.get('movie/upcoming'), popluar: () =&gt; api.get('movie/popular')&#125;export const TvApi = &#123; topRated: () =&gt; api.get('tv/top_rated'), popular: () =&gt; api.get('tv/popular'), airingToday: () =&gt; api.get('tv/airing_today')&#125; fetch 방식의 api 요청에 비해 훨씬 간결하고 가독성이 좋음. axios 짱짱맨 4.3 API Verbs part Two Movie Detail을 가져오기 위해 id가 필요함 movie/{movie_id} API Verbs Now playing (Movie) Upcoming (Movie) Top Rated (TV) Popular (TV, X) Airing Today (TV) TV Show Detail Movie Detail Search (Movie, TV) append_to_response api에서 지원하는 기능 API Docs video나 image같은 것들을 덧붙이기(append)하면 포스터나 예고편 등으로 출력이 된다. 12345678910export const MoviesApi = &#123; nowPlaying: () =&gt; api.get('movie/now_playing'), upcoming: () =&gt; api.get('movie/upcoming'), popluar: () =&gt; api.get('movie/popular'), movieDetail: id =&gt; api.get(`movie/$&#123;id&#125;`, &#123; params: &#123; appent_to_response: 'videos' &#125; &#125;)&#125;; Search search 기능은 url 외에도 검색어에 해당하는 파라미터가 추가로 필요함 12345search: (term) =&gt; api.get('search/movie', &#123; params: &#123; query: term &#125;&#125;) 그리고 api의 명세를 잘 찾아보면 아래와 같이 요구사항이 설명되어 있음. 이 경우에는 URI로 인코딩이 필요하다고 함. 따라서 아래와 같이 encodeURIComponent를 사용하면 값을 인코팅하고 그 문자열로 검색을 하게 됨.12345search: (term) =&gt; api.get('search/movie', &#123; params: &#123; query: encodeURIComponent(term) &#125;&#125;)","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://codeameba.github.io/categories/JavaScript/"}],"tags":[{"name":"til","slug":"til","permalink":"http://codeameba.github.io/tags/til/"},{"name":"TIL","slug":"TIL","permalink":"http://codeameba.github.io/tags/TIL/"},{"name":"Today I Learned","slug":"Today-I-Learned","permalink":"http://codeameba.github.io/tags/Today-I-Learned/"},{"name":"오늘배운것들","slug":"오늘배운것들","permalink":"http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"리액트","slug":"리액트","permalink":"http://codeameba.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"react","slug":"react","permalink":"http://codeameba.github.io/tags/react/"},{"name":"노마드코더","slug":"노마드코더","permalink":"http://codeameba.github.io/tags/%EB%85%B8%EB%A7%88%EB%93%9C%EC%BD%94%EB%8D%94/"},{"name":"nomadcoders","slug":"nomadcoders","permalink":"http://codeameba.github.io/tags/nomadcoders/"}]},{"title":"[ReactJS] 무비앱 만들기 Day 04","slug":"programming/react-movie-app-04","date":"2019-08-28T16:00:42.000Z","updated":"2020-02-03T07:47:26.945Z","comments":true,"path":"2019/08/29/programming/react-movie-app-04/","link":"","permalink":"http://codeameba.github.io/2019/08/29/programming/react-movie-app-04/","excerpt":"","text":"[ReactJS] 무비앱 만들기 Day 04 3.0 CSS in React part One 리액트에서 CSS를 적용하는 방법 01 styles.css 파일을 만들어서 스타일 적용 CSS를 적용할 요소에 className으로 클래스명 적어야 함 최상위 파일(index.js)에 import import &#39;styles.css&#39;; 나쁜 방법은 아니나, 컴포넌트와 CSS가 분리되어 있다는 게 단점. 컴포넌트를 쓰는 가장 큰 이유는 캡슐화(Encapulation)에 있음. 리액트에서 CSS를 적용하는 방법 02 기능별로 별도 컴포넌트를 생성 각 컴포넌트마다 CSS 파일의 생성 및 적용 이 방법에도 단점은 있음 첫째, CSS 파일을 생성해야 된다는 점. 둘째, 사용할 때마다 import를 해야 한다는 점. 셋째, className을 기억해야 한다는 점.(CSS는 Global로 작동하기 때문) 3.1 CSS in React part Two 리액트에서 CSS를 적용하는 방법 03 CSS를 컴포넌트 스코프에서 작동하도록 하는 방법. CSS 모듈이라고 부름. className을 임의화해서 local로 작동하게 함. src - Components - Header - Header.module.css 123.navList &#123; display: flex;&#125; CSS 파일명을 Header.module.css 방식으로 변경 import는 자바스크립트와 같은 방식 import styles from ‘./Header.module.css’; className을 자바스크립트의 객체처럼 사용함. src - Components - Header - Header.js 123456789101112131415export default () =&gt; ( &lt;header&gt; &lt;ul className=&#123;styles.navList&#125;&gt; // &lt;- like this &lt;li&gt; &lt;a href=\"/a\"&gt;Home&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"/tv\"&gt;TV&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"/search\"&gt;Search&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/header&gt;); class명이 랜덤으로 생성됨. yarn add node-sass 설치 후 아래와 같이 작성할 수도 있음. 123456.navList &#123; display: flex; &amp;:hover &#123; background-color: deeppink; &#125;&#125; 이러한 모듈 방식도 괜찮기는 하지만 className을 기억해야 한다는 점이 단점이다. 여전히 JS와 CSS가 동떨어져 있다는 느낌을 지울 수가 없다. 둘을 하나의 파일에서 쓸 수 있는 방법은 무엇이 있을까? 3.2 CSS in React part Three 리액트에서 CSS를 적용하는 방법 04 JS를 이용한 니코의 최애 방법은 styled-components 우선 설치가 필요함 yarn add styled-components 설치 후 import import styled from &#39;styled-components&#39; TIP)vscode-styled-components 확장 프로그램을 설치하면 텍스트에 색상이 들어감. styled-component 작성 후 아래와 같이 태그로 사용 src - Components - Header.js 12345678910111213141516171819202122232425import React from 'react';import styled from 'styled-components';const List = styled.ul` display: flex; &amp;:hover &#123; background-color: deeppink; &#125;`;export default () =&gt; ( &lt;header&gt; &lt;List&gt; // &lt;- here &lt;li&gt; &lt;a href=\"/\"&gt;Home&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"/tv\"&gt;TV&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"/search\"&gt;Search&lt;/a&gt; &lt;/li&gt; &lt;/List&gt; // &lt;- here &lt;/header&gt;); Link &lt;a&gt;&lt;/a&gt;태그를 사용하면 링크로 이동할 때마다 뷰를 다시 렌더링 하는데, 굉장히 비효율적이다. 따라서, React에서는 Link라는 기능을 사용함. import { Link } from &#39;react-router-dom&#39;; 동일한 페이지에 있을 경우 해당 요소만 교체하는 방식 이 경우에는 아래와 같이 styled-components를 적용 const SLink = styled(Link)``; Link는 Router 밖에서 사용할 수 없으므로 아래와 같은 형식의 문장 구조를 이룸 1234567891011121314export default () =&gt; ( &lt;Router&gt; &lt;&gt; &lt;Header /&gt; // &lt;- here &lt;Switch&gt; &lt;Route path=\"/\" exact component=&#123;Home&#125; /&gt; &lt;Route path=\"/tv\" exact component=&#123;TV&#125; /&gt; &lt;Route path=\"/tv/popular\" render=&#123;() =&gt; &lt;h1&gt;popular&lt;/h1&gt;&#125; /&gt; &lt;Route path=\"/search\" component=&#123;Search&#125; /&gt; &lt;Redirect from=\"*\" to=\"/\" /&gt; &lt;/Switch&gt; &lt;/&gt; &lt;/Router&gt;); 3.3 GlobalStyles and Header Global style 적용 글로벌로 설정하는 이유는 해당 사이트의 폰트를 설정하거나, styled-components를 설치하거나 하는 등의 작업 때문. 우선 yarn add styled-reset GitHub - zacanger/styled-reset: Eric Meyer’s Reset CSS for styled-components styled-reset은 SC를 이용하여 CSS초기화 한 뒤 0의 상태에서 시작할 수 있게 해줌. GlobalStyles.js 파일 생성 src - Components - GlobalStyles.js 1234567891011121314151617181920import &#123; createGlobalStyle &#125; from 'styled-components';import reset from 'styled-reset';const globalStyles = createGlobalStyle` $&#123;reset&#125;; a &#123; text-decoration: none; color: inherit; &#125; * &#123; box-sizing: border-box; &#125; body &#123; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; font-size: 14px; background-color: rgba(20, 20, 20, 1); &#125;`;export default globalStyles; src - Components - App.js 12345678910111213141516import React, &#123; Component &#125; from 'react';import Router from 'Components/Router';import GlobalStyles from './GlobalStyles';class App extends Component &#123; render() &#123; return ( &lt;&gt; &lt;Router /&gt; &lt;GlobalStyles /&gt; &lt;/&gt; ); &#125;&#125;export default App; 3.4 Location Aware Header 선택된 Header의 border에만 컬러링 해당 요소에 props를 줌 123456const Item = styled.li` width: 50px; height: 50px; text-align: center; border-bottom: 5px solid $&#123;props =&gt; props.current ? 'deeppink' : 'transparent'&#125;;`; props로 현재 선택된 Header의 Router를 전달해야 함 이때 withRouter을 사용. 이것은 컴포넌트를 감싸는 또 다른 컴포넌트의 개념. Router에 대한 정보를 줌. import { Link, withRouter } from ‘react-router-dom’; 아래와 같은 형식으로 withRouter로 기존의 컴포넌트를 감싼다. 123456789101112131415161718const HeaderC = (props) =&gt; ( &lt;Header&gt; &#123;console.log(props)&#125; &lt;List&gt; &lt;Item current=&#123;false&#125;&gt; &lt;SLink to=\"/\"&gt;Movies&lt;/SLink&gt; &lt;/Item&gt; &lt;Item current=&#123;true&#125;&gt; &lt;SLink to=\"/tv\"&gt;TV&lt;/SLink&gt; &lt;/Item&gt; &lt;Item current=&#123;false&#125;&gt; &lt;SLink to=\"/search\"&gt;Search&lt;/SLink&gt; &lt;/Item&gt; &lt;/List&gt; &lt;/Header&gt;);export default withRouter(HeaderC); 위와 동일한 내용을 다른 형식으로 작성 12345678910111213141516export default withRouter(props =&gt; ( &lt;Header&gt; &#123;console.log(props)&#125; &lt;List&gt; &lt;Item current=&#123;false&#125;&gt; &lt;SLink to=\"/\"&gt;Movies&lt;/SLink&gt; &lt;/Item&gt; &lt;Item current=&#123;true&#125;&gt; &lt;SLink to=\"/tv\"&gt;TV&lt;/SLink&gt; &lt;/Item&gt; &lt;Item current=&#123;false&#125;&gt; &lt;SLink to=\"/search\"&gt;Search&lt;/SLink&gt; &lt;/Item&gt; &lt;/List&gt; &lt;/Header&gt;)); console.log를 찍어보면 아래와 같이 props를 얻을 수 있음. 여기서 필요한 것은 pathname { location: { pathname } } 최종적으로 아래와 같이 pathname의 확인 결과가 boolean으로 나올 수 있도록 작성하면 선택한 요소에만 border 색상이 들어감. 123456789101112131415export default withRouter((&#123; location: &#123; pathname &#125; &#125;) =&gt; ( &lt;Header&gt; &lt;List&gt; &lt;Item current=&#123;pathname === '/'&#125;&gt; &lt;SLink to='/'&gt;Movies&lt;/SLink&gt; &lt;/Item&gt; &lt;Item current=&#123;pathname === '/tv'&#125;&gt; &lt;SLink to='/tv'&gt;TV&lt;/SLink&gt; &lt;/Item&gt; &lt;Item current=&#123;pathname === '/search'&#125;&gt; &lt;SLink to='/search'&gt;Search&lt;/SLink&gt; &lt;/Item&gt; &lt;/List&gt; &lt;/Header&gt;));","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://codeameba.github.io/categories/JavaScript/"}],"tags":[{"name":"til","slug":"til","permalink":"http://codeameba.github.io/tags/til/"},{"name":"TIL","slug":"TIL","permalink":"http://codeameba.github.io/tags/TIL/"},{"name":"Today I Learned","slug":"Today-I-Learned","permalink":"http://codeameba.github.io/tags/Today-I-Learned/"},{"name":"오늘배운것들","slug":"오늘배운것들","permalink":"http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"리액트","slug":"리액트","permalink":"http://codeameba.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"react","slug":"react","permalink":"http://codeameba.github.io/tags/react/"},{"name":"노마드코더","slug":"노마드코더","permalink":"http://codeameba.github.io/tags/%EB%85%B8%EB%A7%88%EB%93%9C%EC%BD%94%EB%8D%94/"},{"name":"nomadcoders","slug":"nomadcoders","permalink":"http://codeameba.github.io/tags/nomadcoders/"}]},{"title":"TIL(190829) - TDD(Test Driven Development) 02","slug":"programming/tdd-til-02","date":"2019-08-28T16:00:42.000Z","updated":"2020-02-03T07:47:26.950Z","comments":true,"path":"2019/08/29/programming/tdd-til-02/","link":"","permalink":"http://codeameba.github.io/2019/08/29/programming/tdd-til-02/","excerpt":"","text":"# TIL(190829) - TDD(Test Driven Development) 02 인프런의 ‘견고한 JS 소프트웨어 만들기’ 강의를 보며 정리함 Jasmine Setting Up Releases · jasmine/jasmine · GitHub 강의에서는 2.7.0 버전 다운로드 SpecRunner.html 파일 실행 ### 테스트 러너 자스민, 소스, 테스트 코드를 실행하는 파일 스탠드 얼론의 경우 HTML 파일이 테스트 러너 테스트 자동화를 하려면 카르마(Karma) 라이브러리와 연동해야 한다. 자스민의 활용 자스민의 SpecRunner.html의 코드를 보면 아래와 같다. 빨간 박스의 자바스크립트 세 줄이 자스민의 테스트 도구라고 할 수 있다. 그리고, 아래와 같이 본인의 테스트 코드를 넣어서 테스트를 한다. 첫 번째 줄의 describe 함수는 테스트 꾸러미를 만들 때 사용함. 보통은 함수 하나 하나를 테스트 할 때 주로 사용한다. 두 번째 줄의 it 함수는 테스트 케이스를 만들 때 사용함. 함수의 기능을 테스트 한다고 보면 됨. 첫 번째 인자로 함수 기능의 스펙을 문자열 형태로 넣고, 두 번째 인자로 테스트 함수를 구현할 수 있는 함수를 넣는다. 세 번째 줄은 테스트 코드 구현 부. 함수의 결과값을 expect 함수의 인자로 넣고, 함수의 기대값을 toBe 함수의 인자로 넣는다. 테스트 꾸러미(Test Suite) describe - 테스트 설명, 테스트 구현 함수 테스트 스펙(Test Spec) it - 테스트 설명, 기대식을 가진 테스트 구현 함수 기대식과 매쳐 expect(결과값).toBe(기대값) 스파이 spyOn(감시할 객체, 감시할 메서드) 테스트 결과 확인 방법 hello world는 describe 함수로 선언했던 테스트 꾸러미의 이름이라고 할 수 있음. true is true는 hello world 테스트 꾸러미에 속한 테스트 케이스. 위의 내용을 통틀어 1개의 테스트가 실행되었으므로 1spec이라고 명시되었다. 실패는 없으므로 0 failures.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://codeameba.github.io/categories/JavaScript/"}],"tags":[{"name":"til","slug":"til","permalink":"http://codeameba.github.io/tags/til/"},{"name":"TIL","slug":"TIL","permalink":"http://codeameba.github.io/tags/TIL/"},{"name":"Today I Learned","slug":"Today-I-Learned","permalink":"http://codeameba.github.io/tags/Today-I-Learned/"},{"name":"오늘배운것들","slug":"오늘배운것들","permalink":"http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Javascript","slug":"Javascript","permalink":"http://codeameba.github.io/tags/Javascript/"},{"name":"패스트캠퍼스","slug":"패스트캠퍼스","permalink":"http://codeameba.github.io/tags/%ED%8C%A8%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%8D%BC%EC%8A%A4/"},{"name":"TDD","slug":"TDD","permalink":"http://codeameba.github.io/tags/TDD/"},{"name":"테스트주도개발","slug":"테스트주도개발","permalink":"http://codeameba.github.io/tags/%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%A3%BC%EB%8F%84%EA%B0%9C%EB%B0%9C/"}]},{"title":"[ReactJS] 무비앱 만들기 Day 03","slug":"programming/react-movie-app-03","date":"2019-08-27T16:00:42.000Z","updated":"2020-02-03T07:47:26.920Z","comments":true,"path":"2019/08/28/programming/react-movie-app-03/","link":"","permalink":"http://codeameba.github.io/2019/08/28/programming/react-movie-app-03/","excerpt":"","text":"[ReactJS] 무비앱 만들기 Day 03 2.0 Setting up the project create-react-app yarn 또는 npm을 사용 yarn global add create-react-app 간편하게 react를 시작할 수 있게 해주는 모듈 create-react-app 컴퓨터에 저장하기 때문에 매번 버전 확인 및 업데이트를 해야한다는 번거로움이 있음. npx 앞의 경우를 보완한 것이 npx를 통한 설치 yarn global add npx or npm i npx -g 이것 또한 모듈이지만, 컴퓨터에 저장할 필요가 없음. 항상 최신 버전의 create-react-app을 받아서 실행한 뒤, 끝나면 삭제 됨 npx create-react-app prop-types prop-types 모듈 설치 필요 yarn add prop-types 2.1 React router part one Screens [ ] Home [ ] TV Shows [ ] Search [ ] Detail React Router GitHub - ReactTraining/react-router: Declarative routing for React React Router: Declarative Routing for React.js React App에게 Home에서 시작해야 한다는 걸 알려주기 위한 도구 React의 Routing 패키지 DOM과 react-native에도 사용 가능함 React Router는 컴포넌트 묶음이다. 2.2 React router part two HashRouter url에 해쉬태그가 들어가기 때문에 미관상 보기 좋지 않음 http://localhost:3000/#/home BrowserRouter 일반적인 웹 페이지의 url http://localhost:3000/home Composition 두 개 이상의 Route를 동시에 랜더링 하는 방식12345678export default () =&gt; ( &lt;Router&gt; &lt;Route path=\"/\" exact component=&#123;Home&#125; /&gt; &lt;Route path=\"/tv\" component=&#123;TV&#125; /&gt; &lt;Route path=\"/tv/popular\" render=&#123;() =&gt; &lt;h1&gt;popular&lt;/h1&gt;&#125; /&gt; &lt;Route path=\"/search\" component=&#123;Search&#125; /&gt; &lt;/Router&gt;); Redirect &lt;Redirect from=“*” to=“/“ /&gt; 해당되는 페이지만 렌더링 되도록 함. But, 경로가 겹치게 되어서 에러가 나는데 그래서 Switch를 사용해야 함. Switch 한 번에 오직 하나의 Route만 랜더링 할 수 있게 함.123456789101112131415161718// Router.jsimport React from 'react';import &#123; BrowserRouter as Router, Route, Redirect, Switch &#125; from 'react-router-dom';import Home from 'Routes/Home';import TV from 'Routes/TV';import Search from 'Routes/Search';export default () =&gt; ( &lt;Router&gt; &lt;Switch&gt; // &lt;- Switch &lt;Route path=\"/\" exact component=&#123;Home&#125; /&gt; &lt;Route path=\"/tv\" component=&#123;TV&#125; /&gt; &lt;Route path=\"/tv/popular\" render=&#123;() =&gt; &lt;h1&gt;popular&lt;/h1&gt;&#125; /&gt; &lt;Route path=\"/search\" component=&#123;Search&#125; /&gt; &lt;Redirect from=\"*\" to=\"/\" /&gt; // &lt;- Redirect &lt;/Switch&gt; &lt;/Router&gt;); exact 주어진 경로와 정확히 동일할 때 설정한 컴포넌트를 보여줌. 참고자료 react-router :: 1장. 리액트 라우터 사용해보기 | VELOPERT.LOG React Router: Declarative Routing for React.js","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://codeameba.github.io/categories/JavaScript/"}],"tags":[{"name":"til","slug":"til","permalink":"http://codeameba.github.io/tags/til/"},{"name":"TIL","slug":"TIL","permalink":"http://codeameba.github.io/tags/TIL/"},{"name":"Today I Learned","slug":"Today-I-Learned","permalink":"http://codeameba.github.io/tags/Today-I-Learned/"},{"name":"오늘배운것들","slug":"오늘배운것들","permalink":"http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"리액트","slug":"리액트","permalink":"http://codeameba.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"react","slug":"react","permalink":"http://codeameba.github.io/tags/react/"},{"name":"노마드코더","slug":"노마드코더","permalink":"http://codeameba.github.io/tags/%EB%85%B8%EB%A7%88%EB%93%9C%EC%BD%94%EB%8D%94/"},{"name":"nomadcoders","slug":"nomadcoders","permalink":"http://codeameba.github.io/tags/nomadcoders/"}]},{"title":"[ReactJS] 무비앱 만들기 Day 02","slug":"programming/react-movie-app-02","date":"2019-08-26T16:00:42.000Z","updated":"2020-02-03T07:47:26.920Z","comments":true,"path":"2019/08/27/programming/react-movie-app-02/","link":"","permalink":"http://codeameba.github.io/2019/08/27/programming/react-movie-app-02/","excerpt":"","text":"[ReactJS] 무비앱 만들기 Day 02 1.6 Array.map API로부터 배열로 된 데이터를 받게 되기 때문에 배열 메서드는 중요함 map 메서드는 해당 배열 요소에 모두 동일한 사항을 매핑하여 새로운 배열을 만들어냄 Array.prototype.map() - JavaScript | MDN 123456789101112const days = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri'];const drinkDays = days.map(day =&gt; `$&#123;day&#125;: I'll drink beer`);console.log(drinkDays);/*['Mon: I'll drink beer','Tue: I'll drink beer','Wed: I'll drink beer','Thu: I'll drink beer','Fri: I'll drink beer']*/ 1.7 Array.filter filter 메서드는 주어진 조건을 만족하는 요소만으로 새로운 배열을 만듬 Array.prototype.filter() - JavaScript | MDN 12345678const numbers = [ 3, 4, 7, 32, 31, 5, 64, 12, 24, 87, 66, 59, 243, 356, 645, 210 ];const biggerThan50 = numbers.filter(num =&gt; num &gt; 50);console.log(biggerThan50);/*[ 64, 87, 66, 59, 243, 356, 645, 210]*/ 1.8 forEach / includes / push forEach 새로운 배열을 반환하는 map이나 filter와 다름 배열 각각의 요소에 접근하여 조건에 받는 요소를 반환 로컬 스토리지에 저장한다던가, API로 보낸다던가, 경고를 보낸다던가 하는 등의 작업에 사용 Array.prototype.forEach() - JavaScript | MDN 12345678const beers = ['cass', 'hite', 'terra', 'fitz'];beers.forEach(beer =&gt; console.log(beer));/*casshiteterrafitz*/ push 배열에 새로운 요소를 추가할 때 사용함 Array.prototype.push() - JavaScript | MDN 12345const beers = ['cass', 'hite', 'terra', 'fitz'];beers.push('kloud');console.log(beers);// [ 'cass', 'hite', 'terra', 'fitz', 'kloud' ] includes 배열 내에 특정 요소가 존재하는 확인 Array.prototype.includes() - JavaScript | MDN 12345678const cars = ['BMW', 'AUDI', 'VOLVO'];if(!cars.includes('BENZ')) &#123; cars.push('BENZ');&#125;console.log(cars);// [ 'BMW', 'AUDI', 'VOLVO', 'BENZ' ] 추가) reduce reduce는 단순히 배열 내의 요소를 모두 합하여 하나로 만드는 역할만 하는 메서드가 아니다. 활용하기에 따라 무궁무진한 가능성이 있다. 꾸준히 반복 학습이 필요한 메서드 중 하나. 배열.reduce((누적값,현재값,인덱스,요소)=&gt;{return결과},초기값); Array.prototype.reduce() - JavaScript | MDN 참고 자료 Array.prototype.slice() - JavaScript | MDN https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce String.prototype.split() - JavaScript | MDN parseInt() - JavaScript | MDN","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://codeameba.github.io/categories/JavaScript/"}],"tags":[{"name":"til","slug":"til","permalink":"http://codeameba.github.io/tags/til/"},{"name":"TIL","slug":"TIL","permalink":"http://codeameba.github.io/tags/TIL/"},{"name":"Today I Learned","slug":"Today-I-Learned","permalink":"http://codeameba.github.io/tags/Today-I-Learned/"},{"name":"오늘배운것들","slug":"오늘배운것들","permalink":"http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"리액트","slug":"리액트","permalink":"http://codeameba.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"react","slug":"react","permalink":"http://codeameba.github.io/tags/react/"},{"name":"노마드코더","slug":"노마드코더","permalink":"http://codeameba.github.io/tags/%EB%85%B8%EB%A7%88%EB%93%9C%EC%BD%94%EB%8D%94/"},{"name":"nomadcoders","slug":"nomadcoders","permalink":"http://codeameba.github.io/tags/nomadcoders/"}]},{"title":"[ReactJS] 무비앱 만들기 Day 01","slug":"programming/react-movie-app-01","date":"2019-08-25T16:00:42.000Z","updated":"2020-02-03T07:47:26.920Z","comments":true,"path":"2019/08/26/programming/react-movie-app-01/","link":"","permalink":"http://codeameba.github.io/2019/08/26/programming/react-movie-app-01/","excerpt":"","text":"[ReactJS] 무비앱 만들기 Day 01 1.1 Arrow Function ES6에서 새롭게 추가된 기능 ES6 이전 일반적인 형태의 함수에서는 return을 생략하면 undefined가 출력되었지만, 화살표 함수에서는 내부적으로 return을 자동으로 해주기 때문에 생략이 가능하다. 단, {}를 사용한다면 return을 명시해줘야 한다. parameter가 1개일 경우에는 () 생략 가능. 화살표 함수 - JavaScript | MDN 1234567891011const beers = ['cass', 'hite', 'terra'];// ES6 이전const beerFilter = beers.filter(function(beer) &#123; return beer.length &gt; 4;&#125;);console.log(beerFilter); // [ 'terra' ]// ES6 이후const beerFilterVer2 = beers.filter(beer =&gt; beer.length &lt; 5);console.log(beerFilterVer2); // [ 'cass', 'hite' ] 1.2 Template Literals Template Literals는 Template와 변수, 문자열 등을 다루기에 적합한 방법이다. 백틱(backtracks)라고 부르는 기호를 활용하며 문자열로 출력하게 한다. 인자는 ${} 이것으로 감싼다. Template literals - JavaScript | MDN 12345678910111213141516171819202122const beerBox = [ &#123; name: 'CASS', from: 'KOREA' &#125;, &#123; name: 'STELLA', from: 'BELGIUM' &#125;, &#123; name: 'KIRIN', from: 'JAPAN' &#125;];const favBeer = beerBox.filter(beer =&gt; &#123; if (beer.from === 'KOREA') &#123; return console.log(`I LOVE $&#123;beer.name&#125;`); // &lt;- template literals &#125;&#125;);// I LOVE CASS 1.3 Object Destructuring 우리말로 구조 분해 할당 이라고 하며, 동일한 할당 작업을 반복해야 할 때 이를 한 번에 할 수 있게 해줌. 비교적 적은 코드가 사용되기 때문에 깔끔하게 보인다는 게 장점 Object를 기반으로 생성됨. 구조 분해 할당 - JavaScript | MDN 12345678910111213141516const beer = &#123; name: 'CASS', from: 'KOREA', taste: 'FRESH', type: 'LAGER', with: &#123; morning: 'CUP RA-MYEON', afternoon: 'PIZZA', evening: 'SAM-GYEOP-SAL' &#125;&#125;;const &#123; name, from, taste, type, with: &#123; afternoon &#125; &#125; = beer;console.log(`$&#123;name&#125; is from $&#123;from&#125;, this is $&#123;taste&#125; $&#123;type&#125;. I love drink with $&#123;afternoon&#125;`);// CASS is from KOREA, this is FRESH LAGER. I love drink with PIZZA 1.4 Spread Operator 배열이나 객체를 풀어줌(Unpack). 전개 구문 - JavaScript | MDN 12345678910const days = ['Mon', 'Tue', 'Wed'];const otherDays = ['Thu', 'Fri', 'Sat'];const allDays = [days, otherDays, 'Sun'];console.log(allDays);// [ [ 'Mon', 'Tue', 'Wed' ], [ 'Thu', 'Fri', 'Sat' ], 'Sun' ]const allDaysVer2 = [...days, ...otherDays, 'Sun'];console.log(allDaysVer2);// [ 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun' ] 1.5 Classes 프로그래밍에는 크게 두 종류의 패러다임이 있다 함수형 프로그래밍(Functional Programming) 객체 지향 프로그래밍(OOP, Object Oriented Programming) 객체 지향 프로그래밍의 경우 모든 것을 객체나 클래스로 만들고, 부모 자식의 관계가 분명하다. Class는 청사진(Blueprint)과 같다고 생각하면 된다. 리액트에서 지겹도록 사용하게 됨. Classes - JavaScript | MDN 12345678910111213141516171819202122232425class SmartPhone &#123; constructor(name, made) &#123; this.name = name; this.made = made; &#125;;&#125;;class Calling extends SmartPhone &#123; ringRing() &#123; console.log('Hello?'); &#125;; intro() &#123; console.log(`This phone is $&#123;this.name&#125;`) &#125;;&#125;;const myPhone = new SmartPhone('iphone', 'apple');console.log(myPhone.name);// iphoneconst yourPhone = new Calling('galaxy', 'samsung');console.log(yourPhone.ringRing(), yourPhone.intro());// Hello?// This phone is galaxy// undefined 참고자료 static - JavaScript | MDN 자바스크립트 객체 복사하기 Object.freeze() - JavaScript | MDN","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://codeameba.github.io/categories/JavaScript/"}],"tags":[{"name":"til","slug":"til","permalink":"http://codeameba.github.io/tags/til/"},{"name":"TIL","slug":"TIL","permalink":"http://codeameba.github.io/tags/TIL/"},{"name":"Today I Learned","slug":"Today-I-Learned","permalink":"http://codeameba.github.io/tags/Today-I-Learned/"},{"name":"오늘배운것들","slug":"오늘배운것들","permalink":"http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"리액트","slug":"리액트","permalink":"http://codeameba.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"react","slug":"react","permalink":"http://codeameba.github.io/tags/react/"},{"name":"노마드코더","slug":"노마드코더","permalink":"http://codeameba.github.io/tags/%EB%85%B8%EB%A7%88%EB%93%9C%EC%BD%94%EB%8D%94/"},{"name":"nomadcoders","slug":"nomadcoders","permalink":"http://codeameba.github.io/tags/nomadcoders/"}]},{"title":"[JavaScript] ++i 와 i++의 차이","slug":"programming/js-til-increase-decrease","date":"2019-08-19T16:00:42.000Z","updated":"2020-02-03T07:47:26.920Z","comments":true,"path":"2019/08/20/programming/js-til-increase-decrease/","link":"","permalink":"http://codeameba.github.io/2019/08/20/programming/js-til-increase-decrease/","excerpt":"","text":"[JavaScript] ++i 와 i++의 차이 *** 12345let i = 0;console.log(i++);console.log(++i);console.log(i++);console.log(++i); 위의 출력 결과를 알 수 있겠는가? 불과 3개월 전의 나라면 단순하게 1, 2, 3, 4라고 답했을 지도 모르겠다. 하지만, 지금의 나는 둘의 차이를 분명하게 알고 있다. 위와 같이 ++ 혹은, --와 같이 더하기나 빼기 기호가 이어져 있는 연산자를 증감 연산자라고 하는데, 변수의 앞에 있을 경우 전위 증감 연산자, 뒤에 있을 경우 후위 증감 연산자라고 부른다. 이 증감 연산자는 말 그대로 숫자형의 변수를 1씩 증가 시키거나 1씩 감소 시킨다. 여기까지만 알고 있다면, 자연스럽게 위의 답을 1, 2, 3, 4라고 할 수 있을 것이다. 위의 답을 먼저 밝히자면 0, 2, 2, 4다.1씩 증가하는 증감 연산자인데 어째서 1과 3이 빠지고 2씩 증가했는지 의아하게 생각할 누군가를 위해 개인적인 복습 겸 설명을 해볼까 한다. 여기서 우리는 위의 증감 연산자가 전위인가 후위인가를 주의 깊게 봐야 한다. 굳이 이름까지 다르게 붙였다는 것은 각각의 작동 방식이다 다르다는 것을 의미한다. 전위 증감 연산자(++i) 전위 증감 연산자는 변수의 값을 증가 먼저 시킨 뒤에 할당한다. 따라서 아래와 같은 경우가 있다면, 12let i = 0;console.log(++i); 출력 값은 1이 나올 것이다. 후위 증감 연산자(i++) 반면에 후위 증감 연산자는 변수의 값을 할당 먼저 한 뒤에 증가 시킨다. 따라서 아래와 같은 경우가 있다면, 12let i = 0;console.log(i++); 증가 시키기 전의 값인 0이 나올 것이다. 증감 연산자의 반복 전위 증감 연산자를 쓰던 후위 증감 연산자를 쓰던 정해진 범위 내에서 증감이 이루어지기 때문에 최초의 값이 필요하다면 후위를, 최초의 값이 필요 없다면 전위를 쓰면 된다고 생각한다. 둘의 미묘한 속도 차이가 있다고는 하는데, 몇 차례 출력을 해본 결과로는 후위 증감 연산자가 약간 빠른 것 같기도 한다. 0.01초 정도. 어쨌든 중요한 것은, 전위와 후위를 섞어 쓰지 않는 것이다. 하나를 정했다면 그 프로젝트에서는 끝까지 그걸로 가야만 한다. 그래야 평화로울 것이다.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://codeameba.github.io/categories/JavaScript/"}],"tags":[{"name":"일기","slug":"일기","permalink":"http://codeameba.github.io/tags/%EC%9D%BC%EA%B8%B0/"},{"name":"til","slug":"til","permalink":"http://codeameba.github.io/tags/til/"},{"name":"TIL","slug":"TIL","permalink":"http://codeameba.github.io/tags/TIL/"},{"name":"Today I Learned","slug":"Today-I-Learned","permalink":"http://codeameba.github.io/tags/Today-I-Learned/"},{"name":"오늘배운것들","slug":"오늘배운것들","permalink":"http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Javascript","slug":"Javascript","permalink":"http://codeameba.github.io/tags/Javascript/"},{"name":"증감연산자","slug":"증감연산자","permalink":"http://codeameba.github.io/tags/%EC%A6%9D%EA%B0%90%EC%97%B0%EC%82%B0%EC%9E%90/"}]},{"title":"TIL(190820) - React 06","slug":"programming/react-til-06","date":"2019-08-19T16:00:42.000Z","updated":"2020-02-03T07:47:26.950Z","comments":true,"path":"2019/08/20/programming/react-til-06/","link":"","permalink":"http://codeameba.github.io/2019/08/20/programming/react-til-06/","excerpt":"","text":"TIL(190820) - React 06 Cutting the summary 텍스트의 크기를 배경에 맞추기 위해 자바스크립트에서 가공해야 함 이때 Array 메서드를 사용하는데, 문자열은 배열과 마찬가지로 iterable이기 때문. 예를 들어 아래와 같다. 123const example = 'This is string';example.length; // 14example.slice(0, 5); // \"This \" 배열과 같이 length를 구할 수 있으며 slice 등의 메서드를 활용하여 가공이 가능하다. String.prototype.slice() - JavaScript | MDN 따라서 이를 통해 아래와 같이 활용이 가능하다.1&lt;p className=\"movie_summary\"&gt;&#123;summary.slice(0,140)&#125;&lt;/p&gt; Deploying to Github Pages gh-pages 설치 npm i gh-pages gh-pages를 통해 GitHub-page 도메인에 보여지도록 할 수 있다. package.JSON 설정 이때 홈페이지 주소는 해당 레포 이름 script에 deploy와 predeploy 항목을 추가 deploy에는 npm run build를 한 다음 build 폴더를 업로드 &quot;gh-pages -d build predeploy에는 npm run build를 설정하여 deploy를 호출할 때마다 build가 되도록 함1234567891011121314151617181920212223242526272829303132333435&#123;\"name\":\"movie_app_2019\",\"version\":\"0.1.0\",\"private\":true,\"dependencies\":&#123;\"axios\":\"^0.19.0\",\"gh-pages\":\"^2.1.1\",\"prop-types\":\"^15.7.2\",\"react\":\"^16.9.0\",\"react-dom\":\"^16.9.0\",\"react-scripts\":\"3.1.0\"&#125;,\"scripts\":&#123;\"start\":\"react-scriptsstart\",\"build\":\"react-scriptsbuild\",\"deploy\":\"gh-pages-dbuild\",\"predeploy\":\"npmrunbuild\"&#125;,\"eslintConfig\":&#123;\"extends\":\"react-app\"&#125;,\"browserslist\":&#123;\"production\":[\"&gt;0.2%\",\"notdead\",\"notop_miniall\"],\"development\":[\"last1chromeversion\",\"last1firefoxversion\",\"last1safariversion\"]&#125;,\"homepage\":\"http://www.codeameba.com/react-basic-with-nomadcoders\"&#125; deploy npm run deploy를 하면 배포가 되는 것을 확인 할 수 있음 수정 후에는 deploy도 다시 해야 함 NOMFLIX","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://codeameba.github.io/categories/JavaScript/"}],"tags":[{"name":"til","slug":"til","permalink":"http://codeameba.github.io/tags/til/"},{"name":"TIL","slug":"TIL","permalink":"http://codeameba.github.io/tags/TIL/"},{"name":"Today I Learned","slug":"Today-I-Learned","permalink":"http://codeameba.github.io/tags/Today-I-Learned/"},{"name":"오늘배운것들","slug":"오늘배운것들","permalink":"http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Javascript","slug":"Javascript","permalink":"http://codeameba.github.io/tags/Javascript/"},{"name":"리액트","slug":"리액트","permalink":"http://codeameba.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"react","slug":"react","permalink":"http://codeameba.github.io/tags/react/"}]},{"title":"TIL(190819) - React 05","slug":"programming/react-til-05","date":"2019-08-18T16:00:42.000Z","updated":"2020-02-03T07:47:26.950Z","comments":true,"path":"2019/08/19/programming/react-til-05/","link":"","permalink":"http://codeameba.github.io/2019/08/19/programming/react-til-05/","excerpt":"","text":"TIL(190819) - React 05 내가 필요한 Movie List의 경로는 movies.data.data.movies이기 때문에 아래와 같이 단축표현으로 쓰면 좋음. setState에서 movies: movies로 key와 value의 이름이 같을 때에는 아래와 같이 하나만 써도 됨. 1234getMovies = async () =&gt; &#123; const &#123;data: &#123;data: &#123; movies &#125;&#125;&#125; = await axios.get('https://yts.lt/api/v2/list_movies.json'); this.setState(&#123; movies, isLoading: false &#125;)&#125; class형 모듈이 여러모로 할 수 있는 게 많지만, state가 필요하지 않다던가 하는 경우에는 굳이 class형 모듈을 쓰지 않고, 간단하게 함수형 모듈을 사용해도 좋음. 아래와 같이 api에 정해진 파라미터가 있으니 잘 살펴볼 것 받아온 Movies를 map()메서드로 렌더링 key 빼먹으면 에러 남 123456789101112131415render() &#123; const &#123; isLoading, movies &#125; = this.state; return ( &lt;div&gt;&#123;isLoading ? 'Loading...' : movies.map(movie =&gt; &#123; return &lt;Movie key=&#123;movie.id&#125; id=&#123;movie.id&#125; year=&#123;movie.year&#125; title=&#123;movie.title&#125; summary=&#123;movie.summary&#125; poster=&#123;movie.medium_cover_image&#125; /&gt; &#125;)&#125;&lt;/div&gt; );&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://codeameba.github.io/categories/JavaScript/"}],"tags":[{"name":"til","slug":"til","permalink":"http://codeameba.github.io/tags/til/"},{"name":"TIL","slug":"TIL","permalink":"http://codeameba.github.io/tags/TIL/"},{"name":"Today I Learned","slug":"Today-I-Learned","permalink":"http://codeameba.github.io/tags/Today-I-Learned/"},{"name":"오늘배운것들","slug":"오늘배운것들","permalink":"http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Javascript","slug":"Javascript","permalink":"http://codeameba.github.io/tags/Javascript/"},{"name":"리액트","slug":"리액트","permalink":"http://codeameba.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"react","slug":"react","permalink":"http://codeameba.github.io/tags/react/"}]},{"title":"[번역] What is the difference between a URI, a URL and a URN?","slug":"programming/uri-url-urn","date":"2019-08-17T16:00:42.000Z","updated":"2020-02-20T21:02:25.530Z","comments":true,"path":"2019/08/18/programming/uri-url-urn/","link":"","permalink":"http://codeameba.github.io/2019/08/18/programming/uri-url-urn/","excerpt":"","text":"Stackoverflow에 올라온 URI, URL, URN의 차이를 묻는 질문에 대한 답변 중 개인적으로 가장 이해하기 쉬웠던 답변을 번역함. 의역 포함.(원문 링크 - https://stackoverflow.com/questions/176264/what-is-the-difference-between-a-uri-a-url-and-a-urn/1984225#1984225) Q. URI와 URL 그리고 URN의 차이가 무엇인가요? 사람들은 URI와 URL 그리고 URN을 각기 다른 것처럼 이야기 하는데, 내 눈에는 다 똑같아 보입니다. 이것들을 구분할 수 있는 차이점이 무엇인가요? ## A. URI(Uniform Resource Identifier)는 식별정보(Identify)를 지니고, URL(Uniform Resource Locator)은 위치정보(Locate)를 지닙니다. 위치정보 역시 하나의 식별정보이기 때문에 모든 URL은 URI이기도 합니다. 그러나, URI는 URL이 아닙니다. *** 예시 Roger Pate이것은 내 이름입니다. 일종의 식별자로써 URI라고 할 수 있습니다. 하지만 URL은 아닙니다. 왜냐하면 이름만으로는 내 위치나 연락처에 대한 정보는 알 수 없기 때문이죠. 이런 경우, 식별자가 겹치는 사람이 미국에서만 적어도 5명은 될 겁니다. 4914 West Bay Street, Nassau, Bahamas이것을 나의 현재 위치라고 가정하겠습니다. 물리적인 위치 식별자라고 볼 수 있죠. 식별자로써의 역할을 한다는 점은 URL이나 URI나 둘 다 같습니다만(모든 URL은 URI입니다), 이런 경우에는 간접적으로 나의 거주지를 식별할 수 있습니다. 이를 통해 나를 보다 정확하게 특정할 수 있겠죠. 물론, 저에게 룸메이트가 생긴다면 조금 달라질 테지만 말이죠. 혼동하기 쉬운 것 위키피디아에서는 다음과 같이 설명하고 있습니다. 컴퓨팅에서 URL은 식별된 리소스가 사용 가능한 위치와 검색 매커니즘을 지정하는 URI의 하위 집합이다. 일반적인 사용이나 다수의 기술 문서, 토론 등에서 종종 URL은 URI의 동의어로 잘못 사용되기도 한다. 이처럼 혼동하는 경우가 심심치 않게 있어서, 많은 제품과 문서에서는 한 가지 용어만 사용하거나, 뚜렷하게 구분이 되는 기준을 지정하거나 또는, 그 둘을 동의어로 간주하기도 합니다. URN(Uniform Resource Name) 내 이름인 Roger Pate를 URN이라고 볼 수도 있습니다. 하지만 실제 URN은 그보다 훨씬 더 엄격한 규제 안에서 존재하며, 장소와 시간을 특정할 수 있습니다.내 이름이 URN이 될 수 없는 이유는 다음과 같습니다. 첫째, 충분히 동명이인이 존재할 수 있습니다. 둘째, 내 이름은 증조할아버지의 이름을 따 지었기 때문에 고유하다고 할 수 없습니다. 셋째, 만약 내 후손 중에 누군가가 내 이름을 쓸 수 있는 가능성이 있습니다.이와 같은 이유들로 내 이름은 URN이 되기에 적절치 않습니다. URN은 이처럼 매우 엄격한 제약 조건이 따르기에 URL과는 엄연히 다르며, URN과 URL은 둘 다 URI의 한 종류입니다. ## 역자주 *** 내가 이해한 URI, URL, URN의 차이는 다음과 같다. 도서관에서 책을 찾는 상황으로 생각해보면 좋다고 생각한다. URI는 해당 책의 제목, 저자, 출판사, 위치, ISBN 등 특정한 책을 찾을 때 필요한 모든 가용정보를 포함한다. URL은 도서관이나 서점 등에서 따르는 도서분류규칙에 의거하여 특정 위치에 특정 도서가 있는 것이다. 이 경우 실제 콘텐츠인 책이 규칙을 벗어나 다른 위치로 옮겨지면 찾을 수 없을 텐데 이를 404 Error로 생각할 수 있다. URN은 특정 책의 고유번호인 ISBN으로 볼 수 있다. 이를 통해 해당 콘텐츠에 직접적으로 접근이 가능한 것이다. #### 참고 자료 - [https://danielmiessler.com/study/url-uri/](https://danielmiessler.com/study/url-uri/) - [https://stackoverflow.com/questions/176264/what-is-the-difference-between-a-uri-a-url-and-a-urn/1984225#1984225](https://stackoverflow.com/questions/176264/what-is-the-difference-between-a-uri-a-url-and-a-urn/1984225#1984225) - [https://en.wikipedia.org/wiki/Uniform_Resource_Name](https://en.wikipedia.org/wiki/Uniform_Resource_Name) 이미지 출처 unsplash.com","categories":[{"name":"번역","slug":"번역","permalink":"http://codeameba.github.io/categories/%EB%B2%88%EC%97%AD/"}],"tags":[{"name":"til","slug":"til","permalink":"http://codeameba.github.io/tags/til/"},{"name":"TIL","slug":"TIL","permalink":"http://codeameba.github.io/tags/TIL/"},{"name":"Today I Learned","slug":"Today-I-Learned","permalink":"http://codeameba.github.io/tags/Today-I-Learned/"},{"name":"오늘배운것들","slug":"오늘배운것들","permalink":"http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"},{"name":"url과 uri의 차이","slug":"url과-uri의-차이","permalink":"http://codeameba.github.io/tags/url%EA%B3%BC-uri%EC%9D%98-%EC%B0%A8%EC%9D%B4/"},{"name":"url","slug":"url","permalink":"http://codeameba.github.io/tags/url/"},{"name":"uri","slug":"uri","permalink":"http://codeameba.github.io/tags/uri/"},{"name":"urn","slug":"urn","permalink":"http://codeameba.github.io/tags/urn/"}]},{"title":"TIL(190816) - 쿠키(Cookie)란 무엇인가?","slug":"programming/cookie-til","date":"2019-08-15T16:00:42.000Z","updated":"2020-02-03T07:47:26.540Z","comments":true,"path":"2019/08/16/programming/cookie-til/","link":"","permalink":"http://codeameba.github.io/2019/08/16/programming/cookie-til/","excerpt":"","text":"노마드 코더 유튜브 시청 뒤 정리하여 작성함(영상 링크 - https://youtu.be/1emZgLiGE4s) 쿠키(Cookie)란? HTTP 프로토콜은 기본적으로 stateless(항상 연결되어 있지 않은, 상태 정보가 없는)이기 때문에 유저의 상태 정보를 기억해두기 위한 수단으로 고안된 것이 쿠키다.쿠키는, 서버가 사용자의 웹 브라우저에 전송하는 작은 데이터 조각으로써, 특정 웹사이트에 최초 접속 시 발급된다. 이후, 브라우저는 그 데이터 조각을 저장해두었다가 동일한 서버에 재 요청 시 저장된 데이터를 함께 전송하여 방문했던 유저라는 것을 인증한다.쿠키는 주로 다음의 세 가지 목적을 위해 사용한다. 첫째, 세션 관리(Session management)서버에 저장해야 할 로그인, 장바구니, 게임 스코어 등의 정보 관리 둘째, 개인화(Peronalization)사용자 선호, 테마 등의 설정 셋째, 트래킹(Tracking)사용자 행동을 기록하고 분석하는 용도 ## 쿠키의 한계 *** 쿠키는 다음과 같은 한계 또는 규칙을 지니고 있다. 첫째, 도메인 스코프(Domain Scope)쿠키는 하나의 도메인에 묶여있다. 말 그대로 특정 웹사이트에서 발급된 쿠키는 다른 웹사이트에서 사용이 불가능하다. 둘째, 자동 전송(Sent Automatically)쿠키는 자동으로 전송된다. 서버는 원하는만큼 쿠키를 전송할 수 있고, 브라우저는 자동으로 쿠키를 저장한다. 셋째, 자동 설정(Set Automatically)웹사이트에 접속 시 쿠키는 브라우저에 자동으로 전송된 뒤, 자동으로 설정된다. ## 쿠키의 사용 사례 *** 현재의 웹에서 쿠키를 가장 적극적으로 사용한다고 할 수 있는 회사는 ‘페이스북’이다. 페이스북은 쿠키를 사용하여 유저가 어느 웹사이트를 방문했고, 관심사는 무엇이며, 무슨 물건을 구입하고 싶어하는 지까지 알아낸 뒤, 빅데이터를 구축한다. 그리고 그 빅데이터를 통해 놀라운 정확도로 타겟팅을 하여 마케팅을 한다. 페이스북의 사례는 시사하는 바가 크다. 페이스북은 그들의 ‘좋아요’나 ‘댓글 기능’, ‘피드에 공유 기능’ 등을 다른 웹사이트에 제공함으로써 페이스북으로 요청이 가게 되고, 자동으로 쿠키를 발급한다. 그리고, 그 쿠키를 통해 유저가 접속한 웹사이트를 알아내고 유저의 행동패턴 빅데이터를 구축한다. #### 참고 자료 - [HTTP 쿠키 - HTTP | MDN](https://developer.mozilla.org/ko/docs/Web/HTTP/Cookies) - [https://www.youtube.com/watch?v=1emZgLiGE4s&t=317s](https://www.youtube.com/watch?v=1emZgLiGE4s&t=317s)","categories":[{"name":"HTTP","slug":"HTTP","permalink":"http://codeameba.github.io/categories/HTTP/"}],"tags":[{"name":"til","slug":"til","permalink":"http://codeameba.github.io/tags/til/"},{"name":"TIL","slug":"TIL","permalink":"http://codeameba.github.io/tags/TIL/"},{"name":"Today I Learned","slug":"Today-I-Learned","permalink":"http://codeameba.github.io/tags/Today-I-Learned/"},{"name":"오늘배운것들","slug":"오늘배운것들","permalink":"http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"},{"name":"쿠키","slug":"쿠키","permalink":"http://codeameba.github.io/tags/%EC%BF%A0%ED%82%A4/"},{"name":"cookie","slug":"cookie","permalink":"http://codeameba.github.io/tags/cookie/"},{"name":"http","slug":"http","permalink":"http://codeameba.github.io/tags/http/"}]},{"title":"TIL(190815) - React 04","slug":"programming/react-til-04","date":"2019-08-14T16:00:42.000Z","updated":"2020-02-03T07:47:26.950Z","comments":true,"path":"2019/08/15/programming/react-til-04/","link":"","permalink":"http://codeameba.github.io/2019/08/15/programming/react-til-04/","excerpt":"","text":"TIL(190815) - React 04 class component는 render 외에도 많은 것을 갖고 있다. 그 중의 하나가 life cycle method life cycle method는 react가 component를 생성하고 없애는 방법 component가 생성될 때 render 이전에 호출되는 함수들이 있고, 이후에 호출되는 함수들이 있다. mounting / unmounting updating 12345678910111213141516171819202122232425class App extends React.Component &#123; constructor(props) &#123; super(props); console.log(\"this is constructor\"); &#125; state = &#123; count: 0 &#125;; plus = () =&gt; &#123; this.setState(current =&gt; (&#123; count: current.count + 1 &#125;)); &#125;; minus = () =&gt; &#123; this.setState(current =&gt; (&#123; count: current.count - 1 &#125;)); &#125;; render() &#123; console.log('this is render'); return ( &lt;div&gt; &lt;h1&gt;The number is &#123;this.state.count&#125;&lt;/h1&gt; &lt;button onClick=&#123;this.plus&#125;&gt;Plus&lt;/button&gt; &lt;button onClick=&#123;this.minus&#125;&gt;Minus&lt;/button&gt; &lt;/div&gt; ); &#125;&#125; - constructor는 render보다 먼저 호출된다. 1234567891011121314class App extends React.Component &#123; state = &#123; isLoading: true &#125;; componentDidMount() &#123; setTimeout(() =&gt; &#123; this.setState(&#123;isLoading: false&#125;); &#125;, 3000); &#125; render() &#123; const &#123; isLoading &#125; = this.state; return &lt;div&gt;&#123;isLoading ? 'Loading...' : 'We Are Ready!'&#125;&lt;/div&gt;; &#125;&#125; componentDidMount는 render 이후에 호출된다. 참고자료 https://reactjs-kr.firebaseapp.com/docs/state-and-lifecycle.html https://yts.lt/api Axios fetch처럼 데이터를 받아올 때 사용함 async/await과 같이 사용 가능 ex) axios가 데이터를 다 받아올 때까지 기다려달라는 의미. 123getMovies = async () =&gt; &#123; const movies = await axios.get('https://yts.lt/api/v2/list_movies.json'); &#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://codeameba.github.io/categories/JavaScript/"}],"tags":[{"name":"til","slug":"til","permalink":"http://codeameba.github.io/tags/til/"},{"name":"TIL","slug":"TIL","permalink":"http://codeameba.github.io/tags/TIL/"},{"name":"Today I Learned","slug":"Today-I-Learned","permalink":"http://codeameba.github.io/tags/Today-I-Learned/"},{"name":"오늘배운것들","slug":"오늘배운것들","permalink":"http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Javascript","slug":"Javascript","permalink":"http://codeameba.github.io/tags/Javascript/"},{"name":"리액트","slug":"리액트","permalink":"http://codeameba.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"react","slug":"react","permalink":"http://codeameba.github.io/tags/react/"}]},{"title":"TIL(190814) - React 03","slug":"programming/react-til-03","date":"2019-08-13T16:00:42.000Z","updated":"2020-02-03T07:47:26.920Z","comments":true,"path":"2019/08/14/programming/react-til-03/","link":"","permalink":"http://codeameba.github.io/2019/08/14/programming/react-til-03/","excerpt":"","text":"TIL(190814) - React 03 컴포넌트에서 다루는 데이터는 두 종류 props : 부모 컴포넌트가 자식 컴포넌트에게 주는 값 state : 컴포넌트 내부에서 선언하고 내부에서 값을 변경할 수 있음. 받아온 props 값은 this로 조회 가능함 함수형 컴포넌트와 클래스형 컴포넌트의 주요 차이점 함수형에는 state와 life cycle이 빠져있음 함수형은 초기 마운트 속도가 약간 빠르고 불필요한 부분이 없어서 메모리를 덜 차지함 클래스형 컴포넌트 render() 필수123456789101112class MyName extends Component &#123; static defaultProps = &#123; name: 'codeAmeba' &#125; render() &#123; return ( &lt;div&gt; hello. My Name is &#123;this.props.name&#125; &lt;/div&gt; ) &#125;&#125; 함수형 컴포넌트 1234567const MyName = (&#123;name&#125;) =&gt; &#123; return &lt;div&gt;Hello. My Name is &#123;name&#125;&lt;/div&gt;;&#125;;MyName.defaultProps = &#123; name: 'codeAmeba'&#125;; 동적인 데이터를 다룰 때에는 state를 사용함(ex: counter) state는 클래스형 컴포넌트에서만 가능123456789101112131415161718192021222324class App extends React.Component &#123; state = &#123; count: 0 &#125;; plus = () =&gt; &#123; this.setState(&#123; count: this.state.count + 1 &#125;); &#125;; minus = () =&gt; &#123; this.setState(&#123; count: this.state.count - 1 &#125;); &#125;; render() &#123; return ( &lt;div&gt; &lt;h1&gt;The number is &#123;this.state.count&#125;&lt;/h1&gt; &lt;button onClick=&#123;this.plus&#125;&gt;Plus&lt;/button&gt; &lt;button onClick=&#123;this.minus&#125;&gt;Minus&lt;/button&gt; &lt;/div&gt; ); &#125;&#125; 위의 경우는 state를 변경하기 때문에 좋은 방법은 아님, 아래와 같이 current의 사용을 권함 123456plus = () =&gt; &#123; this.setState(current =&gt; (&#123; count: current.count + 1 &#125;));&#125;;minus = () =&gt; &#123; this.setState(current =&gt; (&#123; count: current.count - 1 &#125;));&#125;; (중요)setState를 호출할 때마다 react는 새로운 state로 render를 다시 한다.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://codeameba.github.io/categories/JavaScript/"}],"tags":[{"name":"til","slug":"til","permalink":"http://codeameba.github.io/tags/til/"},{"name":"TIL","slug":"TIL","permalink":"http://codeameba.github.io/tags/TIL/"},{"name":"Today I Learned","slug":"Today-I-Learned","permalink":"http://codeameba.github.io/tags/Today-I-Learned/"},{"name":"오늘배운것들","slug":"오늘배운것들","permalink":"http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Javascript","slug":"Javascript","permalink":"http://codeameba.github.io/tags/Javascript/"},{"name":"리액트","slug":"리액트","permalink":"http://codeameba.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"react","slug":"react","permalink":"http://codeameba.github.io/tags/react/"}]},{"title":"TIL(190813) - React 02","slug":"programming/react-til-02","date":"2019-08-12T16:00:42.000Z","updated":"2020-02-03T07:47:26.920Z","comments":true,"path":"2019/08/13/programming/react-til-02/","link":"","permalink":"http://codeameba.github.io/2019/08/13/programming/react-til-02/","excerpt":"","text":"TIL(190813) - React 02 props를 전달할 때 고유값을 전달하지 않으면 위와 같이 경고가 뜬다. 따라서 props에 ID를 만들고 아래와 같이 key로 넘겨야 함. 123&#123;BeerBox.map(beer =&gt; ( &lt;Beers key=&#123;beer.id&#125; name=&#123;beer.name&#125; picture=&#123;beer.image&#125; /&gt;))&#125; npm i prop-types props가 잘못 전달 되었을 때 이를 알려주는 도구 아래와 같이 각 필요한 데이터의 타입을 명시해준다12345Beers.propTypes = &#123; name: PropTypes.string.isRequired, picture: PropTypes.string.isRequired, rating: PropTypes.number.isRequired&#125; propTypes 참고 https://reactjs-kr.firebaseapp.com/docs/typechecking-with-proptypes.html","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://codeameba.github.io/categories/JavaScript/"}],"tags":[{"name":"til","slug":"til","permalink":"http://codeameba.github.io/tags/til/"},{"name":"TIL","slug":"TIL","permalink":"http://codeameba.github.io/tags/TIL/"},{"name":"Today I Learned","slug":"Today-I-Learned","permalink":"http://codeameba.github.io/tags/Today-I-Learned/"},{"name":"오늘배운것들","slug":"오늘배운것들","permalink":"http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Javascript","slug":"Javascript","permalink":"http://codeameba.github.io/tags/Javascript/"},{"name":"리액트","slug":"리액트","permalink":"http://codeameba.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"react","slug":"react","permalink":"http://codeameba.github.io/tags/react/"}]},{"title":"TIL(190812) - React 01","slug":"programming/react-til-01","date":"2019-08-11T16:00:42.000Z","updated":"2020-02-03T07:47:26.920Z","comments":true,"path":"2019/08/12/programming/react-til-01/","link":"","permalink":"http://codeameba.github.io/2019/08/12/programming/react-til-01/","excerpt":"","text":"TIL(190812) - React 01 리액트는 Virtual DOM 번역 리액트에 대해서 그 누구도 제대로 설명하기 어려운 것 – 왜 Virtual DOM 인가? | VELOPERT.LOG JSX라는 리액트만의 문법이 존재함. JS와 HTML이 섞인 듯한 느낌 두 단어 이상의 결합은 모두 카멜케이스(ex: className, backgroundColor) 한 파일에 여러 컴포넌트가 들어올 수도 있음.123456789101112function Potato() &#123; return &lt;h3&gt;I love potato&lt;/h3&gt;&#125;function App() &#123; return ( &lt;div&gt; &lt;h1&gt;Hello&lt;/h1&gt; &lt;Potato /&gt; &lt;/div&gt; );&#125; props 누구든지 하는 리액트 4편: props 와 state | VELOPERT.LOG 자바스크립트의 문법을 대부분 그대로 쓸 수 있음1234567891011121314151617181920212223242526272829303132import React from 'react';function Beer(&#123; name &#125;) &#123; return &lt;h1&gt;I love &#123; name &#125;&lt;/h1&gt;&#125;const BeerBox = [ &#123; name: 'Terra' &#125;, &#123; name: 'Cass' &#125;, &#123; name: 'Hite' &#125;, &#123; name: 'Fitz' &#125;]function App() &#123; return ( &lt;div&gt; &#123;BeerBox.map(item =&gt; ( &lt;Beer name=&#123;item.name&#125; /&gt; ))&#125; &lt;/div&gt; );&#125;export default App;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://codeameba.github.io/categories/JavaScript/"}],"tags":[{"name":"til","slug":"til","permalink":"http://codeameba.github.io/tags/til/"},{"name":"TIL","slug":"TIL","permalink":"http://codeameba.github.io/tags/TIL/"},{"name":"Today I Learned","slug":"Today-I-Learned","permalink":"http://codeameba.github.io/tags/Today-I-Learned/"},{"name":"오늘배운것들","slug":"오늘배운것들","permalink":"http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Javascript","slug":"Javascript","permalink":"http://codeameba.github.io/tags/Javascript/"},{"name":"리액트","slug":"리액트","permalink":"http://codeameba.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"react","slug":"react","permalink":"http://codeameba.github.io/tags/react/"}]},{"title":"Github pages에 Custom domain 적용하기","slug":"programming/tip-custom-domain","date":"2019-08-11T16:00:42.000Z","updated":"2020-02-03T07:47:26.950Z","comments":true,"path":"2019/08/12/programming/tip-custom-domain/","link":"","permalink":"http://codeameba.github.io/2019/08/12/programming/tip-custom-domain/","excerpt":"","text":"Github pages에 Custom domain 적용하기 얼마 전 가비아를 통해 codeameba.com 도메인을 구입했다. 그리고, 기존에 codeameba.github.io였던 블로그에 적용을 했다. 물론 커스텀도메인을 구입한 것도 적용한 것도 처음이라 나름의 시행착오는 있었지만, 결과적으로는 잘 돌아간다. 지금이라면, 한 번에 커스텀 도메인을 연결할 자신이 있지만, 몇 개월 뒤, 몇 년 뒤에 다시 한다면 분명 똑같은 시행착오를 겪을 것이라는 걸 나는 잘 알고 있다. 그렇기에 간단히 기록으로 남겨두려 한다. 1. 도메인 구입 커스텀 도메인은 하늘에서 뚝 떨어지는 것이 아니다. 도메인 가치에 따른 사용료를 지불해야만 한다. 구글 도메인 서비스나, 한국에서 가장 많이 이용하는 가비아 같은 DNS 업체를 통해 본인이 사용하고 싶은 도메인을 검색해볼 수 있다. 내 경우에는 가비아에서 검색해보고 구입했는데, 아무도 쓰고 있지 않았고, .com인데도 불구하고 가격이 그다지 비싼 편도 아니었다. 2. DNS 설정 어떤 웹페이지에 도메인을 적용할 것인지 가비아 내에서 설정을 해야 한다.(My가비아 -&gt; DNS 관리툴 바로 가기 -&gt; DNS 설정) 타입은 CNAME, 호스트는 www, 값에는 도메인을 연결할 페이지의 주소를 적는다.TTL(Time To Live)은, 말 그대로 생존 기간을 말하는 것으로 네임서버에서 넘어간 호스트 정보가 유지되는 시간이라고 한다. 설정한 시간 뒤에 자동으로 정보가 소멸된다고 하는데, 아직 자세한 내용을 모르겠다. 공부할 것에 추가. 어쨌든 이렇게 설정한 뒤 저장을 한다. 참고자료https://library.gabia.com/contents/domain/4146WEB2-Domain Name System-12.DNS record &amp; CNAME - YouTube 3. GitHub Custom domain 설정 DNS 쪽은 끝났고, 이제 github에서 설정해야 한다. Settings -&gt; Github Pages -&gt; Custom domain 에 본인이 구매한 도메인을 적는다. 이때 꼭, www.를 붙인다. 그리고 Save. 아직 끝이 아니다. 해당 레포의 메인으로 돌아와보면 아래와 같이 CNAME이라는 새로운 파일이 생성된 것을 볼 수 있다. 이걸 열어서 www.를 붙인 형식으로 도메인을 적는다. CNAME(Canonical Name): 하나의 도메인에 다른 이름을 부여하는 방식. 쉽게 말하자면 가명이라고 할 수 있다. 4. Hexo 추가 설정 Hexo의 경우 _config.yml에서 url을 CNAME으로 변경해야 한다. 그리고, 여기까지 설정했는데 제대로 도메인 적용이 안 된다면 Hexo의 CNAME Plugin을 설치해야 한다.npm install hexo-generator-cname --save 설치 후에는 _config.yml 파일을 열어 다음과 같이 설정을 추가한다.plugins: hexo-generator-cname","categories":[{"name":"tip","slug":"tip","permalink":"http://codeameba.github.io/categories/tip/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://codeameba.github.io/tags/hexo/"},{"name":"blog","slug":"blog","permalink":"http://codeameba.github.io/tags/blog/"},{"name":"githubpages","slug":"githubpages","permalink":"http://codeameba.github.io/tags/githubpages/"},{"name":"dns","slug":"dns","permalink":"http://codeameba.github.io/tags/dns/"},{"name":"customdomain","slug":"customdomain","permalink":"http://codeameba.github.io/tags/customdomain/"},{"name":"cname","slug":"cname","permalink":"http://codeameba.github.io/tags/cname/"}]},{"title":"TIL(190811) - TDD(Test Driven Development) 01","slug":"programming/tdd-til-01","date":"2019-08-10T16:00:42.000Z","updated":"2020-02-03T07:47:26.950Z","comments":true,"path":"2019/08/11/programming/tdd-til-01/","link":"","permalink":"http://codeameba.github.io/2019/08/11/programming/tdd-til-01/","excerpt":"","text":"TIL(190811) - TDD(Test Driven Development) 01 인프런의 ‘견고한 JS 소프트웨어 만들기’ 강의를 보며 정리함 TDD의 개념 테스트 코드를 먼저 작성하고, 그 테스트에 통과할 수 있는 코드를 작성하는 방식의 개발방법 빨간색, 초록색, 파란색으로 단계를 구분함. 빨간색: 테스트 코드만 작성한 상태 초록색: 테스트에 통과할 수 있는 최소 요구치를 만족한 코드를 작성한 상태 파란색: 테스트에 통과한 코드를 리팩토링까지 마친 상태 자스민(Jasmine) - [Getting Started] - 자바스크립트의 코드를 테스트할 수 있는 도구(프레임워크) - ‘자스민’만 사용하는 것을 ’Standalone’이라고 부름 - 현업에서는 Standalone을 쓰는 경우는 그다지 없고, ‘카르마(Karma)’ 라이브러리와 함께 사용하여 테스트를 자동화함.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://codeameba.github.io/categories/JavaScript/"}],"tags":[{"name":"til","slug":"til","permalink":"http://codeameba.github.io/tags/til/"},{"name":"TIL","slug":"TIL","permalink":"http://codeameba.github.io/tags/TIL/"},{"name":"Today I Learned","slug":"Today-I-Learned","permalink":"http://codeameba.github.io/tags/Today-I-Learned/"},{"name":"오늘배운것들","slug":"오늘배운것들","permalink":"http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Javascript","slug":"Javascript","permalink":"http://codeameba.github.io/tags/Javascript/"},{"name":"패스트캠퍼스","slug":"패스트캠퍼스","permalink":"http://codeameba.github.io/tags/%ED%8C%A8%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%8D%BC%EC%8A%A4/"},{"name":"TDD","slug":"TDD","permalink":"http://codeameba.github.io/tags/TDD/"},{"name":"테스트주도개발","slug":"테스트주도개발","permalink":"http://codeameba.github.io/tags/%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%A3%BC%EB%8F%84%EA%B0%9C%EB%B0%9C/"}]},{"title":"[JavaScript Exercise] 하노이의 탑","slug":"programming/coding-exercise-hanoi-tower","date":"2019-07-02T16:00:42.000Z","updated":"2020-02-03T07:47:26.539Z","comments":true,"path":"2019/07/03/programming/coding-exercise-hanoi-tower/","link":"","permalink":"http://codeameba.github.io/2019/07/03/programming/coding-exercise-hanoi-tower/","excerpt":"","text":"하노이의 탑하노이의 탑은 프랑스 수학자 에두아르 뤼카의 저서를 통해 알려진 게임으로, 다음과 같은 규칙을 갖고 있다. 원반은 한 번에 한 개만 옮길 수 있다. 원반은 막대기 A, B, C 이외의 장소에는 놓을 수 없다. 원반을 옮길 때는 작은 원반 위에 그보다 큰 원반을 쌓을 수 없다. 1234567891011121314function hanoi(n, a, b, c) &#123; if (n &lt; 1) &#123; return; &#125; hanoi(n - 1, a, b, c); console.log(`$&#123;n&#125; 번째 원반: $&#123;a&#125; -&gt; $&#123;c&#125;`); hanoi(n - 1, b, a, c);&#125;hanoi(3, 'A', 'B', 'C');// 1 번째 원반: A -&gt; C// 2 번째 원반: A -&gt; C// 1 번째 원반: B -&gt; C// 3 번째 원반: A -&gt; C// 1 번째 원반: B -&gt; C// 2 번째 원반: B -&gt; C// 1 번째 원반: A -&gt; C","categories":[{"name":"Exercise","slug":"Exercise","permalink":"http://codeameba.github.io/categories/Exercise/"}],"tags":[{"name":"til","slug":"til","permalink":"http://codeameba.github.io/tags/til/"},{"name":"TIL","slug":"TIL","permalink":"http://codeameba.github.io/tags/TIL/"},{"name":"Today I Learned","slug":"Today-I-Learned","permalink":"http://codeameba.github.io/tags/Today-I-Learned/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Javascript","slug":"Javascript","permalink":"http://codeameba.github.io/tags/Javascript/"},{"name":"하노이의탑","slug":"하노이의탑","permalink":"http://codeameba.github.io/tags/%ED%95%98%EB%85%B8%EC%9D%B4%EC%9D%98%ED%83%91/"},{"name":"알고리즘","slug":"알고리즘","permalink":"http://codeameba.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"코딩연습","slug":"코딩연습","permalink":"http://codeameba.github.io/tags/%EC%BD%94%EB%94%A9%EC%97%B0%EC%8A%B5/"}]},{"title":"[JavaScript Exercise] 스크롤 업 버튼","slug":"programming/coding-exercise-gotoup","date":"2019-06-24T16:00:42.000Z","updated":"2020-02-03T07:47:26.539Z","comments":true,"path":"2019/06/25/programming/coding-exercise-gotoup/","link":"","permalink":"http://codeameba.github.io/2019/06/25/programming/coding-exercise-gotoup/","excerpt":"","text":"스크롤 업window 메서드 pageYOffset, scroll()을 활용한 예제 See the Pen [exercise]go to up by Sooyoung Jeong (@codeAmeba) on CodePen.","categories":[{"name":"Exercise","slug":"Exercise","permalink":"http://codeameba.github.io/categories/Exercise/"}],"tags":[{"name":"일기","slug":"일기","permalink":"http://codeameba.github.io/tags/%EC%9D%BC%EA%B8%B0/"},{"name":"til","slug":"til","permalink":"http://codeameba.github.io/tags/til/"},{"name":"TIL","slug":"TIL","permalink":"http://codeameba.github.io/tags/TIL/"},{"name":"Today I Learned","slug":"Today-I-Learned","permalink":"http://codeameba.github.io/tags/Today-I-Learned/"},{"name":"오늘배운것들","slug":"오늘배운것들","permalink":"http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Javascript","slug":"Javascript","permalink":"http://codeameba.github.io/tags/Javascript/"},{"name":"패스트캠퍼스","slug":"패스트캠퍼스","permalink":"http://codeameba.github.io/tags/%ED%8C%A8%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%8D%BC%EC%8A%A4/"}]},{"title":"[번역 중...] 2019년을 대표할만한 11가지 자바스크립트 애니메이션 라이브러리","slug":"programming/tip-animation-library","date":"2019-06-16T16:00:42.000Z","updated":"2020-02-20T21:02:36.886Z","comments":true,"path":"2019/06/17/programming/tip-animation-library/","link":"","permalink":"http://codeameba.github.io/2019/06/17/programming/tip-animation-library/","excerpt":"","text":"[번역] 2019년을 대표할만한 11가지 자바스크립트 애니메이션 라이브러리&lt;최고의 JS-CSS 애니메이션 라이브러리&gt; *** 11 JavaScript Animation Libraries For 2019 - Some of the finest JS-CSS animation libraries around.[원문 링크] 깔끔한 자바스크립트 애니메이션 라이브러리를 찾기 위해 웹을 검색해보며 한 가지 알게된 사실이 있습니다. 추천리스트에 있는 라이브러리 중 상당수는 제대로 유지 및 관리가 되지 않는다는 점입니다. 그래서 저는 직접 조사를 진행했고, 당신의 앱에 사용할만한 가장 훌륭한 라이브러리 11가지를 소개하려 합니다. 그리고, 유지, 관리는 조금 안 될지라도 여전히 유용한 라이브러리도 몇 가지 추가할까 합니다. 순수한 CSS를 사용한다는 것 애니메이션 라이브러리 속으로 뛰어들기에 앞서, 순수한 CSS를 사용하는 것을 잊지 않았으면 합니다. 왜냐하면, 그것이 표준이기 때문입니다. 순수한 CSS의 사용은 퍼포먼스를 향상시키고, 호환성이 뛰어나며, 애니메이션 효과를 만드는 가장 좋은 방법일 수 있습니다. 여기에 순수한 CSS로 이루어진 10가지의 좋은 예가 있습니다. See the Pen Pure CSS Saturn Hula Hooping by Jamie Coulter (@jcoulterdesign) on CodePen. 1. Three.js 깃허브에서 43K 이상의 별을 받을 정도로 굉장히 인기가 있는 라이브러리인 Three.js는, WebGL을 직관적인 방법으로 사용하여 브라우저에서 3D 애니메이션을 만들 수 있는 훌륭한 방식을 취하고 있습니다.Canvas, svg, CSS3D 그리고 WebGL 렌더러를 제공하는 이 라이브러리를 사용하면 다양한 디바이스와 브라우저 전반에 걸쳐 풍부한 인터렉티브 경험을 만들어낼 수 있습니다. Three.js는 2010년 4월 처음 소개 되었음에도 여전히 큰 사랑을 받으며 약 1,000 여명 기고자(contributor)들에 의해 개발되고 있습니다. GitHub - mrdoob/three.js: JavaScript 3D library. 2. Anime.js 깃허브에서 20K 이상의 별을 받은 Anime.js는, CSS 속성(Property), 개별 CSS 트랜스폼, SVG 또는, DOM 속성(Attribute) 및 자바스크립트 객체와 함께 작동하는 자바스크립트 애니메이션 라이브러리입니다. 이 라이브러리를 사용하면 여러 애니메이션 속성(Properties)들을 연결하여 여러 인스턴스를 동기화하고, 타임라인을 만드는 등의 작업을 할 수 있습니다. GitHub - juliangarnier/anime: JavaScript animation engine 3. Mo.js 깃허브에서 14K 이상의 별을 받은 Mo.js는, 웹을 위한 모션 그래픽 도구모음입니다. 여기에는 간단한 선언적 APIs부터 기기간 호환성을 비롯한 1,500개 이상의 유닛 테스트가 포함되어 있는데요. 이를 통해 DOME 또는 SVG DOME을 중심으로 물체를 움직이거나, 독특한 Mo.js 객체를 만들 수도 있습니다. 문서가 다소 부족하다는 게 아쉽지만, 예제가 풍부하고, CSS-TRICKSAn Introduction to mo.js | CSS-Tricks에서도 다루고 있다. GitHub - mojs/mojs: The motion graphics toolbelt for the web 4. Velocity See the Pen CSS Cube - Velocity JS Animation by Luca Dimola (@hone) on CodePen. 깃허브에서 15K 이상의 별을 받은 Velocity는, jQuery의 $.animate() 함수와 동일한 API를 지니고 있는 빠른 자바스크립트 애니메이션 엔진입니다. 색상 애니메이션(Color animation), 변형(Transforms), 가속/감속(easing), 반복(loops), SVG 지원(support), 스크롤(scrolling) 등의 기능이 특징입니다.Velocity의 고성능 엔진에 대한 설명과 고장(breakdown) 예방법에 대한 내용은 여기를 참고하시기 바랍니다. 그리고, Velocity를 활용한 SVG 애니메이션의 소개는 이곳을 참고해주세요. GitHub - julianshapiro/velocity: Accelerated JavaScript animation. 5. Popmotion 깃허브에서 14K 이상의 별을 받은 Popmotion은, 고작 11kb밖에 되지않는 실용적인 반응형 애니메이션 라이브러리죠. 값을 입력하여 시작과 종료를 임의로 정할 수 있으며, 이를 통해 CSS, SVG, React, Three.js 그리고, API까지 컨트롤이 가능합니다. GitHub - Popmotion/popmotion: Simple animation libraries for delightful user interfaces 6. Vivus 깃허브에서 10K 이상의 별을 받은 Vivus는, 자바스크립트 클래스에 대한 의존성이 전혀 없이 SVG로 애니메이션을 만들 수 있는 라이브러리입니다. 이미지가 그려지는 다양한 형태의 애니메이션을 기본적으로 제공하며, 그 중 하나를 선택하거나, 임의로 제작하여 SVG를 그릴 수도 있습니다. 그와 관련하여 예시를 보고 싶으시다면 Vivus-instantVivus Instant - inline SVG animation with CSS를 확인해보세요. GitHub - maxwellito/vivus: JavaScript library to make drawing animation on SVG 7. GreenSock JS GreenSock JS(이하 GSAP)는 400만 개 이상의 웹 사이트에서 사용되고 있는 고성능의 의존성이 없는, 크로스 브라우저 애니메이션이 가능한 자바스크립트 라이브러리입니다. GSAP는 그만큼 유연하고 React, Vue, Angular 등의 프레임워크는 물론이고 바닐라 자바스크립트와의 호환성도 아주 좋습니다. 또한, GSDevtools는 GSAP를 사용하여 제작된 애니메이션의 디버깅에 유용합니다. GitHub - greensock/GreenSock-JS: GreenSock’s GSAP JavaScript animation library (including Draggable). 8. Scroll Reveal 깃허브에서 15K 이상의 별을 받았고, 의존성이 전혀 없는 라이브러리 Scroll Reaveal은, 웹 브라우저와 모바일 브라우저를 위하여 쉽게 적용이 가능한 애니메이션 방식의 스크롤을 제공합니다. 다양하고 깔끔한 효과들이 있으며, 자연어를 통해 애니메이션을 정의할 수도 있습니다. 여기 몇 가지의 짧은 튜토리얼Revealing Elements with scrollReveal.js이 있습니다. GitHub - scrollreveal/scrollreveal: Animate elements as they scroll into view. 9. Hover(CSS) 깃허브에서 20K 이상의 별을 받은 Hover는 CSS 라이브러리입니다. 링크, 버튼, 로고, SVG, 이미지 등에 적용 가능한 CSS3 기반의 호버 효과를 다채롭게 제공합니다. CSS, Sass, LESS 등에서 사용할 수도 있으며, 특정 효과를 스타일시트에 직접 복사, 붙여넣기 하는 방식으로도 적용이 가능합니다. GitHub - IanLunn/Hover: A collection of CSS3 powered hover effects to be applied to links, buttons, logos, SVG, featured images and so on. Easily apply to your own elements, modify or just use for inspiration. Available in CSS, Sass, and LESS. 10. Kute.js Kute.js는 크로스 브라우저 애니메이션에 필수적인 기능을 두루 갖춘 본격적인 네이티브 자바스크립트 애니메이션 엔진입니다. 코드의 품질, 유연성, 성능 및 크기에 중점적으로 신경을 썼으며, 확장KUTE.js Features | Javascript Animation Engine이 가능하여 별도의 기능을 추가할 수도 있습니다. GitHub - thednp/kute.js: KUTE.js is a native JavaScript animation engine featuring great code quality, badass performance, SVG morphing, stroke drawing and 2D &amp; 3D transforms, CSS3 transforms, colors, as well as other CSS3 properties or presentation attributes. 11. Typed.js 깃허브에서 6K 이상의 별을 받은 Typed.js를 사용하면, 설정한 속도에 따라 문자열의 입력 애니메이션을 생성할 수가 있습니다. 또한, 페이지에 HTML &lt;div&gt;를 배치하고.. [번역 중…]","categories":[{"name":"번역","slug":"번역","permalink":"http://codeameba.github.io/categories/%EB%B2%88%EC%97%AD/"}],"tags":[{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"VSCode","slug":"VSCode","permalink":"http://codeameba.github.io/tags/VSCode/"},{"name":"확장프로그램","slug":"확장프로그램","permalink":"http://codeameba.github.io/tags/%ED%99%95%EC%9E%A5%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8/"},{"name":"CSS","slug":"CSS","permalink":"http://codeameba.github.io/tags/CSS/"},{"name":"자바스크립트라이브러리","slug":"자바스크립트라이브러리","permalink":"http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC/"},{"name":"애니메이션라이브러리","slug":"애니메이션라이브러리","permalink":"http://codeameba.github.io/tags/%EC%95%A0%EB%8B%88%EB%A9%94%EC%9D%B4%EC%85%98%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC/"},{"name":"모션그래픽","slug":"모션그래픽","permalink":"http://codeameba.github.io/tags/%EB%AA%A8%EC%85%98%EA%B7%B8%EB%9E%98%ED%94%BD/"},{"name":"motion graphic","slug":"motion-graphic","permalink":"http://codeameba.github.io/tags/motion-graphic/"}]},{"title":"[번역] 쾌적한 자바스크립트 코딩을 위한 VSCode 확장 프로그램 추천","slug":"programming/tip-extensions","date":"2019-06-09T16:00:42.000Z","updated":"2020-02-20T21:02:56.986Z","comments":true,"path":"2019/06/10/programming/tip-extensions/","link":"","permalink":"http://codeameba.github.io/2019/06/10/programming/tip-extensions/","excerpt":"","text":"[번역] 쾌적한 자바스크립트 코딩을 위한 VSCode 확장 프로그램 추천 Top JavaScript VSCode Extensions for Faster Development [원문 링크] VSCode는 현재 가장 많은 프로그래머들이 사랑하는 IDE입니다. 매우 빠르고, 확장 프로그램이 풍부하며, 자유로운 커스터마이징이 가능하죠. 그 외에도 뛰어난 기능들을 다수 지니고 있습니다. 만약 아직도 사용해보지 않았다면, 꼭 한 번 써보시길 바랍니다. VSCode에는 수천 개의 확장 프로그램이 존재합니다. 그 중에서 개인적으로 애용하는 몇 가지 확장 프로그램을 추천해볼까 합니다. Quokka.js Quokka.js는 자바스크립트(JavaScript)와 타입스크립트(TypeScript)를 위한 매우 빠른 프로토타입 놀이터와 같습니다. 이 말은 곧, 사용자가 입력하는 즉시 코드를 실행한다는 의미입니다. 여기서 한 단계 더 나아가 실행 결과를 미리 보여주기도 합니다 Quokka.js를 설치한 후 Ctrl / Cmd (⌘) + Shift + P를 눌러 명령 팔레트를 오픈하고 Quokka를 입력하면, 사용 가능한 명령어 목록을 볼 수 있습니다. 그 중에서 New JavaScript File을 선택하거나 ⌘ + K + J 키를 누르면 즉시 실행이 가능합니다. Bracket Pair Colorizer 괄호와 괄호의 나열은 프로그래밍에서 빠질 수 없는 요소입니다. 여러 개의 괄호가 지속적으로 중첩되다 보면 괄호가 하나 빠진 부분이 있더라도 쉽게 발견할 수가 없죠. Bracket Pair Colorizer 는 괄호의 색상을 모두 다르게 만들어 이러한 고충을 덜게 해줍니다. 물론, 여는 괄호와 닫는 괄호로 이루어진 한 쌍은 동일한 색상을 지닙니다. Snippets Snippet은 IDE에서 사용되는 축약어입니다. 예를 들어 import React from ‘react’; 같은 경우에는 단지 imr이라고 타이핑 하고 Tab 키를 누르면 자동 완성이 됩니다. clg 같은 축약어는 특히 자주 사용 되는데요. 이건 console.log입니다. Todo Highlighter 종종 우리는 코딩을 한 뒤, ‘이것 보다 더 좋은 방법이 있지 않을까?’하는 생각을 하게 됩니다. 그런 경우에 추후 리펙토링을 하기 위해 주석을 달곤 하는데요. 주의 깊게 보지 않으면 눈에 띄지 않기 때문에 잊어버리고는 그대로 마스터 브랜치에 푸쉬를 해버리는 불상사가 일어나기도 합니다. 하지만 Todo Highlighter와 함께라면 그런 일은 더 이상 없을 것입니다. 당신의 코드에 숨은 주석들을 밝은 형광색으로 항상 눈에 띄게 하기 때문이죠. Import Cost 이 확장 프로그램은 import하려는 모듈의 크기를 미리 볼 수 있게 합니다. 덕분에 Webpack같은 번들러를 사용할 때 큰 도움이 되죠. 이를 통해 전체 라이브러리를 가져오는지 아니면 특정 유틸리티만 가져오는지 확인할 수가 있습니다. REST Client 웹 개발자로서 우리는 종종 REST APIs를 통해 협력을 해야 합니다. URL을 검사하고 응답을 확인하기 위해 Postman과 같은 툴을 사용하죠. 하지만 IDE에서 동일한 작업이 가능하다면 굳이 다른 프로그램을 실행할 필요는 없을 것입니다. 그렇기 때문에 REST Client를 반길 수밖에 없습니다. 이를 통해 VSCode에서 HTTP 요청을 보내고 즉시 응답을 확인할 수가 있습니다. Auto Close Tag and Auto RenameTag React의 출현으로 말미암아 지난 몇 년간 지속된 웹 개발 업계의 호황 이후, JSX 형태의 HTML 구문이 다시금 유행하고 있습니다. 그래서 우리는 다시 자바스크립트로 태그를 코딩해야 합니다. 대다수의 웹개발자는 태그를 입력하는 것을 그다지 반길 것 같지 않은데요. 그렇기 때문에 우리는 태그는 물론 자식 태그까지 빠르고 쉽게 만들 수 있는 도구가 필요합니다. 그런 점에서 Emmet이 VSCode에 이미 내장되어 있다는 점은 훌륭한 예입니다. 하지만, 때때로 이보다 간결하고 단순한 도구가 필요할 때가 있죠. 바로, Auto Close Tag와 Auto RenameTag처럼 말입니다. 이를 통해 여는 태그만 작성해도 닫는 태그까지 동시에 완성이 되고, 둘 중 하나의 태그만 수정하더라도 둘 다 자동으로 수정이 됩니다. 또한, JSX, XML, PHP, Vue, JavaScript, TSX와 같이 다양한 언어에서 정상적으로 작동을 합니다. GitLens GitLens의 제작자가 밝혔듯이, GitLens는 VSCode에 내장된 Git의 기능을 한층 더 강화 해줍니다. 코드 렌즈, 커밋 검색, 히스토리, Gitlens 탐색기 등 놀라운 기능들이 담겨있습니다. 깃을 사용한다면 필수 확장 프로그램이라고 말할 수 있습니다.자세한 설명은 여기에서 확인할 수 있습니다. Git ProjectManager GPM(Git Project Manager)을 사용하면 VSCode에서 직접 Git 저장소 새창으로 열 수 있습니다. 기본적으로 VSCode를 종료하지 않고도 다른 저장소를 여는 것이 가능합니다.이 확장 프로그램을 설치한 후에 gitProjectManager.baseProjectsFolders는 저장소가 포함된 URL 목록으로 설정해야 합니다. 예시는 아래와 같습니다. 123456&#123; &quot;gitProjectManager.baseProjectsFolders&quot;: [ &quot;&#x2F;home&#x2F;user&#x2F;nodeProjects&quot;, &quot;&#x2F;home&#x2F;user&#x2F;personal&#x2F;pocs&quot; ]&#125; Indenticator 현재 들여쓰기가 어느 정도 되어 있는지 시각적으로 강조됩니다. 각기 다른 깊이로 들여쓰기된 여러 블록들을 쉽게 구분할 수 있게 합니다. VSCode Icons 당신의 IDE를 보다 멋지게 만들기 위한 아이콘! Dracula (Theme) 그냥 개인적으로 가장 좋아하는 테마입니다.※역자 주: 저는 material theme을 좋아합니다 :) 원문 출처 medium.com 이미지 출처 unsplash.com","categories":[{"name":"번역","slug":"번역","permalink":"http://codeameba.github.io/categories/%EB%B2%88%EC%97%AD/"}],"tags":[{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"VSCode","slug":"VSCode","permalink":"http://codeameba.github.io/tags/VSCode/"},{"name":"확장프로그램","slug":"확장프로그램","permalink":"http://codeameba.github.io/tags/%ED%99%95%EC%9E%A5%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8/"},{"name":"extension","slug":"extension","permalink":"http://codeameba.github.io/tags/extension/"},{"name":"IDE","slug":"IDE","permalink":"http://codeameba.github.io/tags/IDE/"},{"name":"코드편집기","slug":"코드편집기","permalink":"http://codeameba.github.io/tags/%EC%BD%94%EB%93%9C%ED%8E%B8%EC%A7%91%EA%B8%B0/"}]},{"title":"[JavaScript Preview] 스코프(Scope)는 취조실 거울처럼 단방향","slug":"programming/js-scope","date":"2019-06-07T16:00:42.000Z","updated":"2020-02-03T07:47:26.920Z","comments":true,"path":"2019/06/08/programming/js-scope/","link":"","permalink":"http://codeameba.github.io/2019/06/08/programming/js-scope/","excerpt":"","text":"꼭 알아야 하는 자바스크립트의 20가지 개념INDEX(링크 업데이트 예정) Data type Literal Expression Primitive type vs Object type Function Definition Scope Lexical Scope 전역 변수의 문제점 var 키워드로 선언한 변수의 문제점 Constructor Function this DOM 브라우저 동작 Event Delegation Event Capturing vs Event Bubbling Class super Prototype Promise 동기식 처리 모델 vs 비동기식 처리 모델 스코프(Scope) 스코프(scope)는 변수가 선언된 위치를 기준으로 다른 코드를 참조할 수 있는 유효범위를 의미한다. 왜 선언된 위치를 기준으로 하는지, 어떤 방식으로 정해지는지 알기 위해서는 실행 컨텍스트(execution context)를 알아야만 하는데, 실행 컨텍스트의 내용이 방대하기 때문에 추후 별도의 포스트에서 다루도록 하고, 이번 포스트에서는 실행 컨텍스트를 간단히 겉핥기만 하고 스코프를 알아볼까 한다. 실행 컨텍스트와 스코프 위에서 언급 했듯이 스코프와 실행 컨텍스트는 분리할 수가 없는 개념이다. 애초에 실행 컨텍스트로 인하여 스코프가 생긴다고도 볼 수 있다.실행 컨텍스트를 생성하는 코드는 크게 네 종류가 있으며, 전역(global) 코드 함수(function) 코드 eval 코드 모듈(module) 코드 이러한 코드들(주로 전역, 함수)이 실행 준비를 하는 평가 과정에서 각각의 실행 컨텍스트가 생성된다. 그리고, 변수, 함수, 클래스 등의 선언문이 해당 실행 컨텍스트에 등록된다. 각 실행 컨텍스트에 속한 코드가 실행을 마치면 그 실행 컨텍스트는 소멸하는데, 이 말은 곧, 전역 실행 컨텍스트는 가장 처음에 시작하여 가장 마지막까지 남는다는 것이다.(엄밀히 따지면 전역 실행 컨텍스트는 window이며 브라우저와 생애주기가 동일하다.) 함수의 경우는 함수가 호출 될 때 해당 실행 컨텍스트가 생성되며 콜 스택에 쌓이게 된다(push). 실행이 종료되면 콜 스택에서 빠지고(pop), 컨트롤을 이전 컨텍스트에 넘겨준다. 이와 같은 과정으로 자바스크립트 소스 코드에 스코프(scope)와 스코프들의 중첩으로 이루어진 스코프 체인(scope chain)이 생겨난다. 스코프의 동작 방식 스코프는 전역(global)과 지역(local)로 구분하는데, 변수가 선언된 위치를 기준으로 유효범위를 정하기 때문에 전역에서 선언된 변수는 전역 스코프를 갖고, 지역에서 선언된 변수는 지역 스코프를 갖는다. 전역 스코프는 가장 바깥의 window를 의미하기 때문에 모든 지역 스코프에서 참조가 가능하다. 이러한 스코프의 동작 방식을 쉽게 이해하려면 미드에서 등장하는 취조실을 떠올리면 좋다. 취조실 내부에는 거울이 있는데, 내부에서는 건너편이 보이지 않는 거울이지만, 취조실 옆 밀실에서는 유리창처럼 내부가 훤히 보이곤 한다. 스코프도 이와 마찬가지로 단방향으로만 참조만 가능하다. 만약, 아래와 같은 중첩된 스코프가 있다면, 아래의 그림처럼 이미지를 그릴 수 있다. 결국, 중첩된 스코프에서 가장 안쪽에 있는 코드는 그것을 감싸고 있는 모든 스코프의 변수를 참조할 수 있는 것이다. 스코프가 중첩되어 이어진 것을 스코프 체인이라 한다. 엄밀히 따지면, 실행 컨텍스트의 렉시컬 환경(Lexical Environment)을 연결한 것이긴 한데, 이 부분은 추후에 다루도록 하겠다. 어쨌든, 요는 내부 스코프에서는 외부 스코프의 변수(식별자)를 참조할 수 있지만, 외부 스코프에서는 내부 스코프의 그 무엇도 참조할 수 없다는 사실이다. 물론, 아래와 같이 찾고 있는 식별자가 내부 스코프에 있다면, 그것이 반환되며, 123456789101112function kirin() &#123; console.log('kirin is good beer!');&#125;function stella() &#123; function kirin() &#123; console.log('asahi is good beer?'); &#125; kirin();&#125;stella(); // asahi is good beer? 내부에 없을 때에만 스코프 체인에서 해당 식별자를 발견할 때까지 거슬러 올라간다. 123456789101112function kirin() &#123; console.log('kirin is good beer!');&#125;function stella() &#123; function asahi() &#123; console.log('asahi is good beer?'); &#125; kirin();&#125;stella(); // kirin is good beer! 참고자료 번역 자바스크립트 스코프와 클로저(JavaScript Scope and Closures) JavaScript Scope and Closures | CSS-Tricks Understanding Execution Context and Execution Stack in Javascript","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://codeameba.github.io/categories/JavaScript/"}],"tags":[{"name":"일기","slug":"일기","permalink":"http://codeameba.github.io/tags/%EC%9D%BC%EA%B8%B0/"},{"name":"til","slug":"til","permalink":"http://codeameba.github.io/tags/til/"},{"name":"TIL","slug":"TIL","permalink":"http://codeameba.github.io/tags/TIL/"},{"name":"Today I Learned","slug":"Today-I-Learned","permalink":"http://codeameba.github.io/tags/Today-I-Learned/"},{"name":"오늘배운것들","slug":"오늘배운것들","permalink":"http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Javascript","slug":"Javascript","permalink":"http://codeameba.github.io/tags/Javascript/"},{"name":"패스트캠퍼스","slug":"패스트캠퍼스","permalink":"http://codeameba.github.io/tags/%ED%8C%A8%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%8D%BC%EC%8A%A4/"}]},{"title":"[JavaScript Preview] 함수의 정의(Function Definition)","slug":"programming/js-function-definition","date":"2019-06-05T16:00:42.000Z","updated":"2020-02-03T07:47:26.902Z","comments":true,"path":"2019/06/06/programming/js-function-definition/","link":"","permalink":"http://codeameba.github.io/2019/06/06/programming/js-function-definition/","excerpt":"","text":"꼭 알아야 하는 자바스크립트의 20가지 개념INDEX(링크 업데이트 예정) Data type Literal Expression Primitive type vs Object type Function Definition Scope Lexical Scope 전역 변수의 문제점 var 키워드로 선언한 변수의 문제점 Constructor Function this DOM 브라우저 동작 Event Delegation Event Capturing vs Event Bubbling Class super Prototype Promise 동기식 처리 모델 vs 비동기식 처리 모델 함수(Function) 함수는 자바스크립트에서 가장 중요한 기능이라고 할 수 있다. 여타 프로그래밍 언어와는 달리 자바스크립트의 함수는 객체로 취급되며, 심지어 1급 객체이다.JavaScript 함수는 퍼스트 클래스? - codeAmeba 함수(Function)의 기본 구조와 작동 방식 자바스크립트에서 객체는 객체 리터럴 표기법을 생성이 가능하다. 함수 역시 객체이며, 함수 리터럴로 생성을 할 수 있다. 기본적으로 function 키워드, 식별자(함수명), 매개변수 목록 그리고 함수 몸체로 이루어진다. 함수명 함수명은 식별자이기 때문에 식별자 네이밍 규칙을 준수해야 한다. 함수명은 함수 몸체 내부에서만 참조할 수 있는 식별자다. 함수명을 생략할 수도 있으며, 이를 익명 함수(anonymous function)이라고 부른다. 매개변수(parameter) 0개 이상의 매개변수를 받을 수 있으며, 쉼표로 구분한다. 매개변수(parameter)에는 인수(argument)가 할당된다. 이는 곧, 매개변수도 변수(variable)이며, 인수는 값(value)이라는 의미다. 함수 몸체 내에서는 변수와 동일하게 취급한다. 함수 몸체(Function Body) 함수가 호출되었을 때 일괄적으로 실행될 문들을 하나의 실행 단위로 정의한 코드 블록이다. 함수 몸체는 함수 호출에 의해 실행된다. 123function square(number) &#123; return number * number;&#125; 위와 같이 자바스크립트에서 함수의 정의는 함수 키워드로 시작되며. 그 뒤에 함수명(식별자명)을 지정하고, 소괄호 () 와 중괄호{}가 이어진다. 소괄호에는 매개변수(parameter)가 있으며, 이곳으로 인수(argument)가 전달된다. 중괄호에는 표현식(expression)과 문(statement)이 들어가게 되며, 매개변수로 전달 받은 인수가 이곳을 거치게 된다. 따라서 일반적인 함수의 형태는 표현식인 문이라고 할 수 있다. 이렇게 정의된 함수는 아래와 같이 호출된 후에 실행된다. 1234567891011121314function changeBeer(newBeer) &#123; newBeer.name = 'Stella';&#125;var myBeer = &#123; name: 'Kirin', country: 'Japan', taste: 'deep' &#125;;var x;x = myBeer.name;console.log(x); // Kirin// 함수 호출changeBeer(myBeer);x = myBeer.name;console.log(x); // Stella 함수의 정의(Function Definition) 함수를 정의하는 방법에는 4가지가 있는데, 각각의 정의 방법에는 적합한 상황이 있고, 함수가 동작하는 방식에 다소 차이가 있기 때문에 두루 숙지하는 것이 좋다. 선언문을 통한 함수의 정의 123function add(a, b) &#123; return a + b;&#125;; 표현식을 통한 함수의 정의 123const add = function (a, b) &#123; return a + b;&#125;; 생성자 함수(Function Constructor)를 통한 함수의 정의 1const add = new Function('a', 'b', 'return a + b'); 화살표 함수(Arrow Function) -&gt; ES6에서 추가 1const add = (a, b) =&gt; a + b; 위와 같이 4가지의 방식으로 함수를 정의하는데, 일관되게 보이는 것이 바로 식별자다. 그 이유는, 함수 선언문을 통해 생성된 함수 객체는 고유한 식별자를 통해 참조해야만 하며, 아무도 참조하지 않는 함수 객체는 가비지 컬렉터에 의해 메모리에서 해제되기 때문이다.함수 선언문 또는 함수 표현식을 통해 식별자를 지정하고, 함수를 정의하게 되는데, 함수 선언문 !== 함수 표현식 작성중… 참고자료 함수 - JavaScript | MDN 함수 - JavaScript | MDN 함수 | PoiemaWeb","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://codeameba.github.io/categories/JavaScript/"}],"tags":[{"name":"일기","slug":"일기","permalink":"http://codeameba.github.io/tags/%EC%9D%BC%EA%B8%B0/"},{"name":"til","slug":"til","permalink":"http://codeameba.github.io/tags/til/"},{"name":"TIL","slug":"TIL","permalink":"http://codeameba.github.io/tags/TIL/"},{"name":"Today I Learned","slug":"Today-I-Learned","permalink":"http://codeameba.github.io/tags/Today-I-Learned/"},{"name":"오늘배운것들","slug":"오늘배운것들","permalink":"http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Javascript","slug":"Javascript","permalink":"http://codeameba.github.io/tags/Javascript/"},{"name":"패스트캠퍼스","slug":"패스트캠퍼스","permalink":"http://codeameba.github.io/tags/%ED%8C%A8%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%8D%BC%EC%8A%A4/"}]},{"title":"[JavaScript Preview] 데이터 타입(Data type)의 구분과 이유","slug":"programming/js-data-type","date":"2019-06-02T16:00:42.000Z","updated":"2020-02-03T07:47:26.902Z","comments":true,"path":"2019/06/03/programming/js-data-type/","link":"","permalink":"http://codeameba.github.io/2019/06/03/programming/js-data-type/","excerpt":"","text":"꼭 알아야 하는 자바스크립트의 20가지 개념INDEX(링크 업데이트 예정) Data type Literal Expression Primitive type vs Object type Function Definition Scope Lexical Scope 전역 변수의 문제점 var 키워드로 선언한 변수의 문제점 Constructor Function this DOM 브라우저 동작 Event Delegation Event Capturing vs Event Bubbling Class super Prototype Promise 동기식 처리 모델 vs 비동기식 처리 모델 데이터 타입(Data Type) 데이터 타입은 프로그래밍 언어의 가장 기본적인 구성 요소이며, 자바스크립트 역시 다양한 데이터 타입을 갖고 있다.자바스크립트의 데이터 타입은 크게 두 종류로 나눌 수 있는데, 원시 타입(Primitive Type)과 객체 타입(Object Type)이 바로 그것이다. 그리고 원시 타입은 다시 여섯 종류로 나누어진다. 원시 타입(Primitive Type) Number String Boolean Undefined Null Symbol Object Type Object 데이터 타입을 구분하는 이유 일반적인 프로그래밍 언어는 자바스크립트처럼 값으로 데이터 타입을 구분하지 않고, 변수 키워드를 통해 구분한다. 대표적으로 int, float, str 등이 그렇다. 하지만 자바스크립트는 데이터 타입과 상관 없이 var, let, const 세 개의 변수 키워드로 모든 데이터 타입을 정의할 수 있다. 그렇다고 해서 데이터 타입의 구분도 필요 없는 것은 아닌데, 자바스크립트 엔진은 평가된 값에 따라 데이터 타입을 나눈다. 12var num = 1; // Numbervar num = '1'; // String 이처럼 데이터 타입을 구분하는 가장 큰 이유는 메모리 공간 확보에 있다. 값은 2진수로 메모리에 저장되며 변수는 해당 메모리 공간의 주소값을 가리키게 되는데, 이때 필요한 최소 메모리 공간이 데이터 타입에 따라 다르다. 이외에도 데이터 타입이 필요한 이유에는 몇 가지가 더 있는데 크게 세 가지의 이유를 들자면 아래와 같다. 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해 값을 참조할 때 한번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해 메모리에 읽어 들인 2진수를 어떻게 해석해야 할지 결정하기 위해 참고 자료 poiemaweb.com MDN","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://codeameba.github.io/categories/JavaScript/"}],"tags":[{"name":"일기","slug":"일기","permalink":"http://codeameba.github.io/tags/%EC%9D%BC%EA%B8%B0/"},{"name":"til","slug":"til","permalink":"http://codeameba.github.io/tags/til/"},{"name":"TIL","slug":"TIL","permalink":"http://codeameba.github.io/tags/TIL/"},{"name":"Today I Learned","slug":"Today-I-Learned","permalink":"http://codeameba.github.io/tags/Today-I-Learned/"},{"name":"오늘배운것들","slug":"오늘배운것들","permalink":"http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Javascript","slug":"Javascript","permalink":"http://codeameba.github.io/tags/Javascript/"},{"name":"패스트캠퍼스","slug":"패스트캠퍼스","permalink":"http://codeameba.github.io/tags/%ED%8C%A8%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%8D%BC%EC%8A%A4/"}]},{"title":"[JavaScript Preview] 표현식(Expression)과 문(Statement)","slug":"programming/js-expression","date":"2019-06-02T16:00:42.000Z","updated":"2020-02-03T07:47:26.902Z","comments":true,"path":"2019/06/03/programming/js-expression/","link":"","permalink":"http://codeameba.github.io/2019/06/03/programming/js-expression/","excerpt":"","text":"꼭 알아야 하는 자바스크립트의 20가지 개념INDEX(링크 업데이트 예정) Data type Literal Expression Primitive type vs Object type Function Definition Scope Lexical Scope 전역 변수의 문제점 var 키워드로 선언한 변수의 문제점 Constructor Function this DOM 브라우저 동작 Event Delegation Event Capturing vs Event Bubbling Class super Prototype Promise 동기식 처리 모델 vs 비동기식 처리 모델 표현식(Expression) 자바스크립트에서의 값(value)은 리터럴 표기법으로도 생성이 가능하지만, 대개의 경우 표현식(Expression)으로 생성한다. 엄밀히 따지면, 리터럴은 표현식의 일부라고 할 수 있으며, 표현식은 리터럴 외에도 식별자, 연산자, 함수 호출 등으로도 구성할 수 있다. 1234567891011121314151617// 리터럴 표현식10'beer'// 식별자 표현식(선언을 했다는 가정 하에)beerbeer.namebeerBox[2]// 연산자 표현식5 + 10sum = 15a !== b// 함수, 메서드 호출 표현식(선언을 했다는 가정 하에)multiply()beer.getName() 결국, 표현식은 하나의 값으로 평가될 수 있는 문(statement)라고 할 수 있다. 문(Statement) || 표현식(Expression) 처음 자바스크립트를 배울 때 이해하기 어려운 개념 베스트 5에 들어가는 개념이라면, 단연 문과 표현식의 구분이라고 나는 말하고 싶다. 나 역시 그랬다. 하지만, 각각의 역할을 생각하면 구분하는 것은 쉽다. 요는, 문은 자바스크립트 엔진에게 명령을 내리는 것이고, 표현식은 값으로 평가될 수 있다는 것이다. 따라서 값을 통해 명령을 내릴 경우 그것은 표현식인 문이다. 표현식만으로는 명령을 내릴 수 없다. 만약, 그래도 둘의 역할이 헷갈린다면, 간단히 구분할 수 있는 방법이 있다. 바로, 변수에 할당을 해보는 것이다. 변수에 할당할 수 있는 것은 값이며, 따라서 변수에 할당이 된다면 그것은 표현식이다. 예를 들어 아래와 같은 것이다. 12345var a; // 변수 선언문은 표현식이 아닌 문이다.a = 10; // 할당문은 표현식인 문이다.var b = bar a; // Uncaught SyntaxError: Unexpected token var -&gt; 문은 값처럼 사용할 수 없다.var b = a = 100; // 표현식인 문은 값처럼 사용할 수 있다.console.log(b); // 100 참고 자료 poiemaweb.com","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://codeameba.github.io/categories/JavaScript/"}],"tags":[{"name":"일기","slug":"일기","permalink":"http://codeameba.github.io/tags/%EC%9D%BC%EA%B8%B0/"},{"name":"til","slug":"til","permalink":"http://codeameba.github.io/tags/til/"},{"name":"TIL","slug":"TIL","permalink":"http://codeameba.github.io/tags/TIL/"},{"name":"Today I Learned","slug":"Today-I-Learned","permalink":"http://codeameba.github.io/tags/Today-I-Learned/"},{"name":"오늘배운것들","slug":"오늘배운것들","permalink":"http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Javascript","slug":"Javascript","permalink":"http://codeameba.github.io/tags/Javascript/"},{"name":"패스트캠퍼스","slug":"패스트캠퍼스","permalink":"http://codeameba.github.io/tags/%ED%8C%A8%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%8D%BC%EC%8A%A4/"}]},{"title":"[JavaScript Preview] 리터럴(Literal)의 이해","slug":"programming/js-literal","date":"2019-06-02T16:00:42.000Z","updated":"2020-02-03T07:47:26.920Z","comments":true,"path":"2019/06/03/programming/js-literal/","link":"","permalink":"http://codeameba.github.io/2019/06/03/programming/js-literal/","excerpt":"","text":"꼭 알아야 하는 자바스크립트의 20가지 개념INDEX(링크 업데이트 예정) Data type Literal Expression Primitive type vs Object type Function Definition Scope Lexical Scope 전역 변수의 문제점 var 키워드로 선언한 변수의 문제점 Constructor Function this DOM 브라우저 동작 Event Delegation Event Capturing vs Event Bubbling Class super Prototype Promise 동기식 처리 모델 vs 비동기식 처리 모델 리터럴(Literal) 리터털(Literal)은 소스 코드 내에 직접 타이핑하여 만들어낸 값 자체를 의미한다. 자칫 값(value)와 혼동하기 쉬운데, 리터럴은 값이 될 수 있지만, 값은 리터럴이 될 수 없다. 즉, 리터럴은 평가(Evaluation)되기 이전의 표현식을 구성하는 것이라고 할 수 있다. 123457 // 리터럴 표기법으로 작성한 숫자 리터럴5 + 10 // 표현식의 일부로 작성된 리터럴 5와 리터럴 10true // 불리언 리터럴‘Hello!’ // 문자열 리터럴&#123; id: 1, name: 'Kirin ichiban', drunk: true &#125; // 객체 리터럴 위와 같이 자바스크립트의 소스 코드를 이루는 요소 하나 하나가 모두 리터럴이다.또한, 리터럴은 값이 될 수 있지만, 값은 리터럴이 될 수 있다는 말은 아래의 예시를 통해 이해할 수 있다. 12var a = 10;var b = 2 + 8; a와 b는 동일하게 10으로 평가된 값을 갖는다. 표현식인 2 + 8이 값을 평가될 때에는 둘의 합으로 평가되어 변수 b에 할당되기 때문이다. 하지만, 리터럴로 놓고 봤을 때 둘은 다르다. a는 10이라는 리터럴이 평가된 값을 갖고, b는 리터럴 2와 리터럴8 그리고, 연산자로 이루어진 표현식이 평가된 값을 갖는다. 참고 자료 poiemaweb.com MDN","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://codeameba.github.io/categories/JavaScript/"}],"tags":[{"name":"일기","slug":"일기","permalink":"http://codeameba.github.io/tags/%EC%9D%BC%EA%B8%B0/"},{"name":"til","slug":"til","permalink":"http://codeameba.github.io/tags/til/"},{"name":"TIL","slug":"TIL","permalink":"http://codeameba.github.io/tags/TIL/"},{"name":"Today I Learned","slug":"Today-I-Learned","permalink":"http://codeameba.github.io/tags/Today-I-Learned/"},{"name":"오늘배운것들","slug":"오늘배운것들","permalink":"http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Javascript","slug":"Javascript","permalink":"http://codeameba.github.io/tags/Javascript/"},{"name":"패스트캠퍼스","slug":"패스트캠퍼스","permalink":"http://codeameba.github.io/tags/%ED%8C%A8%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%8D%BC%EC%8A%A4/"}]},{"title":"[JavaScript Exercise] Realtime Analog Clock","slug":"programming/coding-exercise-realtime-clock","date":"2019-05-31T16:00:42.000Z","updated":"2020-02-03T07:47:26.539Z","comments":true,"path":"2019/06/01/programming/coding-exercise-realtime-clock/","link":"","permalink":"http://codeameba.github.io/2019/06/01/programming/coding-exercise-realtime-clock/","excerpt":"","text":"실시간 아날로그 시계현재시간을 반영한 아날로그와 디지털 시계 구현 See the Pen [exercise] real time clock by Sooyoung Jeong (@codeAmeba) on CodePen.","categories":[{"name":"Exercise","slug":"Exercise","permalink":"http://codeameba.github.io/categories/Exercise/"}],"tags":[{"name":"일기","slug":"일기","permalink":"http://codeameba.github.io/tags/%EC%9D%BC%EA%B8%B0/"},{"name":"til","slug":"til","permalink":"http://codeameba.github.io/tags/til/"},{"name":"TIL","slug":"TIL","permalink":"http://codeameba.github.io/tags/TIL/"},{"name":"Today I Learned","slug":"Today-I-Learned","permalink":"http://codeameba.github.io/tags/Today-I-Learned/"},{"name":"오늘배운것들","slug":"오늘배운것들","permalink":"http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Javascript","slug":"Javascript","permalink":"http://codeameba.github.io/tags/Javascript/"},{"name":"패스트캠퍼스","slug":"패스트캠퍼스","permalink":"http://codeameba.github.io/tags/%ED%8C%A8%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%8D%BC%EC%8A%A4/"}]},{"title":"[JavaScript Exercise] Stop watch","slug":"programming/coding-exercise-stopwatch","date":"2019-05-31T16:00:42.000Z","updated":"2020-02-03T07:47:26.540Z","comments":true,"path":"2019/06/01/programming/coding-exercise-stopwatch/","link":"","permalink":"http://codeameba.github.io/2019/06/01/programming/coding-exercise-stopwatch/","excerpt":"","text":"STOP WATCHStart, Stop 버튼 클릭으로 동작하는 스톱워치 구현setInterval()과 clearInterval() 메서드가 관건 내용추가리셋 버튼 추가 1차 시도 123$reset.addEventListener('click', function () &#123; $display.innerHTML = '00:00:00';&#125;); 초기화 되는 듯 보였지만, start 버튼 누르면 stop 했던 시점부터 다시 시작 됨 2차 시도 123$reset.addEventListener('click', function () &#123; $display.innerHTML = `0$&#123;min = 0&#125;:0$&#123;sec = 0&#125;:0$&#123;milSec = 0&#125;`;&#125;); 스트링 인터폴레이션 사용하여 시간 출력할 때와 동일한 방식으로 적용 제대로 초기화 됨 See the Pen [exercise] stop watch by Sooyoung Jeong (@codeAmeba) on CodePen.","categories":[{"name":"Exercise","slug":"Exercise","permalink":"http://codeameba.github.io/categories/Exercise/"}],"tags":[{"name":"일기","slug":"일기","permalink":"http://codeameba.github.io/tags/%EC%9D%BC%EA%B8%B0/"},{"name":"til","slug":"til","permalink":"http://codeameba.github.io/tags/til/"},{"name":"TIL","slug":"TIL","permalink":"http://codeameba.github.io/tags/TIL/"},{"name":"Today I Learned","slug":"Today-I-Learned","permalink":"http://codeameba.github.io/tags/Today-I-Learned/"},{"name":"오늘배운것들","slug":"오늘배운것들","permalink":"http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Javascript","slug":"Javascript","permalink":"http://codeameba.github.io/tags/Javascript/"},{"name":"패스트캠퍼스","slug":"패스트캠퍼스","permalink":"http://codeameba.github.io/tags/%ED%8C%A8%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%8D%BC%EC%8A%A4/"}]},{"title":"[Book Review] 프로그래밍 심리학(The psychology of computer programming)","slug":"blog/book-review-phychology-of-programming","date":"2019-05-29T16:00:42.000Z","updated":"2020-02-14T14:31:08.559Z","comments":true,"path":"2019/05/30/blog/book-review-phychology-of-programming/","link":"","permalink":"http://codeameba.github.io/2019/05/30/blog/book-review-phychology-of-programming/","excerpt":"","text":"[Book Review] 프로그래밍 심리학(The psychology of computer programming) 프로그래밍 심리학 제럴드 M. 와인버그 저약 40년 전 제랄드 와인버그는 ‘프로그래밍도 사람이 하는 것’이라는, 당연하지만 현실에선 제대로 인정받지 못하는 문제 인식을 바탕으로 『프로그래밍 심리학』을 탄생시켰다. 프로그래밍을 둘러싼 여러 부류의 사람들이 가지는 마음의 이치를 다룬 역사적인 책이다. 프로젝트를 이끌어나가는 사람 사이의 관계뿐 아니... 프로그래밍 + 심리학 본디 책 욕심이 과한 나는, 본격적인 공부를 시작하기도 전부터 프로그래밍 관련 서적이라면 닥치는대로 사 모았다. 그렇게 충동구매 했던 많은 책들 중 하나가 ‘프로그래밍 심리학’이었다. 몇 개월을 책장에만 두고 읽을 엄두도 못 내다가 마침내 최근에서야 읽었는데, 수많은 책들 중 가장 먼저 읽게 된 이유라면 역시 제목이었다. ‘프로그래밍’과 ‘심리학’이라니, 마치 수십년간 서로를 이해하지 못 하는 이과와 문과가 조화롭게 어울리는 듯한 생경한 모습으로 다가왔다. 더불어, 아직 코드를 물 흐르듯 읽을 정도의 실력이 되지 못 하는 나는 가장 코드의 등장 빈도가 낮은 이 책을 선택한 것이다. 프로그래밍 심리학은 어떤 책인가 프로그래밍이라는 분야는 여러모로 흥미로운 분야다. 학문으로써도 그렇지만, 프로그래밍 역사에 한 획을 그은 이들 중 상당수가 아직까지 생존하고 있다는 점이 특히 그렇다. 그만큼 역사가 길지 않은데, 이 책은 약 40년 전 초판이 발행되었다. 불과 40년 밖에 되지 않은 책이 프로그래밍 세계에서는 고전인 것이다. 어찌 흥미롭지 않을 수 있겠는가. 심지어 프로그래밍 심리학의 저자 또한 아직까지 건재하여 개정판이 나올 때마다 내용을 덧붙이고 있다. 이러한 프로그래밍 세계의 고전 ‘프로그래밍 심리학’에서 시종일관 강조하는 것은, 협업에 관한 내용이다. 예나 지금이나 사람 관계만큼 힘든 것이 없다. 그것은 이쪽 업계도 마찬가지인 것이다. 저자는 협업을 강조하는 과정에 있어서 빼먹지 않고 각자의 심리를 연관 짓고 있는데, 그럼에도 마지막에 남는 것은 심리보다는 인간관계에 대한 다양한 사례들이다. 그래서인지 개인적으로는 심리학보다 인간관계론의 비중이 크게 느껴졌다. 책에서는 대략적으로 다음과 같은 내용들을 다룬다. ‘프로그래밍을 하는 프로그래머 본인의 심리’, ‘프로그래머 사이의 관계’, ‘프로그래머와 관리자의 관계’, ‘프로그래머의 마음가짐과 태도’ 등을 다양한 사례를 곁들이며 유쾌하게 풀어내고 있다. 그리고, 역시 약 40년 전에 쓰인 책이라고 느껴질 수 있는 대목도 심심치 않게 등장한다. ‘천공카드’, ‘FORTRAN’, ‘PL/1’ 등 지금은 쉽게 접하기 어려운 용어들인데, 덕분에 겸사겸사 비루한 내 배경지식을 키울 수 있어서 긍정적으로 다가왔다. 프로그래머로서의 자세 이런저런 재밌는 옛날(?)이야기들이 대거 등장하지만, 결국 저자가 말하고 싶은 것은 프로그래머로서의 자세라고 생각한다. 내가 이 책을 읽고 느낀 것은 크게 세 가지다. 첫째,프로그래밍이라는 행위는 프로그래머 한 명과 컴퓨터 사이에서만 진행되는 개인적인 일이 아니라, 다수의 프로그래머와 프로그래머가 아닌 누군가가 컴퓨터를 도구 삼아 유기적으로 진행하는 삶의 한 부분인 것이다. 따라서 컴퓨터보다 사람을 먼저 생각해야 한다. 둘째,너무 겸손한 태도도, 너무 자신만만한 태도도 좋지 않다. 특히, 과한 자신감은 집단과 멀어지게 만들고, 작은 실수도 크게 보이게 한다. 셋째,컴퓨터는 융통성이 없기 때문에, 프로그래머는 유연한 사고를 할 수 있어야 한다. 또한, 컴퓨터는 시시때때로 앞에 앉은 사람을 한 없이 바보처럼 느끼게 만들기 때문에, 프로그래머의 가장 큰 덕목은 유머러스함과 끊임없는 동기부여다. 인상적인 대목 끝으로, 두고 두고 다시 읽으며 기억하고 싶은 인상적인 대목을 여기에 적어두려 한다. 프로그램은 사람이 만드는 다른 모든 물건처럼 명확한 수명과 활용 범위를 염두에 두고 설계되어야 한다. 수백 년 동안 유지될 수 있을 만큼 논리적인 방법으로 만든 장인의 작품처럼, 프로그램에는 과도하게 설계된 부분도 미진하게 설계된 부분도 있어서는 안 된다.-프로그래밍 심리학 p.246- 아마도 좋은 프로그래머를 만드는 요소가 훌륭한 우정을 만드는 요소와 비슷하다는 사실을 발견하게 될 것이다. 바로, 상호 관심과 개성 존중이다.-프로그래밍 심리학 p.262- 프로그래머에게는 유머감각이 필요하다. 컴퓨터는 자신 앞에 앉은 사람을 모두 바보로 만드는 기계이기 때문에 우스꽝스러운 꼴을 당한 자신의 모습을 웃고 넘길 수 없는 사람이 프로그래머로 오랫동안 버티기는 어렵다. 누군가가 말했다. 프로그래머의 주제가는 “아아아아아(괴로워하는 신음소리)”라고. 프로그래머는 작업을 하나 마칠 때마다 자기가 저질렀던 멍청한 실수와 대면한다. 그리고 주제가의 두 번째 소절을 부른다. “하하하하” 그러지 않고서는 광대 노릇을 계속할 수가 없다.-프로그래밍 심리학 p.284- 심리적 자세가 야기한 문제를 논할 때에는 주석문 얘기가 빠질 수 없다. 코드에 주석을 다는 목적은 읽는 이가 코드를 직접 보기 전에 적당한 마음의 준비를 하게 만들려는 것이다. 그 코드가 정확히 구현되어 있다면, 주석문은 확실히 효과가 있다. 그러나 코드가 부정확하다면, 읽는 사람의 심리적 자세가 주석문의 지배를 당하기 때문에 오류를 찾아내는 데 오히려 방해가 된다.-프로그래밍 심리학 p.303- 우리 머릿속의 잘못된 믿을들을 깨끗이 쓸어 내고, 가능하다면 실험을 통해 나온 견고한 증거들로 채워 넣을 때가 되었다. 여러 문제 중 일부라도 결국에는 해결된다는 뜻이 아니다. 그러기에는 문제가 너무 복잡하다. 그러나 언제나 완벽하게 해결될 수 있는 문제만 풀어볼 만한 가치가 있지는 않다. 사실, 우리에게 필요한 것은 정답이 아니라 그것을 찾는 과정에서 얻는 경험이다.-프로그래밍 심리학 p.484-","categories":[{"name":"내가 읽은 책","slug":"내가-읽은-책","permalink":"http://codeameba.github.io/categories/%EB%82%B4%EA%B0%80-%EC%9D%BD%EC%9D%80-%EC%B1%85/"}],"tags":[{"name":"book review","slug":"book-review","permalink":"http://codeameba.github.io/tags/book-review/"},{"name":"독후감","slug":"독후감","permalink":"http://codeameba.github.io/tags/%EB%8F%85%ED%9B%84%EA%B0%90/"},{"name":"developer","slug":"developer","permalink":"http://codeameba.github.io/tags/developer/"},{"name":"book","slug":"book","permalink":"http://codeameba.github.io/tags/book/"},{"name":"개발자","slug":"개발자","permalink":"http://codeameba.github.io/tags/%EA%B0%9C%EB%B0%9C%EC%9E%90/"},{"name":"프로그래밍 심리학","slug":"프로그래밍-심리학","permalink":"http://codeameba.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%8B%AC%EB%A6%AC%ED%95%99/"}]},{"title":"[JavaScript Exercise] Counter","slug":"programming/coding-exersice-counter","date":"2019-05-28T16:00:42.000Z","updated":"2020-02-03T07:47:26.540Z","comments":true,"path":"2019/05/29/programming/coding-exersice-counter/","link":"","permalink":"http://codeameba.github.io/2019/05/29/programming/coding-exersice-counter/","excerpt":"","text":"Counter 버튼을 누르면 증가, - 버튼을 누르면 감소단, 음수는 허용하지 않음. See the Pen [exercise] counter by Sooyoung Jeong (@codeAmeba) on CodePen.","categories":[{"name":"Exercise","slug":"Exercise","permalink":"http://codeameba.github.io/categories/Exercise/"}],"tags":[{"name":"일기","slug":"일기","permalink":"http://codeameba.github.io/tags/%EC%9D%BC%EA%B8%B0/"},{"name":"til","slug":"til","permalink":"http://codeameba.github.io/tags/til/"},{"name":"TIL","slug":"TIL","permalink":"http://codeameba.github.io/tags/TIL/"},{"name":"Today I Learned","slug":"Today-I-Learned","permalink":"http://codeameba.github.io/tags/Today-I-Learned/"},{"name":"오늘배운것들","slug":"오늘배운것들","permalink":"http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Javascript","slug":"Javascript","permalink":"http://codeameba.github.io/tags/Javascript/"},{"name":"패스트캠퍼스","slug":"패스트캠퍼스","permalink":"http://codeameba.github.io/tags/%ED%8C%A8%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%8D%BC%EC%8A%A4/"}]},{"title":"[JavaScript Exercise] Toggle side nav","slug":"programming/coding-exercise-toggle","date":"2019-05-27T16:00:42.000Z","updated":"2020-02-03T07:47:26.540Z","comments":true,"path":"2019/05/28/programming/coding-exercise-toggle/","link":"","permalink":"http://codeameba.github.io/2019/05/28/programming/coding-exercise-toggle/","excerpt":"","text":"Toggle side nav화살표 버튼을 클릭했을 때 사이드 내비게이션이 나오도록 구현 See the Pen exercise-01 by Sooyoung Jeong (@codeAmeba) on CodePen.","categories":[{"name":"Exercise","slug":"Exercise","permalink":"http://codeameba.github.io/categories/Exercise/"}],"tags":[{"name":"일기","slug":"일기","permalink":"http://codeameba.github.io/tags/%EC%9D%BC%EA%B8%B0/"},{"name":"til","slug":"til","permalink":"http://codeameba.github.io/tags/til/"},{"name":"TIL","slug":"TIL","permalink":"http://codeameba.github.io/tags/TIL/"},{"name":"Today I Learned","slug":"Today-I-Learned","permalink":"http://codeameba.github.io/tags/Today-I-Learned/"},{"name":"오늘배운것들","slug":"오늘배운것들","permalink":"http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Javascript","slug":"Javascript","permalink":"http://codeameba.github.io/tags/Javascript/"},{"name":"패스트캠퍼스","slug":"패스트캠퍼스","permalink":"http://codeameba.github.io/tags/%ED%8C%A8%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%8D%BC%EC%8A%A4/"}]},{"title":"[JavaScript Exercise] 배열을 사용한 HTML 생성","slug":"programming/coding-exercise-dom-control","date":"2019-05-26T16:00:42.000Z","updated":"2020-02-03T07:47:26.539Z","comments":true,"path":"2019/05/27/programming/coding-exercise-dom-control/","link":"","permalink":"http://codeameba.github.io/2019/05/27/programming/coding-exercise-dom-control/","excerpt":"","text":"HTML 생성아래 배열을 사용하여 html을 생성하는 함수를 작성하라. 123456789101112131415161718192021222324252627const todos = [ &#123; id: 3, content: 'HTML', completed: false &#125;, &#123; id: 2, content: 'CSS', completed: true &#125;, &#123; id: 1, content: 'Javascript', completed: false &#125;];function render() &#123; let html = ''; todos.forEach(function (todo) &#123; html += `&lt;li id=\"$&#123;todo.id&#125;\"&gt;&lt;label&gt;&lt;input type=\"checkbox\" $&#123;todo.completed ? 'checked' : ''&#125;&gt;$&#123;todo.content&#125;&lt;/label&gt;&lt;/li&gt;` &#125;); return html;&#125;console.log(render());/*&lt;li id=\"3\"&gt; &lt;label&gt;&lt;input type=\"checkbox\" &gt;HTML&lt;/label&gt;&lt;/li&gt;&lt;li id=\"2\"&gt; &lt;label&gt;&lt;input type=\"checkbox\" checked&gt;CSS&lt;/label&gt;&lt;/li&gt;&lt;li id=\"1\"&gt; &lt;label&gt;&lt;input type=\"checkbox\" &gt;Javascript&lt;/label&gt;&lt;/li&gt;*/","categories":[{"name":"Exercise","slug":"Exercise","permalink":"http://codeameba.github.io/categories/Exercise/"}],"tags":[{"name":"일기","slug":"일기","permalink":"http://codeameba.github.io/tags/%EC%9D%BC%EA%B8%B0/"},{"name":"til","slug":"til","permalink":"http://codeameba.github.io/tags/til/"},{"name":"TIL","slug":"TIL","permalink":"http://codeameba.github.io/tags/TIL/"},{"name":"Today I Learned","slug":"Today-I-Learned","permalink":"http://codeameba.github.io/tags/Today-I-Learned/"},{"name":"오늘배운것들","slug":"오늘배운것들","permalink":"http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Javascript","slug":"Javascript","permalink":"http://codeameba.github.io/tags/Javascript/"},{"name":"패스트캠퍼스","slug":"패스트캠퍼스","permalink":"http://codeameba.github.io/tags/%ED%8C%A8%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%8D%BC%EC%8A%A4/"}]},{"title":"[JavaScript Exercise] 1~10,000에는 8이 몇 개 있을까?","slug":"programming/coding-exercise-count8","date":"2019-05-25T16:00:42.000Z","updated":"2020-02-18T05:25:20.007Z","comments":true,"path":"2019/05/26/programming/coding-exercise-count8/","link":"","permalink":"http://codeameba.github.io/2019/05/26/programming/coding-exercise-count8/","excerpt":"","text":"1~10,000의 숫자 중 8이 등장하는 횟수1부터 10,000까지 8이라는 숫자가 총 몇번 나오는가? 이를 구하는 함수를 완성하라.단, 8이 포함되어 있는 숫자의 갯수를 카운팅 하는 것이 아니라 8이라는 숫자를 모두 카운팅 해야 한다. 예를 들어 8808은 3, 8888은 4로 카운팅 해야 한다.(hint) 문자열 중 n번째에 있는 문자 : str.charAt(n) or str[n] 123456789101112131415161718function getCount8() &#123; // 변수 str에 1~10,000까지 문자열로 할당 예정 let str = ''; // 변수 sum에 str의 '8' 개수를 카운팅하여 할당 예정 let sum = 0; // 1~10,000까지 1씩 증가 시켜서 str에 할당 for (let i = 0; i &lt; 10000; i++) &#123; str += i; &#125; // str의 전체 길이 -1만큼 순회하여 '8'이 등장할 때마다 sum 증가 for (let j = 0; j &lt; str.length; j++) &#123; if (str[j] === '8') sum++; &#125; return sum;&#125;console.log(getCount8()); // 4000","categories":[{"name":"Exercise","slug":"Exercise","permalink":"http://codeameba.github.io/categories/Exercise/"}],"tags":[{"name":"일기","slug":"일기","permalink":"http://codeameba.github.io/tags/%EC%9D%BC%EA%B8%B0/"},{"name":"til","slug":"til","permalink":"http://codeameba.github.io/tags/til/"},{"name":"TIL","slug":"TIL","permalink":"http://codeameba.github.io/tags/TIL/"},{"name":"Today I Learned","slug":"Today-I-Learned","permalink":"http://codeameba.github.io/tags/Today-I-Learned/"},{"name":"오늘배운것들","slug":"오늘배운것들","permalink":"http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Javascript","slug":"Javascript","permalink":"http://codeameba.github.io/tags/Javascript/"}]},{"title":"[JavaScript Exercise] 짝수와 홀수","slug":"programming/coding-exercise-evenodd","date":"2019-05-22T16:00:42.000Z","updated":"2020-02-03T07:47:26.539Z","comments":true,"path":"2019/05/23/programming/coding-exercise-evenodd/","link":"","permalink":"http://codeameba.github.io/2019/05/23/programming/coding-exercise-evenodd/","excerpt":"","text":"짝수와 홀수evenOrOdd 함수는 정수 num을 매개변수로 받는다. num은 1이상의 정수이며, num이 음수인 경우는 없다.num이 짝수일 경우 ‘Even’을 반환하고 홀수인 경우 ‘Odd’를 반환하도록 evenOrOdd 함수를 완성하라. 1차 시도1234567891011function evenOrOdd (num) &#123; if (num &gt; 1 &amp;&amp; num % 2 === 0) &#123; console.log('Even'); &#125; else &#123; console.log('Odd'); &#125;&#125;console.log(evenOrOdd(2)); // Even undefinedconsole.log(evenOrOdd(3)); // Odd undefinedconsole.log(evenOrOdd(1000)); // Even undefined 왜인지 undefined가 같이 출력되었다. 2차 시도12345678910111213function evenOrOdd(num) &#123; if (num &gt; 1) &#123; if (num % 2 === 0) &#123; return 'Even'; &#125; if (num % 2 === 1) &#123; return 'Odd'; &#125; &#125;&#125;console.log(evenOrOdd(2)); // Evenconsole.log(evenOrOdd(3)); // Oddconsole.log(evenOrOdd(1000)); // Even 1차 시도 때에는 반환문이 누락되어 undefined가 나왔다는 것을 알게 되었다. 3차 시도1234567891011121314// 1은 true, 0은 falsefunction evenOrOdd(num) &#123; // num % 2 === 1 은 true이므로 홀수 if (num % 2) &#123; return 'Odd'; // num % 2 === 0 은 false이므로 짝수 &#125; else &#123; return 'Even'; &#125;&#125;console.log(evenOrOdd(2)); // Evenconsole.log(evenOrOdd(3)); // Oddconsole.log(evenOrOdd(1000)); // Even 0은 falsy, 1은 truthy이므로 이를 이용하여 2차 시도 때보다 짧게 구성할 수 있었다. 3항 연산자로 바꾸기 1차 시도12345678function evenOrOdd(num) &#123; let result = num &gt; 1 &amp;&amp; num % 2 === 0 ? 'Even' : 'Odd'; return result;&#125;console.log(evenOrOdd(2)); // Evenconsole.log(evenOrOdd(3)); // Oddconsole.log(evenOrOdd(1000)); // Even 2차 시도123456789function evenOrOdd(num) &#123; let res = ''; res += num % 2 ? 'Odd' : 'Even'; return res;&#125;console.log(evenOrOdd(2)); // Evenconsole.log(evenOrOdd(3)); // Oddconsole.log(evenOrOdd(1000)); // Even","categories":[{"name":"Exercise","slug":"Exercise","permalink":"http://codeameba.github.io/categories/Exercise/"}],"tags":[{"name":"일기","slug":"일기","permalink":"http://codeameba.github.io/tags/%EC%9D%BC%EA%B8%B0/"},{"name":"til","slug":"til","permalink":"http://codeameba.github.io/tags/til/"},{"name":"TIL","slug":"TIL","permalink":"http://codeameba.github.io/tags/TIL/"},{"name":"Today I Learned","slug":"Today-I-Learned","permalink":"http://codeameba.github.io/tags/Today-I-Learned/"},{"name":"오늘배운것들","slug":"오늘배운것들","permalink":"http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Javascript","slug":"Javascript","permalink":"http://codeameba.github.io/tags/Javascript/"},{"name":"패스트캠퍼스","slug":"패스트캠퍼스","permalink":"http://codeameba.github.io/tags/%ED%8C%A8%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%8D%BC%EC%8A%A4/"}]},{"title":"[JavaScript] 배열(array)을 조작하는 다양한 방법","slug":"programming/array-control","date":"2019-05-18T16:00:42.000Z","updated":"2020-02-03T07:47:26.539Z","comments":true,"path":"2019/05/19/programming/array-control/","link":"","permalink":"http://codeameba.github.io/2019/05/19/programming/array-control/","excerpt":"","text":"[JavaScript] 배열(array) 요소를 조작하는 다양한 방법 1. 배열 요소의 추가 1 - 1. 인덱스를 지정하여 요소 추가 배열의 요소에는 기본적으로 0부터 시작되는 인덱스가 지정되어 있으며, 요소를 추가할 때는 해당 요소의 인덱스와 함께 추가해야 한다. 1234567891011let beerBox = [];console.log(beerBox[0]); // undefinedbeerBox[] = 'kirin';console.log(beerBox); // Uncaught SyntaxError: Unexpected tokenbeerBox[1] = 'kirin';beerBox[3] = 'stella';console.log(beerBox); // [empty, \"kirin\", empty, \"stella\"]console.log(beerBox.length); // 4 1 - 2. push와 unshift메서드를 통한 요소 추가 push와 unshift를 사용하여 배열에 요소를 추가할 수도 있다. 용어에서 알 수 있듯 컴퓨터공학에서 심심치 않게 등장하는 용어들로 각각 스택(stack)과 큐(queue)와 관련된 행동을 한다. 각각의 특징으로는, push는 배열의 끝에 요소를 추가하며, unshift는 배열의 가장 앞에 요소를 추가한다는 것이다. 12345678910111213let beerBox = [];beerBox.push('kirin');console.log(beerBox); // [ 'kirin' ]beerBox.unshift('stella');console.log(beerBox); // [ 'stella', 'kirin' ]beerBox.push('cass', 'hite');console.log(beerBox); // [ 'stella', 'kirin', 'cass', 'hite' ]beerBox.unshift('kozel', 'asahi');console.log(beerBox); // [ 'kozel', 'asahi', 'stella', 'kirin', 'cass', 'hite' ] 위의 예제에서 볼 수 있듯이 unshift는 배열의 앞으로 요소를 추가한다. 1 - 3. concat 메서드를 통한 요소 추가 concat은 엄밀히 따지자면 요소를 추가한다기 보다는, 요소를 복사 및 붙여넣기 한다고 볼 수 있다. 12345678910111213let firstBox = ['cass', 'hite', 'fitz'];let secondBox = ['asahi', 'kirin', 'stella'];let thirdBox = firstBox.concat(secondBox);console.log(thirdBox); // (6) [\"cass\", \"hite\", \"fitz\", \"asahi\", \"kirin\", \"stella\"]let fourthBox = firstBox.concat('1664 blanc');console.log(fourthBox); // (4) [\"cass\", \"hite\", \"fitz\", \"1664 blanc\"]let fifthBox = firstBox.concat('kozel', 'guinness');console.log(fifthBox); // (5) [\"cass\", \"hite\", \"fitz\", \"kozel\", \"guinness\"]console.log(firstBox); // (3) [\"cass\", \"hite\", \"fitz\"] 위의 예제와 같이 concat을 통하여 각각의 배열이 하나의 배열로 합쳐질 수 있으며, 여기서 주의 깊게 볼 것은 원본의 배열은 그대로 남아있다는 것이다. 2. 배열 요소의 제거 2 - 1. delete와 splice를 통한 요소의 제거 delete 를 사용하면 배열의 요소를 제거할 수 있다. 이때 delete는 메서드가 아니라 연산자이며, 특정 요소의 인덱스를 지정하여 제거할 수 있다.다만, 요소만 제거될 뿐, 인덱스는 그대로 남게 되어 해당 인덱스는 empty로 채워지게 된다. 1234567let beerBox = ['cass', 'hite', 'fitz', 'asahi', 'kirin', 'stella'];delete beerBox[2];console.log(beerBox); // (6) [\"cass\", \"hite\", empty, \"asahi\", \"kirin\", \"stella\"]beerBox.splice(2, 1);console.log(beerBox); // (5) [\"cass\", \"hite\", \"asahi\", \"kirin\", \"stella\"] 따라서 delete로 요소를 제거한 다음, 해당 인덱스까지 제거하기 위해 splice 메서드를 사용한다. splice 메서드는 다음과 같은 구조를 하고 있다. 1beerBox.splice(제거할 인덱스 시작점, 시작점으로부터의 요소 갯수); 2 - 2. pop과 shift 메서드를 활용한 요소의 제거 앞서 요소를 추가할 때 사용했던 push와 unshift 메서드에는 각각 짝이 있다. 동일한 방식의 작업인데 반대의 결과를 가져오는 메서드로 볼 수 있는데, 그것이 바로 pop과 shift다. 마찬가지로 stack과 queue를 배울 때 자주 보게 되는 녀석들이다. 사용법은 아래와 같다. 1234567let beerBox = ['cass', 'hite', 'fitz', 'asahi', 'kirin', 'stella'];beerBox.pop();console.log(beerBox); // (5) [\"cass\", \"hite\", \"fitz\", \"asahi\", \"kirin\"]beerBox.shift();console.log(beerBox); // (4) [\"hite\", \"fitz\", \"asahi\", \"kirin\"] 특이한 점이 있다면, pop과 shift는 특정 인덱스나 요소를 지정하지 않는다는 것이다. 그 이유는 이들의 특성에 있다. 아래의 예시를 통해 확인해보자. 123456789let beerBox = ['cass', 'hite', 'fitz', 'asahi', 'kirin', 'stella'];beerBox.pop(0); // \"stella\"beerBox.pop('cass'); // \"kirin\"console.log(beerBox); // (4) [\"cass\", \"hite\", \"fitz\", \"asahi\"]beerBox.shift(-1); // \"cass\"beerBox.shift('asahi'); // \"hite\"console.log(beerBox); // (2) [\"fitz\", \"asahi\"] 위와 같이 pop과 shift는 임의로 지정하는 요소와 별개로 동작한다. pop은 맨뒤의 요소부터 차례대로 제거하고, shift는 맨앞의 요소부터 차례대로 제거한다. 결론적으로 이들, push - pop, unshift - shift는 stack과 queue의 특성으로 이해하면 된다. 스택(stack)은 **LIFO(후입선출, Last In First Out)**의 특성이 있다. 즉, 마지막에 입력된 자료부터 출력된다는 말이다. 반대로 큐(queue)는 **FIFO(선입선출, First In First Out)**라는 특성이 있다. 즉, 먼저 입력된 자료부터 출력된다. 3. 그 밖의 배열을 조작하는 방법들(작성 예정) 3 - 1. 요소 가져오기 slice() 12345678910111213const myBeer = ['Kirin', 'Stella', 'Guinness'];let res = myBeer.slice(0, 1);console.log(res); // [\"Kirin\"]res = myBeer.slice(1);console.log(res); // [\"Stella\", \"Guinness\"]res = myBeer.slice(1, 2);console.log(res); // [\"Stella\"]res = myBeer.slice(-1);console.log(res); // [\"Guinness\"] 3 - 2. 요소 추가 및 제거 동시에 하기 splice() 1234567891011121314const firstBeerBox = ['Kirin', 'Stella', 'Cass', 'Hite'];const yourBeer = firstBeerBox.splice(2, 2);console.log(firstBeerBox); // [ 'Kirin', 'Stella' ]console.log(yourBeer); // [ 'Cass', 'Hite' ]const secondBeerBox = ['Kozel', '1664 Blanc', 'Guinness', 'Asahi'];const myBeer = secondBeerBox.splice(1);console.log(secondBeerBox); // [ 'Kozel' ]console.log(myBeer); // [ '1664 Blanc', 'Guinness', 'Asahi' ] 3 - 3. 요소 교체하기 copyWithin() 3 - 4. 특정 값으로 채우기 fill() 1234const beer = ['kirin', 'stella', 'cass', 'hite'];beer.fill('asahi');console.log(beer); // (4) [\"asahi\", \"asahi\", \"asahi\", \"asahi\"] 3 - 5. 배열 정렬과 역순 정렬 sort()reverse() 1234567const beer = ['kirin', 'stella', 'cass', 'hite'];beer.sort();console.log(beer); // (4) [\"cass\", \"hite\", \"kirin\", \"stella\"]beer.reverse();console.log(beer); // (4) [\"stella\", \"kirin\", \"hite\", \"cass\"] 하지만, sort는 유니코드 순서로 정렬한다는 문제가 있다. 그래서 아래와 같이 숫자형 요소를 지닌 배열의 경우 일반적인 방법으로는 마음에 드는 정렬이 완성되지 않는다. 따라서 오름차순대로 정렬되도록 별도의 함수를 사용해야 한다. 1234567const arrNum = [100, 30, 2, 1543, 76, 6, 19, 753];arrNum.sort();console.log(arrNum); // (8) [100, 1543, 19, 2, 30, 6, 753, 76]arrNum.sort((a, b) =&gt; a - b);console.log(arrNum); // (8) [2, 6, 19, 30, 76, 100, 753, 1543] 위의 함수는 ES6에서 추가된 화살표함수다. 우리 눈에 익숙한 형태인 아래의 함수와 동일한 기능을 한다. 1234const arrNum = [100, 30, 2, 1543, 76, 6, 19, 753];arrNum.sort(function (a, b) &#123; return a - b; &#125;);console.log(arrNum); // (8) [2, 6, 19, 30, 76, 100, 753, 1543] 또한, 이것을 응용하면 reverse의 효과도 낼 수 있다. 1234const arrNum = [100, 30, 2, 1543, 76, 6, 19, 753];arrNum.sort((a, b) =&gt; b - a);console.log(arrNum); // (8) [1543, 753, 100, 76, 30, 19, 6, 2] 1234567891011121314151617181920212223const beerBox = [ &#123; id: 4, content: 'Kirin' &#125;, &#123; id: 1, content: 'Stella' &#125;, &#123; id: 2, content: 'Guinness' &#125;];function compare(key) &#123; return function (a, b) &#123; return a[key] &gt; b[key] ? 1 : (a[key] &lt; b[key] ? -1 : 0); &#125;;&#125;beerBox.sort(compare('id'));console.log(beerBox);// 0:&#123;id:1,content:\"Stella\"&#125;// 1:&#123;id:2,content:\"Guinness\"&#125;// 2:&#123;id:4,content:\"Kirin\"&#125;beerBox.sort(compare('content'));console.log(beerBox);// 0:&#123;id:2,content:\"Guinness\"&#125;// 1:&#123;id:4,content:\"Kirin\"&#125;// 2:&#123;id:1,content:\"Stella\"&#125; 참고자료 Learning JavaScript (ISBN 9788968483387) poiemaweb.com MDN Immersive_Sprint.js Stack &amp; Queue – 이용현 – Medium 이미지 출처 unsplash.com","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://codeameba.github.io/categories/JavaScript/"}],"tags":[{"name":"일기","slug":"일기","permalink":"http://codeameba.github.io/tags/%EC%9D%BC%EA%B8%B0/"},{"name":"til","slug":"til","permalink":"http://codeameba.github.io/tags/til/"},{"name":"TIL","slug":"TIL","permalink":"http://codeameba.github.io/tags/TIL/"},{"name":"Today I Learned","slug":"Today-I-Learned","permalink":"http://codeameba.github.io/tags/Today-I-Learned/"},{"name":"오늘배운것들","slug":"오늘배운것들","permalink":"http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Javascript","slug":"Javascript","permalink":"http://codeameba.github.io/tags/Javascript/"},{"name":"패스트캠퍼스","slug":"패스트캠퍼스","permalink":"http://codeameba.github.io/tags/%ED%8C%A8%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%8D%BC%EC%8A%A4/"}]},{"title":"[JavaScript] 배열(array)의 기본 사항","slug":"programming/array-basic","date":"2019-05-17T16:00:42.000Z","updated":"2020-02-03T07:47:26.539Z","comments":true,"path":"2019/05/18/programming/array-basic/","link":"","permalink":"http://codeameba.github.io/2019/05/18/programming/array-basic/","excerpt":"","text":"[JavaScript] 자바스크립트 배열(array)의 기본 사항 자바스크립트에서 배열은 무척 중요한 객체(object)이며, 이를 통해 다양한 작업들을 수행할 수 있다. 기본적인 사항들은 다음과 같다. 객체는 순서가 없지만, 배열은 순서가 있는 데이터의 집합이며 0부터 시작하는 숫자형 인덱스를 사용한다. 12345let beerCollection = [];console.log(beerCollection[1]); // undefinedconsole.log(beerCollection.length); // 0console.log(typeof beerCollection); // object 자바스크립트의 모든 데이터 타입이 배열의 요소가 될 수 있다. 즉, 배열의 요소로 또다른 배열을 포함한다거나, 객체나 함수까지 하나의 배열에 포함할 수 있다. 1234567891011121314151617181920let beerCollection = [ 'kirin', // string 3, // number ['oneBottle', 'twoBottle', 'threeBottle'], // array function drinkBeer() &#123;&#125;, // function &#123; name: 'stella', country: 'Belgium' &#125; // object literal];console.log(beerCollection);// 콘솔에서 아래와 같이 확인할 수 있다./*(5)[\"kirin\", 3, Array(3), ƒ, &#123;…&#125;]0:\"kirin\"1:32:(3)[\"oneBottle\",\"twoBottle\",\"threeBottle\"]3: ƒ drinkBeer()4:&#123;name:\"stella\",country:\"Belgium\"&#125;length:5__proto__:Array(0)*/ 배열은 기본적으로 length 프로퍼티를 가지며, 이것은 요소의 갯수를 나타낸다. 12345let beerCollection = [ 'kirin', 'stella', 'asahi', 'cass', 'sapporo', 'kozel'];console.log(beerCollection.length); // 6 배열의 길이(length)보다 큰 인덱스로 요소를 할당하면 배열은 자동으로 길이가 늘어나며, 비어있는 인덱스에는 empty가 채워진다. 1234567891011121314151617181920let beerCollection = [ 'kirin', 'stella', 'asahi', 'cass', 'sapporo', 'kozel'];beerCollection[9] = '1664 blanc';console.log(beerCollection.length); // 10console.log(beerCollection);// 콘솔에서 아래와 같이 확인할 수 있다./*(10)[\"kirin\", \"stella\", \"ashai\", \"cass\", \"sapporo\", \"kozel\", empty × 3, \"1664 blanc\"]0:\"kirin\"1:\"stella\"2:\"asahi\"3:\"cass\"4:\"sapporo\"5:\"kozel\"9:\"1664 blanc\"length:10__proto__:Array(0)*/ Array 생성자로 배열을 만들 수도 있다. 하지만, 그런 경우는 드물다. 123let beerCollection = new Array(5);console.log(beerCollection); // (5) [empty × 5] 참고자료 Learning JavaScript (ISBN 9788968483387) poiemaweb.com MDN","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://codeameba.github.io/categories/JavaScript/"}],"tags":[{"name":"일기","slug":"일기","permalink":"http://codeameba.github.io/tags/%EC%9D%BC%EA%B8%B0/"},{"name":"til","slug":"til","permalink":"http://codeameba.github.io/tags/til/"},{"name":"TIL","slug":"TIL","permalink":"http://codeameba.github.io/tags/TIL/"},{"name":"Today I Learned","slug":"Today-I-Learned","permalink":"http://codeameba.github.io/tags/Today-I-Learned/"},{"name":"오늘배운것들","slug":"오늘배운것들","permalink":"http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Javascript","slug":"Javascript","permalink":"http://codeameba.github.io/tags/Javascript/"},{"name":"패스트캠퍼스","slug":"패스트캠퍼스","permalink":"http://codeameba.github.io/tags/%ED%8C%A8%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%8D%BC%EC%8A%A4/"}]},{"title":"[JavaScript Preview] 함수는 퍼스트 클래스?","slug":"programming/first-class-object","date":"2019-05-16T16:00:42.000Z","updated":"2020-02-03T07:47:26.902Z","comments":true,"path":"2019/05/17/programming/first-class-object/","link":"","permalink":"http://codeameba.github.io/2019/05/17/programming/first-class-object/","excerpt":"","text":"[JavaScript] 함수는 1급 객체(first-class object) 1급 객체란, 특정 언어의일급 객체(first-class citizens, 일급 값, 일급 엔티티, 혹은 일급시민)이라 함은 컴퓨터 프로그래밍 언어 디자인에서 일반적으로 다른 객체들에 적용 가능한 연산을 모두 지원하는 객체를 가리킨다. 함수에 매개변수로 넘기기, 변수에 대입하기와 같은 연산들이 여기서 말하는일반적인연산의 예에 해당한다.직관적으로 설명하자면, Function 이면서 Class의 성질인 지닌 객체 또는 Class이면서 Function의 성질을 지닌 객체를 First-Class Citizens 라고 이해할 수 있다.JavaScript 에서 Function에 Property를 줄 수 있는 것이 대표적인 예이다. 위의 내용이 위키백과에서 말하는 1급 객체의 설명이다. 내가 이해한 1급 객체 우선 자바스크립트에서 대표적인 1급 객체로 취급 받는 함수(Function)는 다음과 같은 특성을 지니고 있기에 1급 객체라고 한다. 무명의 리터럴로 생성이 가능하다. 따라서 런타임에 생성이 가능하다. 변수 혹은 객체나 배열 등의 자료구조에 저장이 가능하다. 함수의 매개변수(parameter)에 전달이 가능하다. 함수의 반환값(return)으로 사용이 가능하다. 123456789101112131415161718192021222324252627282930313233343536/*1. 무명의 리터럴로 생성이 가능하다.2. 변수나 자료구조에 저장이 가능하다.-&gt; 런타임(할당 단계)에 함수 리터럴이 평가되어 함수 객체가 생성되고 변수에 할당 된다.*/const getBeer = function (num) &#123; return ++num;&#125;;const loseBeer = function (num) &#123; return --num;&#125;;// 함수 객체를 객체에 저장할 수 있다.const myBeer = &#123; getBeer, loseBeer &#125;;// 3. 함수의 매개변수에 전달이 가능하다.// 4. 함수의 반환값으로 사용이 가능하다.function myBeerCounter(myBeer) &#123; let num = 0; return function () &#123; num = myBeer(num); return num; &#125;;&#125;// myBeerCounter의 매개변수에 함수 객체를 전달const getBeerCounter = myBeerCounter(myBeer.getBeer);console.log(getBeerCounter()); // 1console.log(getBeerCounter()); // 2// myBeerCounter의 매개변수에 함수 객체를 전달const loseBeerCounter = myBeerCounter(myBeer.loseBeer);console.log(loseBeerCounter()); // -1console.log(loseBeerCounter()); // -2 이처럼 자바스크립트의 함수는 마치 1급 시민권을 소유한 시민이 자유와 특권을 갖고 있듯 여타 객체들에 비해 관여할 수 있는 범위가 넓다. 활용하기에 따라 무궁무진한 결과를 만들어낼 수 있는 강력한 기능인 함수이기 때문에 최근 함수형 프로그래밍이 각광 받는 게 아닐까 싶다. 배워야 할 것들이 너무나 많아서 행복하다(?). 참고자료 WIKIPEDIA poiemaweb.com Javascript에서 왜 함수가 1급 객체일까요? – Sona Lee – Medium","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://codeameba.github.io/categories/JavaScript/"}],"tags":[{"name":"일기","slug":"일기","permalink":"http://codeameba.github.io/tags/%EC%9D%BC%EA%B8%B0/"},{"name":"til","slug":"til","permalink":"http://codeameba.github.io/tags/til/"},{"name":"TIL","slug":"TIL","permalink":"http://codeameba.github.io/tags/TIL/"},{"name":"Today I Learned","slug":"Today-I-Learned","permalink":"http://codeameba.github.io/tags/Today-I-Learned/"},{"name":"오늘배운것들","slug":"오늘배운것들","permalink":"http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Javascript","slug":"Javascript","permalink":"http://codeameba.github.io/tags/Javascript/"},{"name":"패스트캠퍼스","slug":"패스트캠퍼스","permalink":"http://codeameba.github.io/tags/%ED%8C%A8%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%8D%BC%EC%8A%A4/"}]},{"title":"[JavaScript] Why so undefined?","slug":"programming/js-why-undefined","date":"2019-05-14T16:00:42.000Z","updated":"2020-02-03T07:47:26.920Z","comments":true,"path":"2019/05/15/programming/js-why-undefined/","link":"","permalink":"http://codeameba.github.io/2019/05/15/programming/js-why-undefined/","excerpt":"","text":"[JavaScript] why so undefined? *** 1991년은 undefined 123456789101112131415function isLeapYear(year) &#123; if (year % 4 === 0) &#123; if (year % 100 === 0) &#123; if (year % 400 === 0) &#123; return '윤년'; &#125; return '평년'; &#125; return '윤년'; &#125;&#125;console.log(isLeapYear(2100)); // 평년console.log(isLeapYear(1600)); // 윤년console.log(isLeapYear(1991)); // undefined 제어문에 살짝 자신감이 붙어서 년도를 인수로 입력하면, 평년 혹은 윤년을 출력하는 함수를 if문으로 만들어봤다. 그리고 2100년과 1600년을 넣자 제대로 작동을 했다. 그런데, 1991년과 같이 4로 나누어지지 않는 년도를 입력하면 undefined가 나오는 것이 아닌가. 알고 보니 if (year % 4 === 0) 조건이 false일 때의 반환문(return)과 반환값이 빠졌으며, 함수는 반환문이나 반환값 둘 중 하나만 누락되어도 undefined를 반환하는 것이었다. 아래와 같이 반환문을 명시적으로 지정하고 나서야 나의 윤년 계산기는 제대로 작동하였다. 123456789101112131415161718function isLeapYear(year) &#123; if (year % 4 === 0) &#123; if (year % 100 === 0) &#123; if (year % 400 === 0) &#123; return '윤년'; &#125; return '평년'; &#125; return '윤년'; &#125; return '평년'; // (year % 4 !== 0)일 때의 반환문을 추가&#125;console.log(isLeapYear(2100)); // 평년console.log(isLeapYear(1991)); // 평년console.log(isLeapYear(1993)); // 평년console.log(isLeapYear(2000)); // 윤년console.log(isLeapYear(1600)); // 윤년 결론적으로 지금은 원인을 알게 되었지만, 이런 기초적인 내용을 내가 잊었다는 것에 상당히 큰 충격을 받고 ‘함수’ 파트를 다시 읽어보았다. 그리고, 이번에 경험한 사례 외에도 undefined가 반환되는 경우가 몇 가지 더 있다는 것도 새삼 알게 되었다. 분명 읽었던 내용일 텐데 새로운 것은 왜일까. 내 머리를 점점 더 믿을 수 없게 된다. 훗날 내가 또 잊을 수 있으니 한 번 더 정리하고 넘어가도록 한다. 함수의 반환문 함수는 return 키워드와 반환값으로 구성된 반환문을 사용하여 실행 결과를 반환할 수 있다. 그리고, 함수를 호출하면, 이때 반환값으로 평가된다. 함수에서 반환문의 특징은 두 가지가 있는데, 첫째, 함수 실행 도중 반환문이 있을 경우 실행이 중단되고 함수 몸체를 빠져나간다. 즉, 반환문 이후에 존재하는 문은 무시된다. 1234567// 반환문이 먼저 나온 경우function selectBeer(beer) &#123; return 'Just Drink'; console.log('I like ' + beer + '!!!');&#125;console.log(selectBeer('kirin')); // Just Drink 12345678// 반환문이 나중에 나온 경우function selectBeer(beer) &#123; console.log('I like ' + beer + '!!!'); return 'Just Drink';&#125;console.log(selectBeer('kirin')); // I like kirin!!! // Just Drink 둘째, 반환문은 return 키워드 뒤에 지정한 값을 반환한다. 이때, 반환값을 명시적으로 지정하지 않으면 undefined가 반환된다. 123456// 반환값을 생략한 경우function drinkBeer() &#123; return;&#125;console.log(drinkBeer()); // undefined 물론, 우리의 자바스크립트는 무척 친절하기 때문에 반환문을 생략해도 오류가 나지는 않는다. 다만, 함수가 마지막 문까지 실행된 후 암묵적으로 undefined가 반환된다. 123456// 반환문이 없는 경우function drinkBeer() &#123;&#125;console.log(drinkBeer()); // undefined 참고자료 poiemaweb.com MDN 이미지 출처 unsplash.com","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://codeameba.github.io/categories/JavaScript/"}],"tags":[{"name":"일기","slug":"일기","permalink":"http://codeameba.github.io/tags/%EC%9D%BC%EA%B8%B0/"},{"name":"til","slug":"til","permalink":"http://codeameba.github.io/tags/til/"},{"name":"TIL","slug":"TIL","permalink":"http://codeameba.github.io/tags/TIL/"},{"name":"Today I Learned","slug":"Today-I-Learned","permalink":"http://codeameba.github.io/tags/Today-I-Learned/"},{"name":"오늘배운것들","slug":"오늘배운것들","permalink":"http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Javascript","slug":"Javascript","permalink":"http://codeameba.github.io/tags/Javascript/"},{"name":"패스트캠퍼스","slug":"패스트캠퍼스","permalink":"http://codeameba.github.io/tags/%ED%8C%A8%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%8D%BC%EC%8A%A4/"}]},{"title":"[JavaScript Preview] 객체(object)를 생성하는 다양한 방법","slug":"programming/js-object-constructor","date":"2019-05-13T16:00:42.000Z","updated":"2020-02-03T07:47:26.919Z","comments":true,"path":"2019/05/14/programming/js-object-constructor/","link":"","permalink":"http://codeameba.github.io/2019/05/14/programming/js-object-constructor/","excerpt":"","text":"[JavaScript Preview] 객체(object)를 생성하는 다양한 방법 자바스크립트의 객체는 이름(key)과 값(value)을 하나로 묶은 집합이다. 이러한 집합 하나 하나를 프로퍼티(property)라고 부른다. 값으로는 원시 값(primitive)과 객체(object) 타입 데이터가 모두 할당될 수 있는데, 당연히 객체인 함수(function)도 참조 값으로 들어올 수가 있다. 그리고, 값의 자리에 함수가 오는 경우는 구분을 위해 메서드(method)라고 부른다. 1. 객체 리터럴(Literal) 생성 객체를 생성하는 가장 기본적인 방법은 객체 리터럴이다. 기본적으로 변수에 값을 할당하는 형태와 크게 다르지 않으며, 이름과 값으로 이루어진 프로퍼티를 중괄호{}로 감싼다. 1234const beer = &#123; name: 'stella', taste: 'fruity'&#125;; 객체는 프로퍼티의 추가 및 수정, 삭제가 가능하며, 프로퍼티가 없는 빈 객체를 생성하는 것 또한 가능하다. 123456789101112131415// 빈 객체 생성const beer = &#123;&#125;;console.log(beer); // &#123;&#125;// 프로퍼티 추가beer.name = 'kirin';console.log(beer); // &#123;name: \"kirin\"&#125;// 프로퍼티 수정beer.name = 'stella';console.log(beer); // &#123;name: \"stella\"&#125;// 프로퍼티 삭제delete(beer.name); // trueconsole.log(beer); // &#123;&#125; 위와 같이 프로퍼티의 삭제까지 가능하지만, 삭제는 추가, 수정에 비해 메모리에 가해지는 부담이 크기 때문에 되도록 하지 않는 게 좋다. 2. 내장(built in) 객체 생성자(constructor) 아래의 소스 코드와 같이 new 연산자와 함께 Object 생성자 함수를 호출하면 빈 객체를 생성 및 반환한다. 이렇게 생성된 빈 객체에도 객체 리터럴과 마찬가지로 프로퍼티(property)나 메서드(method)를 추가할 수가 있다. 123456789101112// 빈 객체 생성const beer = new Object();// 프로퍼티 추가// 이때 this는 메서드를 호출한 객체를 가리킨다.beer.name = 'kirin';beer.drinkBeer = function () &#123; console.log('Yeah! ' + this.name + ' is good beer!');&#125;;console.log(beer); // &#123;name: \"kirin\", drinkBeer: ƒ&#125;beer.drinkBeer(); // Yeah! kirin is good beer! 이와 같은 생성자 함수를 내장 객체(built in object)라고 하며, 자바스크립트 엔진에 기본적으로 탑재되어 있다. 앞서 소개한 객체를 생성하는 Object 외에도 문자열 객체를 생성하는 String, 숫자 객체를 생성하는 Number, 논리값 객체를 생성하는 Boolean 등 다양한 내장 객체들이 있다. 이 내장 객체들은 함수 형식으로 사용하여 객체를 생성하기 때문에 생성자(constructor) 함수라고도 하며, new 연산자와 함께 호출했을 때, 객체(인스턴스)를 생성할 수 있다. 이때 인스턴스란, 생성자 함수에 의해 생성된 객체를 뜻하는데, 다른 객체와 구분을 하기 위해 인스턴스라고 부른다. 다만, 단순히 빈 객체를 생성하는 것이라면, 객체 리터럴 표기법을 사용하는 편이 더욱 간편하다. 3. 생성자 함수 123456789101112// name과 taste가 parameter의 역할을 하며, arguments를 입력 받아 인스턴스가 생성된다.// 이때 this는 생성자 함수가 생성하게 될 인스턴스를 가리킨다.function Beer(name, taste) &#123; this.name = name; this.taste = taste;&#125;// new 연산자를 사용하여 arguments를 입력한다.const beer = new Beer('kirin', 'deep');console.log(beer); // Beer &#123;name: \"kirin\", taste: \"deep\"&#125; 작성중… 참고자료 poiemaweb.com MDN 모던 자바스크립트 입문 ISBN 9791160504439 이미지 출처 unsplash.com","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://codeameba.github.io/categories/JavaScript/"}],"tags":[{"name":"일기","slug":"일기","permalink":"http://codeameba.github.io/tags/%EC%9D%BC%EA%B8%B0/"},{"name":"til","slug":"til","permalink":"http://codeameba.github.io/tags/til/"},{"name":"TIL","slug":"TIL","permalink":"http://codeameba.github.io/tags/TIL/"},{"name":"Today I Learned","slug":"Today-I-Learned","permalink":"http://codeameba.github.io/tags/Today-I-Learned/"},{"name":"오늘배운것들","slug":"오늘배운것들","permalink":"http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Javascript","slug":"Javascript","permalink":"http://codeameba.github.io/tags/Javascript/"},{"name":"패스트캠퍼스","slug":"패스트캠퍼스","permalink":"http://codeameba.github.io/tags/%ED%8C%A8%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%8D%BC%EC%8A%A4/"}]},{"title":"[JavaScript Preview] 전역 변수를 왜 지양해야 하는가","slug":"programming/js-no-more-global-variable","date":"2019-05-09T16:00:42.000Z","updated":"2020-02-03T07:47:26.920Z","comments":true,"path":"2019/05/10/programming/js-no-more-global-variable/","link":"","permalink":"http://codeameba.github.io/2019/05/10/programming/js-no-more-global-variable/","excerpt":"","text":"꼭 알아야 하는 자바스크립트의 20가지 개념INDEX(링크 업데이트 예정) Data type Literal Expression Primitive type vs Object type Function Definition Scope Lexical Scope 전역 변수의 문제점 var 키워드로 선언한 변수의 문제점 Constructor Function this DOM 브라우저 동작 Event Delegation Event Capturing vs Event Bubbling Class super Prototype Promise 동기식 처리 모델 vs 비동기식 처리 모델 [JavaScript Preview] 전역 변수를 왜 지양해야 하는가 1. 변수의 생명 주기(Life cycle)변수 선언에 의해 생성된 변수는 영원불멸이 아니다. 언젠가는 소멸하게 되어 있는데, 이를 생명 주기라고 한다.변수는 선언된 위치에서 생성과 소멸을 겪게 되는데, 그렇기 때문에 당연히 전역 변수와 지역 변수의 생명 주기에는 차이가 있다. 지역 변수의 생명 주기함수 내부에서 생성된 지역변수(Local variable)은 함수와 생사를 함께 한다. 아래와 같은 함수가 있을 때, 123456789// 지역변수의 생명 주기function drink() &#123; var beer = 'stella'; console.log(beer); return beer;&#125;drink();console.log(beer); drink 함수가 호출되기 전까지 지역변수 beer는 생성되지 않으며, 마침내 drink 함수가 호출 되었을 때야 비로소 변수 beer도 생성된다. 이때의 순서는 전역변수가 호이스팅 되듯이 함수 몸체의 문들이 순차적으로 실행되기 이전에 변수 beer의 선언이 자바스크립트 엔진에 의해 우선적으로 실행되어 undefined로 초기화 된다. 그 이후에 함수 몸체의 문들이 순차적으로 실행 되며 변수에 값이 할당된다. 그리고 함수가 종료될 때 변수도 소멸하며 생명 주기가 종료된다. 마치, 김춘수의 꽃이라는 시가 생각나는 모습이 아닐 수 없다. 함수를 호출했을 때에만 비로소 변수로써의 제역할을 하는 것이다. 전역 변수의 생명 주기전역 변수는 함수와 다르게 호출이 없더라도 실행이 되고, 함수와 달리 return 문이 필요 없기 때문에 더 이상 실행할 문이 없더라도 종료되지 않는다. 만일 전역 코드가 종료된다면 애플리케이션에 존재하는 모든 이벤트는 작동하지 않게 된다. 즉, 전역 변수와 애플리케이션의 생명 주기는 일치한다고 볼 수 있다. 2. 전역 변수 === 시한폭탄이러한 전역 변수에는 당연하게도 문제가 많은데, 크게 네 가지로 나눌 수가 있겠다. 암묵적 결합전역 변수는 이름 그대로 소스 코드 어디서든지 사용할 수 있는 변수다. 어느 위치의 어느 코드든지 전역 변수를 참조하고, 변경할 수 있다는 것이다. 이것을 암묵적 결합(Implicit coupling)이라고 하는데, 언뜻 듣기에는 편리하고 좋을 것 같은 느낌이 들기도 한다. 하지만, 전역 변수의 유효 범위 즉, 소스 코드의 길이가 길어질수록 가독성은 저하되고, 의도치 않게 상태가 변경되는 등의 위험성이 있다. 긴 생명 주기앞서 말했지만, 전역 변수의 생명 주기는 길다. 애플리케이션의 입장으로 보자면, 영원불멸의 삶을 사는 것이다. 그리고, 그에 따른 부작용은 고스란히 애플리케이션의 성능 저하로 이어지게 된다. 이를테면, 소스 코드 내의 모든 함수들이 아무때나 참조하고, 상태를 변경할 수도 있는 24시간 편의점과 같다. 그렇기 때문에 메모리 리소스를 오랫동안 소비하는 것은 당연하다. 특히, var 키워드의 경우는 중복 선언까지 허용하는 만큼 언제 어디서 변수명이 변경될 지 모르는 일이다. 스코프 체인 상에서 종점에 존재전역 변수의 세 번째 문제점은 스코프 체인 상에서 가장 마지막에 존재한다는 점이다. 이는 변수를 검색할 때 전역 변수가 가장 마지막에 검색된다는 말인데, 따라서 전역 변수의 검색 속도가 가장 느리다는 말이기도 하다. 네임 스페이스 오염자바스크립트의 단점 중 하나는 파일이 분리되어 있어도 하나의 전역 스코프를 공유한다는 점이다. 그래서 별도의 파일이라고 해도 동일한 이름을 지닌 변수나 함수가 같은 스코프 내에 존재할 가능성이 있다는 것인데, 이것이 내 인생의 변수가 될 수도 있다. 3. 전역 변수의 사용을 어떻게 줄일 수 있을까?지금껏 말한 것처럼 전역 변수는 언제 터질 지 모르는 시한폭탄과 같다. 따라서 가능한 전역 변수의 사용을 지양하고, 지역 변수의 사용을 지향해야 한다.전역 변수의 사용을 줄일 수 있는 방법에 대해 알아보자. 즉시 실행 함수(IIFE, Immediately-Invoked Function Expression)즉시 실행 함수는 함수의 정의와 동시에 호출되는 함수를 말한다. 생성과 동시에 실행 및 소멸까지 이어지기 때문에 내부의 변수들은 모두 지역 변수라고 할 수 있다. 123456(function () &#123; var beer = 'kirin'; // 즉시 실행 함수의 지역 변수 // ...&#125;());console.log(beer); // ReferenceError: beer is not defined 네임 스페이스 객체아래와 같이 전역에 네임 스페이스 역할을 맡는 객체를 생성하여 전역 변수처럼 사용할 변수를 프로퍼티(property)로 추가하는 방법이다. 12345var BEER = &#123;&#125;; // 전역 네임 스페이스 객체 생성BEER.name = 'stella';console.log(BEER.name); // stella 또한, 네임 스페이스 객체에 새로운 네임 스페이스 객체를 프로퍼티로 추가하여 네임 스페이스를 중첩(nesting)시킬 수도 있다. 12345678var BEER = &#123;&#125;; // 전역 네임 스페이스 객체 생성BEER.species = &#123; name: 'stella', from: 'Belgium'&#125;;console.log(BEER.species.from); // Belgium 이와 같은 방법으로 식별자(Identifier)의 충돌을 막을 수 있다. 하지만, 네임 스페이스 객체는 전역 변수에 할당되기 때문에 권장할만한 방법은 아니다. 모듈 패턴(Module Pattern)모듈 패턴은 클래스(class)를 모방한 방식으로, 관련이 있는 변수와 함수를 모아서 즉시 실행 함수로 감싼 것이다. 자바스크립트의 강력한 기능인 클로저(closure)를 기반으로 동작하며, 모듈 패턴의 특징은 전역 변수의 억제와 더불어 캡슐화까지 구현할 수 있다는 것이다. 캡슐화(encapsulation)객체 지향 프로그래밍에서 캡슐화를 설명할 수 있는 특징으로는 다음의 두 가지가 있다. 객체의 속성(data fields)과 행위(메소드, methods)를 하나로 묶는다. 실제 구현 내용의 일부를 외부에서 참조할 수 없도록 은닉한다(정보은닉, information hiding). 자바스크립트의 경우는 자바(Java)의 캡슐화처럼 public, private, protected 등의 접근 제한자(Access modifier)를 지원하지는 않지만, 모듈 패턴을 통해 어느 정도 구현이 가능하다. 12345678910111213141516171819202122const Counter = (function () &#123; // private 변수 let num = 0; // 외부로 공개할 데이터나 메소드를 프로퍼티로 추가한 객체를 반환. return &#123; increase() &#123; return ++num; &#125;, decrease() &#123; return --num; &#125; &#125;;&#125;());// private 변수는 외부에서 참조할 수 없음.console.log(Counter.num); // undefinedconsole.log(Counter.increase()); // 1console.log(Counter.increase()); // 2console.log(Counter.increase()); // 3console.log(Counter.decrease()); // 2console.log(Counter.decrease()); // 1 위와 같이 모듈 패턴은 즉시 실행 함수처럼 객체를 반환하는데, 외부에 노출하고 싶은 변수 혹은 함수가 반환된다. 참고자료 poiemaweb.com MDN WIKIPEDIA 이미지 출처 poiemaweb.com unsplash.com","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://codeameba.github.io/categories/JavaScript/"}],"tags":[{"name":"일기","slug":"일기","permalink":"http://codeameba.github.io/tags/%EC%9D%BC%EA%B8%B0/"},{"name":"til","slug":"til","permalink":"http://codeameba.github.io/tags/til/"},{"name":"TIL","slug":"TIL","permalink":"http://codeameba.github.io/tags/TIL/"},{"name":"Today I Learned","slug":"Today-I-Learned","permalink":"http://codeameba.github.io/tags/Today-I-Learned/"},{"name":"오늘배운것들","slug":"오늘배운것들","permalink":"http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Javascript","slug":"Javascript","permalink":"http://codeameba.github.io/tags/Javascript/"},{"name":"패스트캠퍼스","slug":"패스트캠퍼스","permalink":"http://codeameba.github.io/tags/%ED%8C%A8%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%8D%BC%EC%8A%A4/"}]},{"title":"JavaScript TIL(2019.05.08)","slug":"programming/js-til-07","date":"2019-05-07T16:00:42.000Z","updated":"2020-02-03T07:47:26.920Z","comments":true,"path":"2019/05/08/programming/js-til-07/","link":"","permalink":"http://codeameba.github.io/2019/05/08/programming/js-til-07/","excerpt":"","text":"JavaScript TIL(19.05.08) Primitive / Object차이점 원시 타입(primitive)의 값은 immutable, 객체 타입(object)의 값은 mutable 원시 값은 변수에 실제 값이 저장, 객체는 참조 값이 저장 변수와 상수 상수도 변수의 하나다. 차이점은, 변수의 경우 재할당이 가능하지만, 상수는 그렇지 않다는 점. Mutable != 재할당1234567// const 키워드를 사용해 선언한 상수는 재할당이 금지된다.const o = &#123;&#125;;// 하지만 const 키워드를 사용해 선언한 상수에 할당된 객체는 변경할 수 있다.// 즉, 상수는 재할당이 금지된 변수일 뿐이다.o.a = 1;console.log(o); // &#123;a: 1&#125; 원시값의 이점재할당 이외에는 변하지 않기 때문에 신뢰성이 높다. 최근 트렌드는 객체도 원시 타입처럼 immutable하게 쓰는 경우가 많음 애초에 객체도 immutable로 만들었다면? 객체를 생성하는 데에 들어가는 리소스가 원시 값에 비해 훨씬 크기 때문에 재할당을 하려면 퍼포먼스가 떨어진다. Garbage collector의 역할 안 쓰는 값을 지우는 역할이 아니다. 사용되지 않는 값이 할당되어 있는 메모리를 찾고, 할당 해제 시켜서 다른 값이 사용할 수 있도록 한다. 객체객체가 만들어지는 시점 평가 후 메모리에 할당되며 변수가 가리키는 곳에는 객체가 할당된 주소값이 할당되어 있다. 결론적으로 변수는 객체의 주소값을 통해 객체값을 참조한다. 얕은 복사, 깊은 복사 얕은 복사: 참조 값만 복사하는 것 깊은 복사: 값 자체를 동일하게 복사하는 것 예제12345678910var person1 &#x3D; &#123; name: &#39;Lee&#39;&#125;;var person2 &#x3D; &#123; name: &#39;Lee&#39;&#125;;console.log(person1 &#x3D;&#x3D;&#x3D; person2); &#x2F;&#x2F; ①console.log(person1.name &#x3D;&#x3D;&#x3D; person2.name); &#x2F;&#x2F; ② False : 다른 주소 값에 저장된 객체이기 때문에 같지 않다. True : 저장된 주소 값은 다르지만, 원시값의 비교이기 때문에 같다. 함수함수는 선언이 아닌 정의가 더 적절하다.함수 사용의 이유 핵심 키워드는 코드의 재사용 일반 객체와 함수 객체의 차이는일반 객체는 호출할 수가 없지만, 함수 객체는 호출할 수가 있다. 함수의 매개변수 가장 적절한 개수는 0개 즉시 실행 함수 이름을 붙이는 것은 의미가 없기 때문에 보통 익명으로 사용 정의와 동시에 실행되며, 실행되는 동안에만 메모리에 할당되었다가 바로 삭제 됨. 인위적인 스코프를 만들고 싶을 때, 클로저를 만들 때 주로 사용함. 중첩 함수(nested function) 중첩 함수를 포함하는 외부 함수를 돕기 위해 사용함. 콜백 함수 인수로 전달 받는 함수에 따라 동작이 달라짐. 스코프(Scope)변수는 자신이 선언된 위치에 의해 자신이 유효한 범위, 즉 다른 코드가 변수 자신을 참조할 수 있는 범위가 결정된다. 예제12345678910var x &#x3D; &#39;global&#39;;function foo() &#123; var x &#x3D; &#39;local&#39;; console.log(x); &#x2F;&#x2F; ①&#125;foo();console.log(x); &#x2F;&#x2F; ② local global 참고자료 poiemaweb.com 이미지 출처 poiemaweb.com","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://codeameba.github.io/categories/JavaScript/"}],"tags":[{"name":"일기","slug":"일기","permalink":"http://codeameba.github.io/tags/%EC%9D%BC%EA%B8%B0/"},{"name":"til","slug":"til","permalink":"http://codeameba.github.io/tags/til/"},{"name":"TIL","slug":"TIL","permalink":"http://codeameba.github.io/tags/TIL/"},{"name":"Today I Learned","slug":"Today-I-Learned","permalink":"http://codeameba.github.io/tags/Today-I-Learned/"},{"name":"오늘배운것들","slug":"오늘배운것들","permalink":"http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Javascript","slug":"Javascript","permalink":"http://codeameba.github.io/tags/Javascript/"},{"name":"패스트캠퍼스","slug":"패스트캠퍼스","permalink":"http://codeameba.github.io/tags/%ED%8C%A8%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%8D%BC%EC%8A%A4/"}]},{"title":"[JavaScript Preview] 원시 타입(Primitive type)과 객체 타입(Object type)의 차이","slug":"programming/js-primitive-object","date":"2019-05-06T16:00:42.000Z","updated":"2020-02-03T07:47:26.920Z","comments":true,"path":"2019/05/07/programming/js-primitive-object/","link":"","permalink":"http://codeameba.github.io/2019/05/07/programming/js-primitive-object/","excerpt":"","text":"INDEX(링크 예정) Data type Literal Expression Primitive type vs Object type Function Definition Scope Lexical Scope 전역 변수의 문제점 var 키워드로 선언한 변수의 문제점 Constructor Function this DOM 브라우저 동작 Event Delegation Event Capturing vs Event Bubbling Class super Prototype Promise 동기식 처리 모델 vs 비동기식 처리 모델 [JavaScript Preview] 원시 타입(Primitive type)과 객체 타입(Object type)의 차이 자바스크립트의 데이터 타입자바스크립트의 데이터 타입은 크게 두 종류로 나눌 수 있다. 원시 타입(Primitive type)과 객체(Object)가 그것인데, 이 두 타입을 구분 짓는 가장 큰 특징으로는 값의 변경 가능 유무라고 할 수 있다. 원시 타입(Primitive type) String Number undefined null Boolean Symbol 객체(Object) Object 원시 타입과 객체의 차이점 원시 타입의 값은 변경이 불가능하다. 이것을 Immutable value라고 하며, 반면에 객체의 값은 가능하여 Mutable value라고 한다. 원시 타입의 값을 변수에 할당하면 변수는 실제 값이 할당된 메모리 주소를 가리키고 있다. 반면에 객체는 할당된 변수 값(객체 그대로 할당)의 메모리 주소를 별도의 메모리에 저장하여 객체를 참조(Reference)한다. 이를 참조 값이라 한다. 원시 타입의 값을 지닌 변수를 다른 변수에 할당하면 원본의 값이 복사되어 동일한 방식으로 할당되며 이를 Pass by value라고 한다. 반면에 객체를 값을 다른 변수에 할당하면 참조 값이 복사된다. 이를 Pass by reference라고 한다. Mutable / Immutable원시 타입의 값은 변경이 불가능하여 Immutable value라고 한다. 그런데 간혹 아래와 같은 예시를 통해 변경이 가능하다고 오해하는 경우가 있다(내가 그랬다). 12345var beer = 'stella';console.log(beer); // stellabeer = 'kirin';console.log(beer); // kirin 결론부터 말하자면, 이것은 값이 변경된 게 아니라, 재할당이 된 것이다. 다시 말해 기존의 메모리 공간에 할당되어 있던 값 자체가 변한 것이 아니라, 새로운 메모리 공간에 새로운 값이 할당 되었다는 말이다. 아래의 이미지를 참고하도록 하자. 그렇다면, 객체는 어떨까? 12345678910var beer = &#123; name: 'stella'&#125;;console.log(beer); // &#123;name: \"stella\"&#125;beer.name = 'kirin';console.log(beer); // &#123;name: \"kirin\"&#125;beer.taste = 'good';console.log(beer); // &#123;name: \"kirin\", taste: \"good\"&#125; 위와 같이 값이 변경될 뿐만 아니라 추가도 가능하다. 언뜻 보기에 원시 타입의 재할당과 크게 달라 보이지 않을지도 모르지만, 기존에 할당 되었던 메모리 공간 내에서 변경 및 추가가 이루어진다는 점에서 근본적으로 다르다고 볼 수 있다. 객체가 원시 타입보다 좋은 것인가?왠지 모르게 객체의 Mutable 특성이 눈에 띄어서 원시 타입보다 좋은 것이라는 인상이 있는데, 그렇다고 하기는 어렵다. 객체 타입의 이러한 특성은 양날의 검이기 때문이다. 값의 변경과 추가가 가능하다는 것은 오류가 발생할 여지가 있다는 점이기도 하다. 그럼에도 불구하고 객체를 사용하는 것은 메모리를 효율적으로 관리할 수 있으며 퍼포먼스가 뛰어나기 때문이다. 생각을 해보자. 위의 예시 코드는 짧기 때문에 원시 타입과의 차이가 그다지 없다. 하지만, 실제 서비스의 소스 코드처럼 수만줄에 이른다면, 객체의 프로퍼티(Property) 또한 상당히 많을 것이다. 그런 상황에서 매번 재할당을 한다는 것은 메모리에 가해지는 부담이 무척 클 것이다. 그리고, 원시 타입 값은 기본적으로 하나의 값만 갖는 만큼 객체에 비해 차지하는 메모리 공간이 훨씬 적다. 결론적으로 원시 타입이든 객체든 적재적소에 적절히 분배하여 사용하는 것이 이상적이라고 생각한다. 참고자료 poiemaweb.com 이미지 출처 poiemaweb.com unsplash.com","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://codeameba.github.io/categories/JavaScript/"}],"tags":[{"name":"일기","slug":"일기","permalink":"http://codeameba.github.io/tags/%EC%9D%BC%EA%B8%B0/"},{"name":"til","slug":"til","permalink":"http://codeameba.github.io/tags/til/"},{"name":"TIL","slug":"TIL","permalink":"http://codeameba.github.io/tags/TIL/"},{"name":"Today I Learned","slug":"Today-I-Learned","permalink":"http://codeameba.github.io/tags/Today-I-Learned/"},{"name":"오늘배운것들","slug":"오늘배운것들","permalink":"http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Javascript","slug":"Javascript","permalink":"http://codeameba.github.io/tags/Javascript/"},{"name":"패스트캠퍼스","slug":"패스트캠퍼스","permalink":"http://codeameba.github.io/tags/%ED%8C%A8%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%8D%BC%EC%8A%A4/"}]},{"title":"[JavaScript Preview] 반복문을 반복적으로 쓰는 것은 지양해야 한다","slug":"programming/js-repeat-statement","date":"2019-05-05T16:00:42.000Z","updated":"2020-02-03T07:47:26.920Z","comments":true,"path":"2019/05/06/programming/js-repeat-statement/","link":"","permalink":"http://codeameba.github.io/2019/05/06/programming/js-repeat-statement/","excerpt":"","text":"Instagram에서 이 게시물 보기 오늘_날씨_한_장_요약.jpg 🌱🌿🌲🌳🚶🏻‍♂️🌳🌲🌿🌱 . . #aprilgreenery #fubiz #somewheremagazine #inspirationcultmag #dreamermagazine #소니이미지갤러리 #sonyimagegallery #sonyalpha #a7m3 #sel55f18z #minimalzine #gominimalmag #moodygrams #lensculture #walkintheforest 정수영(Sooyoung Jeong)(@aprilgreenery)님의 공유 게시물님, 2019 5월 6 2:45오전 PDT [JavaScript Preview] 반복문 - for 문과 while 문 새롭게 알게 된 것반복문(Loop statement)반복문은 컴퓨터에게 반복적인 작업을 수행하도록 명령할 때 사용하는 제어문(Control flow statement)의 일종이다.주어진 조건식의 평가 결과가 참일 때 코드 블록을 실행하는 방법으로 작동하며, 조건식의 평가 결과가 거짓이 될 때까지 동일하게 실행된다. 자바스크립트 반복문의 종류와 구조자바스크립트에서 지원하는 반복문으로는 다음과 같이 다양한 종류가 있다. 하지만, 주로 쓰이는 것은 for 문과 while 문이다. for 문 1234// examplefor (var i = 0; i &lt; 2; i++) &#123; console.log(i);&#125; do…while 문 12345// exampledo &#123; i += 1; console.log(i);&#125; while (i &lt; 5); while 문 123456789101112// examplen = 0;x = 0;while (n &lt; 3) &#123; n++; x += n;&#125;// example 2while (true) &#123; console.log(\"Hello, world\");&#125; Label 문 12345// examplemarkLoop: // labelwhile (theMark == true) &#123; doSomething();&#125; break 문 : 반복문, switch문, 레이블 문 등에서 빠져나올 때 사용함. 123456789101112131415161718192021222324// example: for문for (i = 0; i &lt; a.length; i++) &#123; if (a[i] == theValue) &#123; break; &#125;&#125;// example: Breaking to a labelvar x = 0;var z = 0labelCancelLoops: while (true) &#123; console.log(\"Outer loops: \" + x); x += 1; z = 1; while (true) &#123; console.log(\"Inner loops: \" + z); z += 1; if (z === 10 &amp;&amp; x === 10) &#123; break labelCancelLoops; &#125; else if (z === 10) &#123; break; &#125; &#125;&#125; continue 문 : while, do-while, for, 레이블 문을 다시 시작할 때 사용함. 12345678910111213141516171819202122232425262728// example: while문i = 0;n = 0;while (i &lt; 5) &#123; i++; if (i == 3) &#123; continue; &#125; n += i;&#125;// example: labelcheckiandj: while (i &lt; 4) &#123; console.log(i); i += 1; checkj: while (j &gt; 4) &#123; console.log(j); j -= 1; if ((j % 2) == 0) &#123; continue checkj; &#125; console.log(j + \" is odd.\"); &#125; console.log(\"i = \" + i); console.log(\"j = \" + j); &#125; for…in 문 123456789// examplefunction dump_props(obj, obj_name) &#123; var result = \"\"; for (var i in obj) &#123; result += obj_name + \".\" + i + \" = \" + obj[i] + \"&lt;br&gt;\"; &#125; result += \"&lt;hr&gt;\"; return result;&#125; for…of 문 12345678910let arr = [3, 5, 7];arr.foo = \"hello\";for (let i in arr) &#123; console.log(i); // logs \"0\", \"1\", \"2\", \"foo\"&#125;for (let i of arr) &#123; console.log(i); // logs \"3\", \"5\", \"7\"&#125; for 문과 while 문for 문for 문은 조건식이 거짓으로 판별될 때까지 코드 블록을 반복 실행하며, 앞서 봤듯이 기본적인 구조는 다음과 같다. 1234// for 문의 기본 구조for (변수 선언문 또는 할당문; 조건식; 증감식) &#123; 조건식이 참인 경우 반복 실행될 문;&#125; for 문의 실행 순서를 통해 반복문을 보다 깊게 이해해보자. 변수 선언문이 가장 먼저 실행된다. 이것은 반복되지 않고 단 한 번만 실행된다. 변수 선언 이후, 조건식으로 이동한다. 현재 i는 0이므로 true이다. 이어서 증감문으로 넘어갈 것 같지만, 그렇지 않다. 조건식의 평가 결과가 true이므로 코드 블록으로 이동하여 실행된다. 코드 블록 실행 종료 후, 마침내 증감문으로 이동하여 i는 1이 된다. 증감식 종료 후 다시 조건식으로 이동한다. i &lt; 2라는 조건식에 여전히 부합하므로 true이다. 조건식 결과가 true이기 때문에 다시 코드 블록으로 이동 및 실행된다. 코드 블록 종료 후 다시 증감식으로 이동하여 i는 2가 된다. 증감식 종료 후 조건식으로 이동하며, i가 2가 되었으므로 조건식을 만족 시키지 못하여 false가 된다. 그리고 for 문은 종료된다. while 문while 문은 주어진 조건식의 평가 결과가 참일 때, 코드 블록을 반복하여 실행하며, 조건식의 평가 결과가 거짓이 될 때 실행이 종료된다. 만약, 조건식의 평가 결과가 불리언 값이 아니라면, 불리언 값으로 강제 변환한다. 1234567var count = 0;// count가 3보다 작을 떄까지 코드 블록이 반복된다.while (count &lt; 3) &#123; console.log(count); count++;&#125; 참고자료 poiemaweb.com 루프와 반복 - JavaScript | MDN 이미지 출처 poiemaweb.com","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://codeameba.github.io/categories/JavaScript/"}],"tags":[{"name":"일기","slug":"일기","permalink":"http://codeameba.github.io/tags/%EC%9D%BC%EA%B8%B0/"},{"name":"til","slug":"til","permalink":"http://codeameba.github.io/tags/til/"},{"name":"TIL","slug":"TIL","permalink":"http://codeameba.github.io/tags/TIL/"},{"name":"Today I Learned","slug":"Today-I-Learned","permalink":"http://codeameba.github.io/tags/Today-I-Learned/"},{"name":"오늘배운것들","slug":"오늘배운것들","permalink":"http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Javascript","slug":"Javascript","permalink":"http://codeameba.github.io/tags/Javascript/"},{"name":"패스트캠퍼스","slug":"패스트캠퍼스","permalink":"http://codeameba.github.io/tags/%ED%8C%A8%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%8D%BC%EC%8A%A4/"}]},{"title":"유용한 크롬 확장 프로그램(Chrome Extension) 추천","slug":"programming/tip-chrome-extenstion","date":"2019-05-04T16:00:42.000Z","updated":"2020-02-20T21:02:06.366Z","comments":true,"path":"2019/05/05/programming/tip-chrome-extenstion/","link":"","permalink":"http://codeameba.github.io/2019/05/05/programming/tip-chrome-extenstion/","excerpt":"","text":"Instagram에서 이 게시물 보기 ✨👨‍💻☕️ . . #fubiz #somewheremagazine #inspirationcultmag #dreamermagazine #소니이미지갤러리 #sonyimagegallery #sonyalpha #a7m3 #sel1635z #minimalzine #gominimalmag #moodygrams #lensculture #peoplewhocode #seoul_korea #codinglife 정수영(Sooyoung Jeong)(@aprilgreenery)님의 공유 게시물님, 2019 5월 4 10:02오후 PDT 크롬 확장 프로그램(Chrome Extension)구글 크롬 확장 프로그램(Google Chrome Extension)은 크롬 브라우저를 기반으로 동작하는 애플리케이션이다. 따라서 HTML, CSS, JavaScript로 제작되며, 구글 계정을 갖고 있다면 누구나 크롬 웹 스토어를 통해 설치할 수 있다. Chrome 웹 스토어 모두에게 유용한 확장 프로그램1. Momentum 모멘텀(Momentum)은 구글의 새창을 기반으로 하는 싱글페이지 애플리케이션이다. 사용자 위치 기반의 현재 시간, 날씨 등을 제공하고, 투두리스트로써의 기능도 갖고 있다. 새창을 열 때마다 새롭게 바뀌는 배경 이미지를 보는 재미도 있다. Momentum - Chrome 웹 스토어 2. Todoist 기본에 충실한 투두리스트 애플리케이션이다. 미니멀한 디자인에 스마트폰(애플리케이션 별도 설치 시)과 연동이 가능하다는 점이 유용하다. Todoist: 할일 목록 및 작업 관리자 - Chrome 웹 스토어 3. Google Arts &amp; Culture 나로 하여금 모멘텀을 삭제하게 만든 일등공신이다. 새창을 열 때마다 동서고금을 막론한 세계의 명화들을 감상할 수 있다. 작품명과 제목은 물론이고 해당 작품을 소장하고 있는 미술관 정보까지 알 수 있다. 나처럼 이렇게나마 비루한 교양 수준을 키우고 싶은 사람들에게 추천한다. Google Arts &amp; Culture - Chrome 웹 스토어 4. Google Dictionary 구글이 만든 구글 사전이다. 영영, 한영, 영한 모두 지원한다. 물론, 번역 애플리케이션도 웹 스토어에 존재하지만, 이건 내 마지막 자존심이다. 그리고, 종종(?) 만나게 되는 생소한 영단어를 더블 클릭 하는 것만으로 빠르게 확인할 수 있기 때문에 빠르게 컨닝하고 시치미 떼기에 좋다. Google Dictionary (by Google) - Chrome 웹 스토어 개발자를 꿈꾸며 공부하는 이들에게 특히 유용한 확장 프로그램1. Blue Button 클릭 한 번으로 해당 웹사이트의 HTML, CSS, JS 정보를 모두 알 수 있으며, 이미지 정보까지 알 수 있다. 물론, 개발자도구로도 모두 알 수 있는 내용이긴 하지만, Blue Button은 친절하게 정리해서 시각화까지 해준다. Blue Button | the webpage X-ray - Chrome 웹 스토어 2. ColorZilla ColorZilla의 존재를 모를 때에는 웹에서 발견한 색상의 값을 알아내기 위해 캡쳐를 하고, 포토샵으로 불러내 스포이드 툴로 찍어봐야 했다. 하지만 ColorZilla와 함께라면 이제 그런 수고는 안 해도 된다. ColorZilla - Chrome 웹 스토어 3. headingsMap 웹 접근성을 고려한 웹 페이지 설계에 관심이 있다면, headingsMap의 설치를 추천한다. 접속 중인 웹 페이지의 모든 헤딩태그들을 선형구조로 한눈에 파악할 수가 있다. 평소 주의 깊게 보던 웹 사이트가 있다면 headingsMap으로 확인해보자. headingsMap - Chrome 웹 스토어 4. OpenWAX OpenWAX 역시 웹 접근성 공부에 특히 유용한 확장 프로그램이다. 제목 뿐만 아니라 대체 텍스트 사용 현황부터 적절한 명도 대비, 링크 텍스트까지 접속 중인 웹 사이트의 웹 접근성 수준을 확인할 수가 있다. 이를 통해 웹 접근성이 고려되지 않은 웹 페이지를 발견하고 “나는 이러지 말아야지”하며 반면교사 삼도록 하자. OpenWAX - Chrome 웹 스토어 5. Page Ruler 웹 페이지 요소들의 사이즈와 태그를 확인할 수 있는 확장 프로그램이다. 해당 위치에 마우스 포인터를 올리는 것만으로 쉽게 확인이 가능하며, 부모 태그와 자식 태그까지 알 수 있다. Page Ruler - Chrome 웹 스토어 6. Web Developer 정말 유저 타겟팅에 충실한 이름이 아닐 수 없다. 확장 프로그램 이름이 Web Developer다. 무슨 말이 더 필요할까. Web Developer - Chrome 웹 스토어 7. WhatFont 이름 그대로 웹에서 만나는 폰트들을 손쉽게 확인할 수 있게 해주는 확장 프로그램이다. WhatFont - Chrome 웹 스토어 8. WhatRuns 접속 중인 웹 사이트를 구성하는 라이브러리, 프레임워크, API 등을 확인할 수 있는 확장 프로그램이다. 평소 눈여겨 보던 사이트는 무엇으로 만들어졌나 확인해보자. WhatRuns - Chrome 웹 스토어 참고 크롬 웹 스토어 이미지 출처 크롬 웹 스토어","categories":[{"name":"tip","slug":"tip","permalink":"http://codeameba.github.io/categories/tip/"}],"tags":[{"name":"확장프로그램","slug":"확장프로그램","permalink":"http://codeameba.github.io/tags/%ED%99%95%EC%9E%A5%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8/"},{"name":"크롬","slug":"크롬","permalink":"http://codeameba.github.io/tags/%ED%81%AC%EB%A1%AC/"},{"name":"chrome","slug":"chrome","permalink":"http://codeameba.github.io/tags/chrome/"},{"name":"extension","slug":"extension","permalink":"http://codeameba.github.io/tags/extension/"}]},{"title":"JavaScript TIL(2019.05.03)","slug":"programming/js-til-05","date":"2019-05-02T16:00:42.000Z","updated":"2020-02-03T07:47:26.920Z","comments":true,"path":"2019/05/03/programming/js-til-05/","link":"","permalink":"http://codeameba.github.io/2019/05/03/programming/js-til-05/","excerpt":"","text":"자바스크립트 3일차(190503) 자바스크립트는 동적 타입 언어변수를 선언할 때 타입이 정해지는데, 정적 타입 언어는 선언 이후 타입이 변할 수 없고, 동적 타입 언어는 선언 후에도 타입이 변할 수 있다. 타입이 있는 이유는타입에 따라 값이 할당되는 메모리의 크기가 다르기 때문에, 선언과 동시에 해당 값이 들어갈 수 있는 충분한 메모리를 확보하기 위함. TypeScript동적 타입 언어인 자바스크립트를 동적 타입 언어처럼 사용할 수 있게 해줌. REPL(Read Eval Print Loop)터미널에서 실행된 Node 환경 변수선언새로운 변수 식별자를 자바스크립트 엔진에 등록 하는 것, 자바스크립트 엔진은 해당 변수의 값이 할당될 메모리 공간을 초기화 하고 undefined를 넣는다. Undefined원시(Primitive) 타입이면서 값이다. var x = 10;기독성을 위해 선언문과 할당문을 한줄에 쓴 것이다.컴퓨터는 다음과 같이 나누어서 이해한다. 12var x; &#x2F;&#x2F; 선언문x &#x3D; 10; &#x2F;&#x2F; 할당문 선언문이 실행되는 시점은Runtime 이전 호이스팅(Hoisting)을 배우는 이유는되도록 지양하는 게 좋기 때문에호이스팅은 두 종류가 있음 변수 호이스팅 함수 호이스팅 상수(Constant)상수의 반대는 변수상수는 재할당이 불가엄밀히 따지면 상수도 변수의 한 종류지만, 재할당이 불가한 변수 let호이스팅을 하지만, 안 하는 척 한다. 스코프(Scope)와 변수외부의 변수를 스코프 내부에 재할당 가능하다.다른 폴더에 동일한 이름의 파일을 만드는 이미지로 이해하면 쉬움. 네이밍 컨벤션변수명, 함수명으로 가장 많이 쓰이는 것은 카멜케이스(camelCase)생성자함수, 클래스의 경우는 파스칼케이스(PascalCase) 코딩 초심자는퍼포먼스보다는 코드 가독성에 신경 써라 데이터 타입(Data type)할당 되는 값에 따라 타입이 정해지며, 타입에 따라 사용할 메모리의 크기가 정해진다. 값(Value)더 이상 평가할 수 없는 하나의 표현식. 표현식(Expression)하나의 값으로 평가할 수 있는 문 리터럴(Literal)값을 만드는 가장 간단한 방식. 값이 평가되기 이전의 상태. 객체와 배열의 차이배열은 순서가 있다.객체는 키(key)와 값(value)이 있다. 자바스크립트는 할당문도 표현식sum = 10; -&gt; expression 숫자 타입의 특별한 3가지 값 Infinity : 양의 무한대 -Infinity : 음의 무한대 NaN : 산술 연산 불가(not-a-number)123console.log(10 &#x2F; 0); &#x2F;&#x2F; Infinityconsole.log(10 &#x2F; -0); &#x2F;&#x2F; -Infinityconsole.log(1 * &#39;String&#39;); &#x2F;&#x2F; NaN 문자열에 따옴표를 쓰는 이유 식별자와 구분하기 위해 문자열의 시작과 끝을 알 수 있도록 백틱의 유용함 공백을 포함한 문자열을 여러 줄에 걸쳐 작성할 수 있다. 123456const template &#x3D; &#96;&lt;ul class&#x3D;&quot;nav-items&quot;&gt; &lt;li&gt;&lt;a href&#x3D;&quot;#home&quot;&gt;Home&lt;&#x2F;a&gt;&lt;&#x2F;li&gt; &lt;li&gt;&lt;a href&#x3D;&quot;#news&quot;&gt;News&lt;&#x2F;a&gt;&lt;&#x2F;li&gt; &lt;li&gt;&lt;a href&#x3D;&quot;#contact&quot;&gt;Contact&lt;&#x2F;a&gt;&lt;&#x2F;li&gt; &lt;li&gt;&lt;a href&#x3D;&quot;#about&quot;&gt;About&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&lt;&#x2F;ul&gt;&#96;; 문자열 연산자를 쓰지 않아도 간단히 문자열을 삽입할 수 있다. 이것을 문자열 인터폴레이션(String Interpolation)이라고 한다. 123456var first &#x3D; &#39;Soo-young&#39;;var last &#x3D; &#39;Jeong&#39;;&#x2F;&#x2F; ES6: String Interpolationconsole.log(&#96;My name is $&#123;first&#125; $&#123;last&#125;.&#96;);&#x2F;&#x2F; My name is Soo-young Jeong. ${표현식} 을 활용하면 표현식의 평가 결과를 문자열로 강제 타입 변환해준다. 1console.log(&#96;1 + 1 &#x3D; $&#123;1 + 1&#125;&#96;); &#x2F;&#x2F; 1 + 1 &#x3D; 2 null변수에 값이 없다는 것을 의도적으로 명시할 때 사용함. 자바스크립트에서 지켜야 할 것 변수의 사용을 최대한 줄인다. 변수 갯수와 오류 발생 확률은 비례함. 전역 변수는 악이다. 프로그램의 생명주기를 짧게 한다. 변수보다는 상수를 사용해 값의 변경을 억제한다. 변수명은 변수의 존재 이유를 알 수 있도록 짓는다. 문과 표현식을 구별하는 방법 값을 평가할 수 있는 문 -&gt; 표현식인 문 값은 평가할 수 있지만, 명령을 수행하지는 않음 -&gt; 표현식 값은 평가할 수 없지만, 명령을 수행함 -&gt; 문 과제(0503)일주일 동안 배운 것들 복습","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://codeameba.github.io/categories/JavaScript/"}],"tags":[{"name":"일기","slug":"일기","permalink":"http://codeameba.github.io/tags/%EC%9D%BC%EA%B8%B0/"},{"name":"til","slug":"til","permalink":"http://codeameba.github.io/tags/til/"},{"name":"TIL","slug":"TIL","permalink":"http://codeameba.github.io/tags/TIL/"},{"name":"Today I Learned","slug":"Today-I-Learned","permalink":"http://codeameba.github.io/tags/Today-I-Learned/"},{"name":"오늘배운것들","slug":"오늘배운것들","permalink":"http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Javascript","slug":"Javascript","permalink":"http://codeameba.github.io/tags/Javascript/"},{"name":"패스트캠퍼스","slug":"패스트캠퍼스","permalink":"http://codeameba.github.io/tags/%ED%8C%A8%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%8D%BC%EC%8A%A4/"}]},{"title":"[JavaScript Preview] 조건문의 조건","slug":"programming/js-boolean-statement","date":"2019-05-01T16:00:42.000Z","updated":"2020-02-03T07:47:26.902Z","comments":true,"path":"2019/05/02/programming/js-boolean-statement/","link":"","permalink":"http://codeameba.github.io/2019/05/02/programming/js-boolean-statement/","excerpt":"","text":"Instagram에서 이 게시물 보기 성수동, 2019 성수는 고양이도 힙하네 . . #fubiz #somewheremagazine #inspirationcultmag #dreamermagazine #소니이미지갤러리 #sonyimagegallery #sonyalpha #a7m3 #sel1635z #streetphotography #life_is_street #ourstreets #minimalzine #gominimalmag #moodygrams #streetleaks #lensculture #springvibe #seoul_korea #catsofstreets 정수영(Sooyoung Jeong)(@aprilgreenery)님의 공유 게시물님, 2019 5월 1 10:54오후 PDT 1. 제어문(Control flow statement)코드는 일반적으로 순차적으로 실행되지만, 제어문을 활용하면 인위적으로 순서를 제어할 수 있다. 사용하기에 따라 무척 편리한 기능이지만, 무분별한 남용은 코드의 가독성을 저하시키고 오류 발생의 원인이 되기도 한다. 자바스크립트 제어문의 종류 조건문 if/else 문, switch문, try/catch/finally문 조건에 따라 처리를 분기 반복문 while문, do/while문, for문, for/in문, for/of문 조건을 만족하면 처리를 반복 실행 점프문 break문, continue문, return문, throw문 프로그램의 다른 위치로 이동 참고 모던 자바스크립트 입문(ISBN 9791160504439) 2. 블록문(Block statement / Compound statement) 프로그램 코드에서블록(block)이란 마치 한 문단처럼 보이는, 코드의 한 부분을 뜻하며, 중괄호로 묶여 있는 경우가 많다. 보통 1개 이상의 명령어를 가지고 있으나, 주석으로 이루어진 블록이나, 아무 내용도 없는 빈 블록도 가능하다. 자바스크립트는 블록문을 하나의 실행 단위로 취급하며, 블록문 단독으로 사용할 수도 있으나 보통 제어문이나 함수 선언문 등으로 사용한다. 블록문 끝에는 세미콜론을 붙이지 않는다. 참고 블록 (프로그래밍) - 위키백과, 우리 모두의 백과사전 poiemaweb.com 3. 조건문자바스크립트의 조건문은 if/else문과 switch문이 있다. if/else문논리적 참(true), 거짓(false)에 따라 실행할 코드 블록을 결정한다. 평가 결과가 true나 false로 나오지 않는 조건식은 결과값을 불리언 값(true/false)으로 강제 변환한다. if와 else는 두 번 이상 사용할 수 없지만 else if는 여러 번 사용이 가능하다. 일반적인 형태는 다음과 같다. 1234567891011121314151617181920212223242526var menuNum = 2;var menu;// if문if (menuNum &gt; 1) &#123; menu = '짬뽕';&#125;console.log(menu); // 짬뽕// if/else문if (menuNum &gt; 1) &#123; menu = '짬뽕';&#125; else &#123; menu = '짜장';&#125;console.log(menu); // 짬뽕// if/else if문if (menuNum &gt; 1) &#123; menu = '짬뽕';&#125; else if (menuNum &lt; 1) &#123; menu = '탕수육';&#125; else &#123; menu = '짜장';&#125;console.log(menu); // 짬뽕 삼항 조건 연산자If/else문은 삼항 연산자로 표현할 수도 있다. 이를 삼항 조건 연산자라고 하며, 표현식을 만든다. 이 표현식은 값처럼 사용할 수도 있다. 반면에 if/else문은 표현식이 아닌 문이며, 값처럼 사용할 수 없다. 위의 예제를 삼항 조건 연산자로 표현하면 아래와 같다. 123456789// if/else문 -&gt; 삼항 조건 연산자var menuNum = 2;var menu = menuNum &gt; 1 ? '짬뽕' : '짜장';console.log(menu); // 짬뽕// if/else if -&gt; 삼항 조건 연산자var menuNum = 2;var menu = menuNum ? (menuNum &gt; 1 ? '짬뽕' : '탕수육') : '짜장';console.log(menu); // 짬뽕 switch문switch문은 true와 false로만 평가되는 if/else와는 다른 조건문이다.switch문은 주어진 표현식을 평가하여 그 값과 일치하는 표현식을 갖고 있는 case문이 등장할 때까지 순차적으로 실행된다. 이때, 일치하는 case가 없다면 default 문이 실행되는데 default문이 필수는 아니다. 그리고, 일치하는 case가 있더라도 break문이 누락된 경우에는 그냥 지나치게 된다. 이러한 것을 폴스루(fall through)라고 한다. 일반적인 switch문은 아래와 같은 형태를 갖고 있다. 123456789101112131415161718192021var temperature = 20;var feeling;switch (temperature) &#123; case 10: feeling = 'cold'; break; case 15: feeling = 'cool'; break; case 20: feeling = 'warm'; break; case 25: feeling = 'hot'; break; default: feeling = 'soso';&#125;console.log(feeling); // warm 의도적으로 break를 생략하여 폴스루(fall through)를 이용하는 경우도 있는데, 추후 알아보도록 하겠다.그리고, default는, switch 블록 내에서 어느 위치에든 올 수 있지만, 블록 중간에 있으면 가독성이 좋지 않으므로 되도록 끝에 배치하도록 한다. 참고 progammers poiemaweb.com 모던 자바스크립트 입문(ISBN 9791160504439)","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://codeameba.github.io/categories/JavaScript/"}],"tags":[{"name":"일기","slug":"일기","permalink":"http://codeameba.github.io/tags/%EC%9D%BC%EA%B8%B0/"},{"name":"til","slug":"til","permalink":"http://codeameba.github.io/tags/til/"},{"name":"TIL","slug":"TIL","permalink":"http://codeameba.github.io/tags/TIL/"},{"name":"Today I Learned","slug":"Today-I-Learned","permalink":"http://codeameba.github.io/tags/Today-I-Learned/"},{"name":"오늘배운것들","slug":"오늘배운것들","permalink":"http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Javascript","slug":"Javascript","permalink":"http://codeameba.github.io/tags/Javascript/"},{"name":"패스트캠퍼스","slug":"패스트캠퍼스","permalink":"http://codeameba.github.io/tags/%ED%8C%A8%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%8D%BC%EC%8A%A4/"}]},{"title":"JavaScript TIL - 기초용어(2019.05.01)","slug":"programming/js-til-03","date":"2019-04-30T16:00:42.000Z","updated":"2020-02-03T07:47:26.920Z","comments":true,"path":"2019/05/01/programming/js-til-03/","link":"","permalink":"http://codeameba.github.io/2019/05/01/programming/js-til-03/","excerpt":"","text":"자바스크립트 2일차(190501) ES는 교집합클라이언트 사이드, 서버 사이드 혹은 모바일에서 자바스크립트를 사용할 때 다른 점은 각각의 API일 뿐, ES는 모두 동일하다. 따라서 ES는 가장 기본이다. Node.js는, 언어가 아닌 실행환경(Runtime Environment)10.12.6 버전의 경우 각 자리의 의미[메이저 패치, 브레이크체인지].[마이너 패치].[버그패치] Parsing컴퓨터가 이해할 수 있는 언어로 해석하는 단계 컴퓨터가 이해했다는 것은,해당 파일을 해석해서 메모리에 저장 완료했다는 것 Metadata사람을 대상으로 한 정보가 아니라 컴퓨터를 대상으로 한 정보 스코프 체인(Scope Chain) **추후 내용 추가 예정** 룰셋(Rule set)123.selector &#123; color: red;&#125; 이것을 룰셋이라 한다. CSSOM(CSS Object Model)HTML의 DOM Tree처럼 CSS 문서 내의 selector를 갖고 트리구조를 만든다, 컴포넌트(Component)CBD(컴포넌트 기반 개발 방식)이 요즘 대세HTML/CSS/JS를 한 세트로 제작 but, 유지보수 차원에서는 파일이 분리되는 편이 낫다. HTTP 버전 별 차이 HTTP 1.1 버전에서는 파일의 갯수와 요청 횟수가 비례했으나, HTTP 2.0 버전부터는 요청 한 번에 필요한 파일을 일괄적으로 전달하는 방식으로 바뀌게 되었다. 참고 HTTP/2 for a Faster Web | Cascading Media Syntax구문보다는 문법으로 이해하는 게 쉽다. 변수선언문var a = 0;[키워드] [식별자] [할당연산자] [값] [세미콜론]하나 하나가 토큰 프로그램의 실행 과정참고 컴퓨터의 구조 및 프로그램 실행 과정 인터프리터(Interpreter)와 컴파일러(Compiler)인터프리터 언어와 컴파일 언어의 가장 큰 차이점을 컴파일 시점이다. 인터프리터 언어는 런타임과 동시에 컴파일이 진행되며, 컴파일 언어는 런타임 이전에 컴파일을 완료하여 실행파일을 생성한다. 표현식값으로 평가될 수 있는 문 상대경로별도 포스팅 예정 1byte가 8bit인 이유는8bit에 ASCII 코드를 전부 담을 수 있기 때문 평가(Evaluation)프로그래밍에서 평가는, “값을 만들어낸다”는 의미로 자주 쓰임.ex: 1+2 실행(Execution)ex: 123if(x &gt; 3) &#123; &#x2F;&#x2F;...&#125; 식별자(Identifier)임의로 정할 수 있는 이름(변수명, 함수명, 클래스명 등)의 통칭하며, 선언(Declaration)을 통하여 자바스크립트 엔진에게 존재를 알릴 수 있다. 선언(Declaration)과 정의(Define)선언은 일방적으로 식별자의 존재를 알리는 것.정의는 선언된 식별자와 그에 할당값을 자바스크립트가 확인 완료한 것(식별자의 존재가 상호 합의 됨)","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://codeameba.github.io/categories/JavaScript/"}],"tags":[{"name":"일기","slug":"일기","permalink":"http://codeameba.github.io/tags/%EC%9D%BC%EA%B8%B0/"},{"name":"til","slug":"til","permalink":"http://codeameba.github.io/tags/til/"},{"name":"TIL","slug":"TIL","permalink":"http://codeameba.github.io/tags/TIL/"},{"name":"Today I Learned","slug":"Today-I-Learned","permalink":"http://codeameba.github.io/tags/Today-I-Learned/"},{"name":"오늘배운것들","slug":"오늘배운것들","permalink":"http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Javascript","slug":"Javascript","permalink":"http://codeameba.github.io/tags/Javascript/"},{"name":"패스트캠퍼스","slug":"패스트캠퍼스","permalink":"http://codeameba.github.io/tags/%ED%8C%A8%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%8D%BC%EC%8A%A4/"}]},{"title":"[JavaScript Preview] 기초용어 정리","slug":"programming/js-til-02","date":"2019-04-29T16:00:42.000Z","updated":"2020-02-03T07:47:26.920Z","comments":true,"path":"2019/04/30/programming/js-til-02/","link":"","permalink":"http://codeameba.github.io/2019/04/30/programming/js-til-02/","excerpt":"","text":"Instagram에서 이 게시물 보기 👨‍💻☕️🍰 . . #fubiz #somewheremagazine #inspirationcultmag #dreamermagazine #소니이미지갤러리 #sonyimagegallery #sonyalpha #a7m3 #sel55f18z #minimalzine #gominimalmag #moodygrams #lensculture #peoplewhocode #seoul_korea #codinglife #hevitz 정수영(Sooyoung Jeong)(@aprilgreenery)님의 공유 게시물님, 2019 4월 27 12:44오전 PDT JavaScript Preview 01(19.04.30) 궁금한 것 아래의 내용에서 평가라는 것은 무엇을 의미하나요?1var score &#x3D; 100; 우변의 100은 리터럴 표기법으로 소스코드 안에서 직접 만들어 낸 리터럴이다. 이 리터럴은 더 이상 평가할 수 없고 변수에 할당할 수 있는 대상이므로 리터럴인 동시에 값이다. 100은 리터럴이자 값이므로 변수에 할당할 수 있다. 아래의 내용과 관련해서 값이 아닌 리터럴은 무엇인가요? 리터럴이 값의 최소 단위이며, 리터럴 그 자체로 값이 될 수 있지만, 모든 값이 리터럴인 것은 아니다. 문과 표현식을 확실하게 구분할 수 있는 결정적 차이점이 무엇인가요? 삼항 조건 연산자와 if…else문은, 기능적으로 동일한 표현식과 문이라고 생각해도 되나요? 새롭게 알게 된 것1. JavaScript != ES6ES(ECMAScript)는 국제 표준화 기구 ‘ECMA international’의 기술 규격으로 정의한 표준화된 스크립트 프로그래밍 언어이다. 이는 자바스크립트의 핵심기능을 표준화하여 자칫 파편화 되어 브라우저에 따라 다르게 적용될 수 있는 문제를 방지하는 것에 목적이 있다. 참고 ECMA 자바스크립트 언어 자료 - JavaScript | MDN 2. Node.js리눅스 재단에서 개발한 Node.js는, 크롬에 탑재된 V8 자바스크립트 엔진을 기반으로 한 자바스크립트의 개발 환경이다. 이를 통해 자바스크립트는 브라우저의 틀을 벗어나 서버 사이드 애플리케이션 개발까지 가능하게 되었다. 참고 ECMAScript 2015(ES6)와 그 다음 | Node.js 3. Parsing / Parser수차례 들어왔으나 정확한 뜻을 모르고 쓰던 용어였는데, 이번 기회에 정리 해둔다. Parsing 컴퓨터 과학에서 파싱(Parsing)은 일련의 문자열을 의미있는 토큰(Token)으로 분해하고 이들로 이루어진 파스 트리(Parse Tree)를 만드는 과정을 말한다. 파싱의 종류는 크게 두 가지가 있으며, 하향식 구문 분석(top-down parsing)과 상향식 구문 분석(bottom-up parsing)으로 나눈다. Parser 파서(Parser)는 인터프리터(Interpreter)나 컴파일러(Compiler)의 구성 요소 중 하나로, 입력 토큰에 담긴 자료구조를 빌드하고 문법을 검사한다. 파서는 일련의 입력 문자로부터 토큰을 만들기 위해 별도의 낱말분석기를 이용하기도 한다. 보통 수작업으로 프로그래밍되며, 일부 프로그래밍 언어에서는 도구에 의해 (반)자동적으로 만들어지기도 한다. 참고 구문 분석 - 위키백과, 우리 모두의 백과사전 자바스크립트는 어떻게 작동하는가: V8 엔진의 내부 + 최적화된 코드를 작성을 위한 다섯 가지 팁 4. Synchronous &amp; Asynchronous(동기 &amp; 비동기)공부를 하다 보면, 심심치 않게 등장하는 용어 중 하나가 동기/비동기이다. 자바스크립트는 싱글쓰레드(Single Thread) 기반이라 동기 방식의 프로세스 처리가 기본이라고 한다.쓰레드의 경우 위키에서는 이렇게 설명하고 있다. 어떠한 프로그램 내에서, 특히 프로세스 내에서 실행되는 흐름의 단위. 일반적으로 하나의 프로그램은 하나의 쓰레드를 갖지만, 프로그램 환경에 따라 둘 이상의 쓰레드를 동시에 실행할 수 있다. 이러한 것을 멀티쓰레드(Multi Thread)라고 한다. 이와 같은 내용들을 참고하여 내가 이해한대로 풀어보자면, 우선, 쓰레드는 작업을 수행하는 작업공간에 비유할 수 있겠다. 그리고, 이 작업장으로 특정 임무를 수행하는 작업자가 한 명씩 들어와 작업을 수행한다. 본인의 임무를 마치거나 중단한 작업자는 퇴장하고, 이어서 다른 작업자가 들어와서 작업을 한다. 이것이 싱글쓰레드를 기반으로 하는 동기 방식(Synchronous)이다. 동일한 맥락으로, 이러한 작업공간이 여럿 있으면 멀티쓰레드이며, 동시에 여러 작업자가 작업을 진행하면 비동기 방식(Asynchronous)이다. 참고 쓰레드 - WIKIPEDIA 5. 변수(Variable)는,하나의 값(Value)을 저장할 수 있는 메모리 공간에 붙인 이름 또는 메모리 공간 자체를 말한다. 값 자체를 메모리에 저장하는 것도 가능하지만, 한 번 사용한 후에 다시 해당 메모리 주소에 접근하여 값을 불러올 방법이 없다. 따라서, 해당 메모리 공간에 변수라는 이름을 붙인다. 6. 블록 레벨 스코프(Block-level scope)ES6 이전까지 자바스크립트의 변수 선언 방법으로는 var 하나밖에 없었지만, ES6부터 let과 const가 추가됐다. 그 이유로는 var가 블록 레벨 스코프(Block-level scope)를 지원하지 않는다는 점이 가장 컸다. 대부분의 프로그래밍 언어가 블록 레벨 스코프를 따르는 것과 달리 자바스크립트는 함수 레벨 스코프(Function-level scope)를 따랐던 이유이기도 하다. 블록 레벨 스코프(Block-level scope): 모든 코드 블록(함수, if문, for문, while문, try/catch문 등) 내에서 선언된 변수는 코드 블록 내에서만 유효하며 코드 블록 외부에서는 참조(접근, 호출)할 수 없다. 따라서, 코드 블록 내부에서 선언한 변수는 지역 변수이다. 함수 레벨 스코프(Function-level scope): 함수 내에서 선언된 변수는 함수 내에서만 유효하며 함수 외부에서는 참조할 수 없다. 즉, 함수 내부에서 선언한 변수는 지역 변수이며, 함수 외부에서 선언한 변수는 모두 전역 변수이다. 참고 let, const | PoiemaWeb 7. undefinedundefined는 자바스크립트가 제공하는 원시 타입의 값(Primitive value)이다. 8. 호이스팅(Hoisting)12console.log(codeAmeba);var codeAmeba; 위와 같은 순서를 지닌 코드가 있을 때, 위에서부터 한 줄씩 해석하는 인터프리터 언어인 자바스크립트라면, ReferenceError가 발생할 것이라고 예상되는데, 막상 실행해보면 undefined가 출력된다. 이는, 자바스크립트가 실행될 때 소스 코드를 전체적으로 훑어 보고 변수 선언문을 우선적으로 메모리에 저장하기 때문이다. 이러한 것을 호이스팅이라고 한다. 참고 Hoisting - 용어 사전 | MDN TOAST Meetup - 자바스크립트의 스코프와 클로저 9. 변수와 값의 저장 시점 차이12console.log(codeAmeba);var codeAmeba &#x3D; &#39;Jeong Sooyoung&#39;; 위와 같은 코드가 있을 때, 호이스팅만 생각한다면 ‘Jeong Sooyoung’이 출력될 것 같지만, undefined가 출력된다. 이는, 변수(Variable)와 (Value)이 메모리에 저장되는 시점이 다르기 때문이다. 변수 선언과 값 할당을 한줄에 했더라도 변수만 호이스팅이 되고, 값은 순차적으로 실행된다. 123console.log(codeAmeba);var codeAmeba &#x3D; &#39;Jeong Sooyoung&#39;;console.log(codeAmeba); 따라서 위와 같이 해보면, 변수에 값이 제대로 들어간 것을 확인할 수 있다. 10. 자료형(Data Type)ECMAScript에서는 자바스크립트의 자료형을 다음과 같이 7개로 구분하고 있다.기본 자료형(Primitive) Boolean: 논리적 참과 거짓 Null: 값이 없음을 의도적으로 명시할 때 사용 Undefined: 선언은 되었지만 값이 할당되지 않은 변수 Number: 숫자(정수, 실수) String: 문자열 Symbol(ES6에서 추가) 그리고, 별도로 구분하는 객체(Object): 객체, 함수, 배열 등 참고 MDN 11. 자료형을 구분해야 하는 이유 값을 저장할 때 필요한 메모리 공간의 크기를 결정하기 위해 값을 참조할 때 한번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해 메모리에서 읽어 들인 2진수를 어떻게 해석할 지 결정하기 위해(ex: 2진수 01000001은 10진수로 65이기도 하고, 동시에 문자 A가 되기도 한다.) 참고 poiemaweb.com 12. 리터럴(Literal)소스코드 안에서 직접 만들어 낸 고정된 값 자체이며, 리터럴 표기법(Literal notation)으로 생성한다. 내용추가: 값이 평가되기 이전의 상태로 이해하면 쉽다. 13. Garbage Collection메모리 관리 기법 중의 하나로, 프로그램이 동적으로 할당했던 메모리 영역 중에서. 필요없게 된 영역을 해제하는 기능이다. 참고 쓰레기 수집 (컴퓨터 과학) - 위키백과, 우리 모두의 백과사전 14. SymbolES6에서 새롭게 추가된 일곱 번째 데이터 타입으로 변경이 불가능한 원시(Primitive) 타입의 값이다. 주로 이름의 충돌 위험이 없는 객체의 유일한 프로퍼티 키(Property key)를 만들기 위해 사용하며, 함수를 호출해 생성한다. 참고 poiemaweb.com Symbol - JavaScript | MDN 15. 동적 타입 언어, 정적 타입 언어 정적 타입 언어: 변수의 데이터 타입을 사전에 선언해야 하며, 이후 타입을 변경할 수 없다. 대표적으로 C, C++, Java, Kotlin, Go, Haskell, Rust, Scala 등이 있다. 유연성은 떨어지나 그만큼 오류발생의 여지가 적기 때문에 신뢰성이 높다. 동적 타입 언어: 사전에 데이터 타입을 선언했더라도 변경이 가능하다. 자바스크립트의 경우는 애초에 데이터 타입의 선언조차 필요하지 않다. 유연성은 뛰어나지만, 예상치 못한 오류가 발생할 여지가 다분하여 신뢰성은 떨어진다. 16. 문(Statement)문(statement)은 하나 이상의 표현식과 키워드의 조합으로 자바스크립트 엔진에게 내리는 명령이다. 문의 집합이 곧 프로그램이며, 문을 작성하고 순서에 맞게 나열하는 것이 프로그래밍이다. 문의 구성 조건 선언문, 표현식 문, 조건문, 반복문 등으로 구분할 수 있다. 리터럴, 연산자, 표현식, 키워드 등으로 구성되며 세미콜론으로 마친다. 표현식으로 생성한 값을 이용해 자바스크립트 엔진에게 명령을 내릴 수 있어야 한다(값만 생성할 수 있는 표현식과의 차이점). 17. 표현식(Expression)표현식 == 리터럴, 식별자(변수명, 함수명 등), 연산자, 함수 호출의 조합 == 하나의 값으로 평가될 수 있는 문(Statement) == 값을 만드는 방법 참고 poiemaweb.com 18. 암묵적 타입 변환(Implicit coercion)타입 강제 변환(Type coercion)이라고도 하며, 개발자의 의도와 상관 없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동으로 변하는 것을 말한다. 예를 들어 console.log(1 + true);의 결과값은 2가 나온다. 이것은 자바스크립트 엔진은 불리언 타입의 true를 숫자 타입 1로 강제 변환하기 때문이다(false는 0으로 변환). 19. 자신과 일치하지 않는 유일한 값1console.log(NaN &#x3D;&#x3D;&#x3D; NaN); &#x2F;&#x2F; false NaN은 자신과 일치하지 않는 유일한 값이다. 따라서 숫자가 NaN인지 아닌지 알기 위해서는 빌트인 함수 isNaN을 사용해야 한다. 20. +0과 -0이 있다.자바스크립트에는 양의 0과 음의 0이 존재한다. 그런데, 둘을 비교해보면 true가 나온다. 12console.log(0 &#x3D;&#x3D;&#x3D; -0); &#x2F;&#x2F; trueconsole.log(0 &#x3D;&#x3D; -0); &#x2F;&#x2F; true","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://codeameba.github.io/categories/JavaScript/"}],"tags":[{"name":"일기","slug":"일기","permalink":"http://codeameba.github.io/tags/%EC%9D%BC%EA%B8%B0/"},{"name":"til","slug":"til","permalink":"http://codeameba.github.io/tags/til/"},{"name":"TIL","slug":"TIL","permalink":"http://codeameba.github.io/tags/TIL/"},{"name":"Today I Learned","slug":"Today-I-Learned","permalink":"http://codeameba.github.io/tags/Today-I-Learned/"},{"name":"오늘배운것들","slug":"오늘배운것들","permalink":"http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Javascript","slug":"Javascript","permalink":"http://codeameba.github.io/tags/Javascript/"},{"name":"패스트캠퍼스","slug":"패스트캠퍼스","permalink":"http://codeameba.github.io/tags/%ED%8C%A8%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%8D%BC%EC%8A%A4/"}]},{"title":"JavaScript TIL(2019.04.29)","slug":"programming/js-til-01","date":"2019-04-28T16:00:42.000Z","updated":"2020-02-03T07:47:26.920Z","comments":true,"path":"2019/04/29/programming/js-til-01/","link":"","permalink":"http://codeameba.github.io/2019/04/29/programming/js-til-01/","excerpt":"","text":"Instagram에서 이 게시물 보기 ✨👨‍💻☕️ Sunny Sunday! Nice day to coding, isn’t it? . . #fubiz #somewheremagazine #inspirationcultmag #dreamermagazine #소니이미지갤러리 #sonyimagegallery #sonyalpha #a7m3 #sel1635z #minimalzine #gominimalmag #moodygrams #lensculture #peoplewhocode #seoul_korea #codinglife #codingdays codeAmeba(Sooyoung Jeong)(@codeameba)님의 공유 게시물님, 2019 4월 28 2:01오전 PDT JavaScript 1일차(19.04.29)프론트엔드 스쿨의 꽃이라고 할 수 있는 자바스크립트 과정이 오늘부로 시작됐다. 첫 시간이라 앞으로 3개월 동안 진행하게 될 수업과 관련하여 오리엔테이션을 해주셨다. 프론트엔드 개발자의 역할부터 자바스크립트의 변천사까지 지난 수업들과 책에서도 봤었기 때문에 어렴풋이 알고 있는 내용들이었다. 그럼에도 오히려 아는 내용이라 반가운 것은, 지난주 컴퓨터공학의 여파가 아닐까 싶다. 물론, 이 반가운 기분은 오늘이 처음이자 마지막이 될 것 같은 예감이 든다. 여러모로 걱정과 설렘이 동시에 찾아오는 미묘한 기분이다. 프론트엔드 개발자퍼블리셔는 서버까지 고려하지 않지만, 프론트엔드 개발자를 서버에서 하는 일까지 숙지하고 있어야 한다.프론트엔드 개발자는 웹브라우저에서 돌아가는 소프트웨어(애플리케이션)를 만드는 사람이다. 따라서 웹브라우저에 대한 이해가 중요하다. 공부의 우선 순위 예습 복습 과제 프로그램이란,해야 할 일들의 나열 HTML/CSS는,선언형 프로그래밍 언어로 구분하는 경우도 있다. 프로그래밍 언어란 무엇인가?컴퓨터가 수행해야 할 명령을 문서 형식으로 작성하는 인공어(!= 자연어) 가독성이 좋은 코딩을 해야 한다코드는 컴퓨터만 보는 게 아니라, 나도 보고, 동료도 보기 때문 ECMA모든 웹브라우저에서 동일하게 구동되도록 JavaScript의 표준을 제시하는 단체현재는 ES5, ES6가 주로 쓰이고 있음.ES6 Document HTML5의 출현2009년 출현한 HTML5는 웹 개발 역사의 큰 전환점. 동시에 ES5가 등장. 2005년 구글맵스비동기적 데이터 통신(Ajax)를 통해 부드러운 화면 전환을 웹에서 최초로 구현한 사례 자바스크립트를 실행할 수 있는 환경 Node.js : ES (server side라서 Web API는 포함되어 있지 않다.) 브라우저 : ES + (client side)Web API -&gt; 따라서 ES를 가장 우선적으로 알아야 함. 과제 자바스크립트와 ES의 차이를 알아야 함 Web API가 무엇인지 알아야 함 참고자료 poiemaweb.com w3.org","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://codeameba.github.io/categories/JavaScript/"}],"tags":[{"name":"일기","slug":"일기","permalink":"http://codeameba.github.io/tags/%EC%9D%BC%EA%B8%B0/"},{"name":"til","slug":"til","permalink":"http://codeameba.github.io/tags/til/"},{"name":"TIL","slug":"TIL","permalink":"http://codeameba.github.io/tags/TIL/"},{"name":"Today I Learned","slug":"Today-I-Learned","permalink":"http://codeameba.github.io/tags/Today-I-Learned/"},{"name":"오늘배운것들","slug":"오늘배운것들","permalink":"http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Javascript","slug":"Javascript","permalink":"http://codeameba.github.io/tags/Javascript/"},{"name":"패스트캠퍼스","slug":"패스트캠퍼스","permalink":"http://codeameba.github.io/tags/%ED%8C%A8%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%8D%BC%EC%8A%A4/"}]},{"title":"CSS의 상속(Inherit)에 대해 알아보자","slug":"programming/css-inherit","date":"2019-04-27T16:00:42.000Z","updated":"2020-02-03T07:47:26.902Z","comments":true,"path":"2019/04/28/programming/css-inherit/","link":"","permalink":"http://codeameba.github.io/2019/04/28/programming/css-inherit/","excerpt":"","text":"CSS 상속(Inherit)의 이해 상속(Inherit)이란?CSS에는 상속이라는 개념이 있다. 말 그대로 부모 요소(Element)의 속성값(Value)을 그대로 물려받는다는 의미인데, 모든 속성값에 상속이 적용되는 것은 아니기 때문에 처음 상속을 배웠을 때 다소 어렵게 느꼈던 기억이 있다.‘백문이불여일견’이랬으니, 우선 아래의 코드와 결과를 확인해보자. 123456789101112131415161718192021&lt;head&gt; &lt;style&gt; .first &#123; color: deeppink; background-color: rgb(49, 49, 49); width: 500px; height: 500px; font-size: 2rem; margin: 150px auto; box-shadow: 3px 3px 10px gray; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"first\"&gt; 이것은 부모 &lt;div class=\"second\"&gt; 이것은 자식 &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 코드에서 볼 수 있듯이 first의 하위 태그의 클래스가 second인데, CSS는 first에만 적용했음에도 second까지 변했다. 이것이 CSS의 상속을 단적으로 보여주는 예라고 할 수 있다. 물론 모든 속성이 상속 되지는 않는데, 이는 개발자도구를 실행해보면 아래와 같이 쉽게 확인할 수가 있다. Inherited form div.first라고 명시된 곳을 보면 어떤 속성값들이 상속 되었는지 알 수가 있는데, 그 중에서도 활성화 되어있는 color와 fort-size가 second에 상속, 적용되었다. 이를 통해 우리가 깨달을 수 있는 것은, 상속이 되어야 편한 속성값들만 상속이 된다는 점이다. 결론적으로, 상속이 있는 이유는 생산성을 높이기 위함이라고 이해할 수가 있다. 만약, 모든 속성값이 상속 된다면, 이러한 결과가 나왔을 것이다. CSS를 다뤄봤다면 잘 알 테지만, 상속된 속성값 중 필요 없는 것들을 제거 하는 일에 상당한 시간을 할애하게 될 것이다. 모든 속성값 상속 후 필요 없는 속성값 제거 VS 필요한 속성값 추가둘 중 무엇이 더 효율적일지는 곰곰이 생각해보면 누구나 알 수 있을 것이다. 아래와 같이 상속 되지 않는 속성값은 따로 추가하면 되는 것이고, 이미 상속된 속성값 또한 자식 요소에 부여한 속성값이 더 우선 적용 되기 때문에 손쉽게 변경이 가능하다. 그리고, 상속이 되지 않는 속성을 강제로 상속 시키고 싶을 때에는, 아래의 코드에서 margin과 같이 속성값으로 inherit을 부여하면 상속이 된다. 1234567891011121314151617181920212223242526&lt;head&gt; &lt;style&gt; .first &#123; color: deeppink; background-color: rgb(49, 49, 49); width: 500px; height: 500px; font-size: 2rem; margin: 150px auto; box-shadow: 3px 3px 10px gray; &#125; .second &#123; color: lime; background-color: brown; margin: inherit; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"first\"&gt; 이것은 부모 &lt;div class=\"second\"&gt; 이것은 자식 &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 상속이 되는 속성값과, 되지 않는 속성값은 아래의 링크에서 자세히 확인할 수 있으니 참고하길 바란다. 링크 바로가기: Full property table 참고자료 MDN W3C","categories":[{"name":"CSS","slug":"CSS","permalink":"http://codeameba.github.io/categories/CSS/"}],"tags":[{"name":"css","slug":"css","permalink":"http://codeameba.github.io/tags/css/"},{"name":"inherit","slug":"inherit","permalink":"http://codeameba.github.io/tags/inherit/"},{"name":"상속","slug":"상속","permalink":"http://codeameba.github.io/tags/%EC%83%81%EC%86%8D/"},{"name":"tip","slug":"tip","permalink":"http://codeameba.github.io/tags/tip/"}]},{"title":"컴퓨터공학 8일차 TIL(2019.04.26)","slug":"programming/cs-til-08","date":"2019-04-25T16:00:42.000Z","updated":"2020-02-03T07:47:26.902Z","comments":true,"path":"2019/04/26/programming/cs-til-08/","link":"","permalink":"http://codeameba.github.io/2019/04/26/programming/cs-til-08/","excerpt":"","text":"컴공 8일차(19.04.26) 오늘은 컴퓨터공학 마지막 수업이었다. 처음에는 워낙 생소하고 어려운 내용들 일색이라 무슨 생각을 할 겨를도 없이 수업을 따라가는 것만으로도 벅찼는데, 일주일 정도 지나니 이제 슬슬 용어들도 귀에 들어오고 익숙해지기 시작했다. 그런데 끝이라니, 아쉬움이 진하게 남는다. 하나라도 더 가르쳐주고 싶어하시던 선생님의 모습 또한 뇌리에 깊게 박혀 더욱 그렇다. 그리고, 위클리 테스트의 날이기도 했다. 지금껏 다소 벅찬 감이 있어도 반타작은 했는데, 이번만큼은 무리였다. 아니, ‘무리였다’라는 건 너무나도 무책임한 변명이고, 내 수준을 절실히 느낀 시간이었다. 내가 지난 두 달 동안 했던 것은 공부가 아니라 ‘공부하는 척’이었다는 생각이 든다. 현재의 수준을 냉정히 받아들이고 치밀하게 계획을 짜야 하는 시기다. Merge sort1234567891011121314151617181920212223242526272829303132333435363738394041424344454647def merge(li, start, mid, end): merged=[] left=start right=mid+1 while left &lt;= mid and right &lt;= end: if li[left] &lt; li[right]: merged.append(li[left]) left+=1 else: merged.append(li[right]) right+=1 while left &lt;= mid: merged.append(li[left]) left+=1 while right &lt;= end: merged.append(li[right]) right+=1 li[start : end+1]=merged # 또는 아래의 코드# for idx in range(start, end):# li[idx]=merged.pop(0)def merge_sort(li, start, end): # 기저조건 if start &gt;= end: return mid=(start+end)//2 merge_sort(li, start, mid) merge_sort(li, mid+1, end) merge(li, start, mid, end)# TESTimport randomwhile True: num_data=int(input('데이터 개수(종료:0):')) if not num_data: break data=[random.randint(1, 100) for _ in range(num_data)] print(data) merge_sort(data, 0, len(data)-1) print(data) 참고: 합병 정렬 - 위키백과, 우리 모두의 백과사전 영상 추천 MIT OpenCourseWare - YouTube ADT(추상 자료형, Abstract Data Type) 자료구조의 인터페이스(함수 시그니처, 오퍼레이션)를 명시해 놓은 것. 기능명세. 구체적인 구현 설명이 들어가면 안 된다. 구현 방법은 크게 3가지 배열 연결리스트 파이썬의 리스트(어댑터) -&gt; 스택 Stack LIFO(후입선출/선입후출, Last In, First Out) 쌓여있는 접시를 꺼내는 이미지로 생각하면 쉬움. stack ADT 참고123456789101112131415161718192021222324252627282930# adapter patternclass Stack: def __init__(self): self.container=list() def empty(self): if not self.container: return True return False def push(self, data): self.container.append(data) # 래퍼 함수(wrapper function) def pop(self): return self.container.pop() def peek(self): return self.container[-1]stack=Stack()stack.push(1)stack.push(2)stack.push(3)stack.push(4)stack.push(5)while not stack.empty(): print(stack.pop()) 스택으로 꼭 해봐야 할 것 후위 표기법 계산기 미로찾기 Queue FIFO(선입선출, First In, First Out) ADT 참고1234567891011121314151617181920212223242526# adapter patternclass Queue: def __init__(self): self.container=list() def empty(self): if not self.container: return True return False def enqueue(self, data): self.container.append(data) # 래퍼 함수(wrapper function) def dequeue(self): return self.container.pop(0) def peek(self): return self.container[0]q=Queue()for i in range(1, 6): q.enqueue(i)while not q.empty(): print(q.dequeue()) 문제: 스택 두 개를 이용해서 큐를 구현하라!123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 스택class Stack: def __init__(self): self.container=list() def empty(self): if not self.container: return True return False def push(self, data): self.container.append(data) # 래퍼 함수(wrapper function) def pop(self): return self.container.pop() def peek(self): return self.container[-1]# 큐class Queue: def __init__(self): self.first=Stack() self.second=Stack() def empty(self): if self.first.empty() and self.second.empty(): return True return False def enqueue(self, deta): self.first.push(data) def dequeue(self): if self.empty(): return None # first에서 second로 옮기는 시점이 중요 # second가 비었을 때 if self.second.empty(): while not self.first.empty(): self.second.push(self.first.pop()) return self.second.pop()q=Queue()q.enqueue(1)q.enqueue(2)q.enqueue(3)print(q.dequeue())q.enqueue(4)q.enqueue(5)while not q.empty(): print(q.dequeue()) 연결리스트(Linked List) 싱글 링크드 리스트와 더블 링크드 리스트가 있음. 더블 링크드 리스트 더미 더블 링크드 리스트 노드(Node) 링크드 리스트에 데이터와 데이터를 잇는 지점 더미 노드: 데이터가 없는 노드, 구현 편의성(프로그래머의 실수를 줄임)을 높이기 위해 사용 Node Add12345678910111213141516171819202122232425262728293031323334353637383940class DLinkedList: def __init__(self): self.head=Node() self.tail=Node() self.d_size=0 self.head.next=self.tail self.tail.prev=self.head def empty(self): if self.d_size==0: return True return False def size(self): return self.d_size def add_first(self, data): # 새로운 노드를 만들었다. new_node=Node(data) # new_node 기준으로 연결 new_node.prev=self.head new_node.next=self.head.next self.head.next.prev=new_node self.head.next=new_node self.d_size+=1 def add_last(self, data): new_node=Node(data) new_node.next=self.tail new_node.prev=self.tail.prev self.tail.prev.next=new_node self.tail.prev=new_node self.d_size+=1 Node Insert1234567891011121314151617181920212223242526272829303132333435363738class DLinkedList: def __init__(self): self.head=Node() self.tail=Node() self.d_size=0 self.head.next=self.tail self.tail.prev=self.head def empty(self): if self.d_size==0: return True return False def size(self): return self.d_size def insert_after(self, data, node): new_node=Node(data) new_node.prev=node new_node.next=node.next node.next.prev=new_node node.next=new_node self.d_size+=1 def insert_before(self, data, node): new_node=Node(data) new_node.next=node new_node.prev=node.prev node.prev.next=new_node node.prev=new_node self.d_size+=1 Node Search 순회 방식(Traversal) 더미 노드 다음/이전(head.next / tail.prev)에서 시작 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071class DLinkedList: def __init__(self): self.head=Node() self.tail=Node() self.d_size=0 self.head.next=self.tail self.tail.prev=self.head def empty(self): if self.d_size==0: return True return False def size(self): return self.d_size def search_forward(self, target): cur=self.head.next while cur is not self.tail: if cur.data==target: return cur cur=cur.next return None def search_backward(self, target): cur=self.tail.prev while cur is not self.head: if cur.data==target: return cur cur=cur.prev return None # 제너레이터def show_list(dlist): cur=dlist.head.next while cur is not dlist.tail: yield cur.data cur=cur.next# TESTli=DLinkedList()li.add_first(1)li.add_first(2)li.add_last(3)def show(li): for elem in show_list(li): print(elem, end=' ')# search data testli.add_last(4)li.add_last(3)searched_node=li.search_forward(3)if searched_node: print(searched_node.data)else: print('there is no such data')node=li.search_forward(3)if node: li.insert_after(10, node)show(li) Node DeleteReference Count 참조 갯수 a=10 일 때 10(value)을 기준으로 ref count는 1 b=a, c=b라고 한다면, ref count는 3 garbage collection을 이루는 것들 중 하나 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class Node: def __init__(self, data=None): self.prev=None self.data=data self.next=None # 객체가 소멸될 때 # 반드시 한 번 호출되는 소멸자 def __del__(self): print(f'&#123;self.data&#125; is deleted')class DLinkedList: def __init__(self): self.head=Node() self.tail=Node() self.d_size=0 self.head.next=self.tail self.tail.prev=self.head def empty(self): if self.d_size==0: return True return False def size(self): return self.d_size def delete_first(self): if self.empty(): return self.head.next=self.head.next.next self.head.next.prev=self.head self.d_size-=1 def delete_last(self): if self.empty(): return self.tail.prev=self.tail.prev.prev self.tail.prev.next=self.tail self.d_size-=1 def delete_node(self, node): node.prev.next=node.next node.next.prev=node.prev self.d_size-=1 # 제너레이터def show_list(dlist): cur=dlist.head.next while cur is not dlist.tail: yield cur.data cur=cur.next# Testli.delete_first()li.delete_last()li.delete_node(li.search_backward(10)) 추가로 공부해야 할 것들배열과 연결리스트 배열 검색(인덱싱)이 빠르다는 것이 배열의 장점, O(1) 데이터를 insert할 때 O(n) - 단점 데이터를 delete할 때도 O(n) - 단점 연결리스트 검색이 느림, O(n) - 단점 insert - O(1) - 장점 delete - O(1) - 장점 선형 자료구조 Linked List Stack Queue 비선형 자료구조 Tree(이진트리) 순회(traversal) 전위(preorder) - stack 중위(inorder) - stack. -&gt; DFS -&gt; 재귀(스택트레인)로 구현, 반복문으로 스택 후위(postorder) - stack 레벨 순서(level order) - queue -&gt; BFS BST(Binary Search Tree) O(n**2) -&gt; search 균형이진트리(Balanced Self Balancing) AVL Tree Red-Black Tree B-Tree(데이터베이스 인덱스) 균형이진트리 + 하드웨어 아키텍처 Heap(완전이진트리, 배열) Hash Table(map) heath function collision(충돌) chaining open-addressing 기법 Graph 순회(traversal) DFS -&gt; 깊이 우선 탐색 - 스택 기반 BFS -&gt; 너비 우선 탐색 - 큐 기반 MST 최소신장트리(minimum spanning tree) greedy algorithm 기반 kruslcal algorithm prim algorithm 최단 경로 문제(shortest path) Dijkstra algorithm -&gt; greedy algorithm Bellman-ford algorithm flood-warshall algorithm -&gt; dynamic programming 참고자료 WIKIPEDIA 이미지 출처 unsplash.com","categories":[{"name":"CS","slug":"CS","permalink":"http://codeameba.github.io/categories/CS/"}],"tags":[{"name":"일기","slug":"일기","permalink":"http://codeameba.github.io/tags/%EC%9D%BC%EA%B8%B0/"},{"name":"til","slug":"til","permalink":"http://codeameba.github.io/tags/til/"},{"name":"TIL","slug":"TIL","permalink":"http://codeameba.github.io/tags/TIL/"},{"name":"Today I Learned","slug":"Today-I-Learned","permalink":"http://codeameba.github.io/tags/Today-I-Learned/"},{"name":"오늘배운것들","slug":"오늘배운것들","permalink":"http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"},{"name":"패스트캠퍼스","slug":"패스트캠퍼스","permalink":"http://codeameba.github.io/tags/%ED%8C%A8%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%8D%BC%EC%8A%A4/"}]},{"title":"컴퓨터공학 7일차 TIL(2019.04.25)","slug":"programming/cs-til-07","date":"2019-04-24T16:00:42.000Z","updated":"2020-02-03T07:47:26.902Z","comments":true,"path":"2019/04/25/programming/cs-til-07/","link":"","permalink":"http://codeameba.github.io/2019/04/25/programming/cs-til-07/","excerpt":"","text":"컴공 7일차(19.04.25) 네트워크와 기본알고리즘을 배웠다. 네트워크는 그나마 알아 들을 수 있는 범주여서 비교적 양호했으나, 알고리즘은 여전히 어렵다. 여전히라고 해봤자 아직 제대로 공부한 것도 아니지만, 사실 첫 인상이 그리 좋지는 않다. 그래도 친해지려고 노력해야겠지만… Network NIC가 2개 이상부터는 라우터라고 부를 수 있음. IP의 역할은 단 하나, IP라우팅 $ netstat -r 라우팅테이블 호출 TCP/IP 4계층 1계층) Network Interface - Ethernet(MAC address) 2계층) Internet - IP(IP routing), packet을 받는 호스트(컴퓨터)를 특정하는 역할, 특정 호스트에 도달하기 위해 IP를 관리하는 계층 3계층) Transport - TCP/UDP, Port를 관리하며, 특정 프로세스(서버나 클라이언트)에 접근 4계층) Application HTTP: 메시지 기반, 문자열, HTTPS: application과 transport 사이에 SSL/TLS(secure socket layer)가 추가되어 암호화 됨 DNS DNS(Domain Name System) $ nslookup -&gt; facebook.com : 해당 도메인의 IP 확인 가능 IP주소를 기억하기 어려워서 사람이 기억하기 쉬운 도메인 네임이 등장 입력된 도메인 네임을 DNS가 IP로 변환해줌 브라우저가 DNS Server 측으로 요청(처음 접속 시에 요청 후, cache에 저장 됨) URL(파일식별자, Uniform Resource Lacator) 구조: http://www.example.com:80/path/to/myfile.html?key1=value1&amp;key2=value2#SomewhereInTheDocument URL: 요청한 자원의 위치를 가리킨다. http: 형식을 나타내는 Protocol 혹은 Scheme www.example.com: Domain Name, IP주소와 동일한 역할 :80: Port, 생략하는 경우가 많음. /path/to/myfile.html: 해당 문서의 경로, 최근에는 물리적 경로가 아닌, 웹 서버에서 추상화된 경로를 나타내는 경우가 많음. ?key1=value1&amp;key2=value2: Query라고 부르며, 해당 자원을 대략적으로 설명한다. #SomewhereInTheDocument: Anchor 혹은 Bookmark라고 한다. 보통 해당 페이지에서 임의 지점으로 자동 스크롤링 되는 방식으로 이용된다. HTTP 0.9/1.0 버전까지는 text 위주였기 때문에 UDP를 사용했음. 1.1부터는 TCP를 통한 지속적 연결 지원. -&gt; 이미지, 영상 등 정보가 많아져서 메서드클라이언트가 웹서버에게 사용자 요청의 목적과 종류를 알리는 수단으로, HTTP 요청 메시지의 첫째줄에 위치한다. GET과 POST 방식이 주로 쓰인다. GET: 리소스 취득 HEAD: 메시지 헤더(문서 정보) 취득 POST: 내용 전송(파일 전송도 가능) PUT: 내용 갱신 위주(파일 전송도 가능) DELETE: 웹 리소스(파일) 제거 TRACE: 요청 리소스가 수신되는 경로를 보여줌. 거의 사용 안함. OPTION: 웹서버측 제공 메소드에 대한 질의 CONNECT: 프록시 서버와 같은 중간 서버 경유. 거의 사용 안함. 보안상의 이유로, 웹서버가 GET, POST 2개의 메소드 또는 OPTIONS를 포함한 3개까지만 허용하는 경우가 대부분. 상태코드 200번대: 성공 300번대: Redirect 400번대: client의 문제로 실패, 요청에 문제가 있음. 500번대: server의 문제로 실패, 응답에 문제가 있음. 컨텐츠 협상 요청 자료에 대해 우선순위를 정해 놓고 요청을 했을 때 서버에서 해당 설정에 맞춰서 전송 서버 주도 방식과 클라이언트 주도 방식이 있음 server-driven: 네트워크에 부담 agent-driven: 정확도 상승 ex) Accept : text/html, text/*;q=0.5, */*;q=0.2 TCP/UDP TCP 신뢰도가 높다. 패킷이 유실되면, 재전송 해줌. 유실 유무를 지속적으로 확인하기 때문에 네트워크에 부담이 됨. 파일, 메일 등에 주로 쓰임. 서버소켓과 호스트가 접속된 후 계속 연결 되어있음. UDP 신뢰도가 낮다. 패킷 전송 후 유실 돼도 재전송 안해줌. 빠르고 가벼움. 동영상 서비스나 게임 등에 주로 쓰임. 데이터 전송 후 연결 해제 참고할만한 자료 TCP/IP 완벽가이드 - 알라딘: TCP/IP 완벽 가이드 NAVER D2 - 최소한 ‘데이터 수신’까지는 알아야 함! NAT(Network Address Translation) 라우터가 호스트의 IP(private)를 자신의 IP(public)로 변환하여 저장 NAPT(Network Address Port Translation) NAT에 Port까지 함게 맵핑하여 변환 NIC(정확하게는 라우터가 호스트에게 할당해줄 수 있는 IP의 갯수)가 부족하여 동일한 IP를 할당할 수밖에 없을 때, 이를 구분하기 위해 Port번호를 추가, 변경하여 구분. port 2**10개 만큼 사용 가능 특정 프로세스에 정확하게 정보를 전송하기 위한 표식 Server / Client server: 서비스 제공자, socket이 많다. 특정 컴퓨터의 특정 프로세스. 웹 서버 게임 서버 ftp 서버 port: socket(일종의 메모리)에 부여된 숫자. 0~216-1, 2bytes 정수 0~1023 (server) 49152~65534(client) Well-known port(정해진 포트 번호)가 있음(표 참고) HTTPS port : 443 / HTTP : 80 client: 프로세스 socket: 두 종류가 있음 data socket: 접속 후 데이터를 송/수신 하는 소켓 listening socket : client로부터 접속 요청을 받는 소켓 sliding window - 공부할 것 자료구조/알고리즘Comparison Sorting - 우선적으로 공부해야 할 알고리즘 Quick Sort - Random pivot O(n log n) -&gt; average 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960def get_middle_idx(li, start, mid, end): \"\"\" 리스트의 맨 처음 값과 중간 값, 마지막 값 중에서 가운데 값이 위치한 인덱스를 반환한다. \"\"\" idx_li=[start, mid, end] # to do if li[idx_li[0]] &lt; li[idx_li[1]]: idx_li[0], idx_li[1]=idx_li[1], idx_li[0] if li[idx_li[1]] &gt; li[idx_li[2]]: idx_li[1], idx_li[2]=idx_li[2], idx_li[1] if li[idx_li[0]] &gt; li[idx_li[1]]: idx_li[0], idx_li[1]=idx_li[1], idx_li[0] return idx_li[1]def quick_sort(li, start, end): # base case # to do if start &gt;= end: return left=start right=end mid=li[(left+right)//2] # 추가된 코드 mid_idx=get_middle_idx(li, start, mid, end) li[mid_idx], li[mid]=li[mid], li[mid_idx] # left와 right가 교차하기 전까지 while left &lt;= right: # li[left]가 피벗보다 작으면 # left++ while li[left] &lt; pivot: left+=1 # li[right]가 피벗보다 크면 # right-- while pivot &lt; li[right]: right-=1 if left &lt;= right: li[left], li[right]=li[right], li[left] left+=1 right-=1 quick_sort(li, start, right) quick_sort(li, left, end)# TESTimport randomwhile True: num_data=int(input('데이터 개수(종료:0):')) if not num_data: break data=[random.randint(1, 100) for _ in range(num_data)] print(data) quick_sort(data, 0, len(data)-1) print(data) Insertion sort / selection sort insertion sort(삽입정렬) 12345678910111213141516171819202122232425def insertion_sort(li): n=len(li) for i in range(1, n): temp=li[i] for j in range(i-1, -2, -1): if j==-1: break if li[j] &gt; temp: li[j+1]=li[j] else: break li[j+1]=temp# TESTimport randomwhile True: num_data=int(input('데이터 개수(종료:0):')) if not num_data: break data=[random.randint(1, 100) for _ in range(num_data)] print(data) insertion_sort(data) print(data) selection sort 1234567891011121314151617181920def selection_sort(li): n=len(li) for i in range(n-1): min_idx=i for j in range(i+1, n): if li[j] &lt; li[min_idx]: min_idx=j li[i], li[min_idx]=li[min_idx], li[i]# TESTimport randomwhile True: num_data=int(input('데이터 개수(종료:0):')) if not num_data: break data=[random.randint(1, 100) for _ in range(num_data)] print(data) selection_sort(data) print(data) 참고자료 MDN WIKIPEDIA 정보통신기술용어해설(http://www.ktword.co.kr/abbr_view.php?m_temp1=3791) 이미지 출처 unsplash.com","categories":[{"name":"CS","slug":"CS","permalink":"http://codeameba.github.io/categories/CS/"}],"tags":[{"name":"일기","slug":"일기","permalink":"http://codeameba.github.io/tags/%EC%9D%BC%EA%B8%B0/"},{"name":"til","slug":"til","permalink":"http://codeameba.github.io/tags/til/"},{"name":"TIL","slug":"TIL","permalink":"http://codeameba.github.io/tags/TIL/"},{"name":"Today I Learned","slug":"Today-I-Learned","permalink":"http://codeameba.github.io/tags/Today-I-Learned/"},{"name":"오늘배운것들","slug":"오늘배운것들","permalink":"http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"},{"name":"패스트캠퍼스","slug":"패스트캠퍼스","permalink":"http://codeameba.github.io/tags/%ED%8C%A8%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%8D%BC%EC%8A%A4/"}]},{"title":"컴퓨터공학 6일차 TIL(2019.04.24)","slug":"programming/cs-til-06","date":"2019-04-23T16:00:42.000Z","updated":"2020-02-03T07:47:26.902Z","comments":true,"path":"2019/04/24/programming/cs-til-06/","link":"","permalink":"http://codeameba.github.io/2019/04/24/programming/cs-til-06/","excerpt":"","text":"컴공 6일차(19.04.24) 여러모로 수학 공부의 필요성을 절실하게 느낀 시간이었다. 왜 나는 문과이며, 수학을 등한시 했던가. 의미 없는 후회보다 대책을 마련해야 할 때다. 정신 차리자. 내겐 시간이 많지 않다. OOP 공부할 때 반드시 이해해야 할 개념 캡슐화(encapsulation): 정보 은닉을 포함 정보 은닉(information hiding) 다형성(polymorphism): 상속(inheritance) -&gt; 매서드 오버라이딩(method overriding) 디자인 패턴(SOLID) - 참고서적: GoF S: single responsibility principle(단일책임) O: open-closed principle(확장-폐쇄) L: Liskov substitution principle(리스코프 치환) I: interface segregation principle(인터페이스 분리) D: dependency inversion principle(의존 역전) Hanoi Tower12345678910111213141516def hanoi(n, _from, _by, _to): #n은 쟁반 갯수 #base case if n==1: print(f'&#123;n&#125;번째 쟁반을 &#123;_from&#125;에서 &#123;_to&#125;로 이동') return hanoi(n-1, _from, _to, _by) print(f'&#123;n&#125;번째 쟁반을 &#123;_from&#125;에서 &#123;_to&#125;로 이동') hanoi(n-1, _by, _from, _to)hanoi(2, 'A', 'B', 'C')# result# 1번째 쟁반을 A에서 B로 이동# 2번째 쟁반을 A에서 C로 이동# 1번째 쟁반을 B에서 C로 이동 버블정렬(Bubble sort)예제 for, while 사용하지 않고 1 ~ 10,000,000의 합을 구해라 재귀 factorial* -&gt; + summation sum(n) = sum(n-1) + n1234def sumation(n): if n==1: return 1 return sumation(n-1)+n 12def sumation2(n): return n*(1+n)//2 리누스 토발즈 영상을 통해 알 수 있는 알고리즘의 필요성 Class class가 붕어빵 틀이라면, instance는 붕어빵 절차지향 함수 -&gt; 함수 시그니처 함수는 기능을 모아둔 단위 함수는 추상화의 도구 객체지향 객체(object) -&gt; 추상화 도구 객체는 관련이 있는 변수(상태정보, 특성값)와 함수(기능)가 합쳐진 것 예제(계좌) 123456789101112131415161718192021222324252627282930313233343536373839class Account: # 생성자(constructor) # 객체를 생성활 때 \"반드시\" 한번 호출한다. def __init__(self, cust_name, init_balance): # 인스턴스 멤버(속성, 데이터, 변수)를 설정 self.name=cust_name self.balance=init_balance # 소멸자(destructor) # 객체가 소멸될 때 \"반드시\" 한번 호출 def __del__(self): pass # 인스턴트 메서드(기능, 행동) def deposit(self, money): if money &lt; 0: return False # 관련 있는 변수: 인스턴스 멤버 self.balance+=money return True def withdraw(self, money): if money &gt; self.balance: return 0 self.balance -= money return money def transfer(self, other, money): self.balance -= money # 다른 객체의 멤버에 바로 접근하지 않는다. # 다른 객체의 멤버값을 변경할 때는 # 반드시 상대 객체가 가진 메서드에 맡겨야 한다. # 이것을 메시지 패싱이라고 한다. other.deposit(money)# 메서드 호출my_acnt=Account('Greg', 5000) Information Hiding 접근 제어자 C, C++은 접근차단 가능 python은 불가능 Network OSI 7 계층 TCP/IP 랜카드의 공식명은 NIC(network interface card) NIC 고유의 (물리적)주소가 MAC address LAN / WAN LAN(local area network) 서로의 MAC주소를 안다면 라우터를 거치지 않고서도 PC끼리 통신 가능 MTU: 한 번에 보낼 수 있는 데이터 허용량(1500 bytes) $ ifconfig -&gt; NIC 확인 가능 WAN(wide area network) 광범위한 지역 단위로 구성하는 네트워크 LAN과 LAN을 잇는다. TCP/IP TCP(전송제어프로토콜, Transmission Control Protocol) IP(인터넷프로토콜, Internet Protocol) TCP/IP 4계층 아래 이미지 참고 ARP 주소 결정 프로토콜(Address Resolution Protocol, ARP)은 네트워크 상에서 IP 주소를 물리적 네트워크 주소로 대응(bind)시키기 위해 사용되는 프로토콜이다. 여기서 물리적 네트워크 주소는 이더넷 또는 토큰링의 48 비트 네트워크 카드 주소를 뜻한다. (출처: 위키백과) IP(Internet Protocal) 1byte 정수(0~255)로 이루어져 있음 클래스 서브넷 Host IP에 할당된 비트를 쪼갠 것이 서브넷 참고자료 1 참고자료 2 Public IP / Private IP 내용 추가 예정 알고리즘sorting 단순 알고리즘 (비교정렬, comparison sorting) bubble sort insertion sort selection sort 분할 정복 기법(Divide &amp; Conquer) : 어려운 문제를 잘게 쪼개서, 작게 쪼개진 문제를 하나씩 해결함으로써 작은 solution이 모여서 전체 문제에 대한 solution을 구하는 기법 quick sort pivot은 해당 index의 값, 그 자체 merge sort heap sort quick sort 예제12345678910111213141516171819202122232425262728293031323334353637383940414243def quick_sort(li, start, end): # base case # to do if start &gt;= end: return left=start right=end pivot=li[(left+right)//2] # left와 right가 교차하기 전까지 while left &lt;= right: # li[left]가 피벗보다 작으면 # left++ while li[left] &lt; pivot: left+=1 # li[right]가 피벗보다 크면 # right-- while pivot &lt; li[right]: right-=1 if left &lt;= right: li[left], li[right]=li[right], li[left] left+=1 right-=1 quick_sort(li, start, right) quick_sort(li, end, left) #test codeimport randomwhile True: num_data=int(input('데이터 개수(종료:0):')) if not num_data: break data=[random.randint(1, 100) for _ in range(num_data)] print(data) quick_sort(data, 0, len(data)-1) print(data) 아래 영상 참고할 것 참고자료 wikipedia microsoft","categories":[{"name":"CS","slug":"CS","permalink":"http://codeameba.github.io/categories/CS/"}],"tags":[{"name":"일기","slug":"일기","permalink":"http://codeameba.github.io/tags/%EC%9D%BC%EA%B8%B0/"},{"name":"til","slug":"til","permalink":"http://codeameba.github.io/tags/til/"},{"name":"TIL","slug":"TIL","permalink":"http://codeameba.github.io/tags/TIL/"},{"name":"Today I Learned","slug":"Today-I-Learned","permalink":"http://codeameba.github.io/tags/Today-I-Learned/"},{"name":"오늘배운것들","slug":"오늘배운것들","permalink":"http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"},{"name":"패스트캠퍼스","slug":"패스트캠퍼스","permalink":"http://codeameba.github.io/tags/%ED%8C%A8%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%8D%BC%EC%8A%A4/"}]},{"title":"컴퓨터공학 5일차 TIL(2019.04.23)","slug":"programming/cs-til-05","date":"2019-04-22T16:00:42.000Z","updated":"2020-02-03T07:47:26.902Z","comments":true,"path":"2019/04/23/programming/cs-til-05/","link":"","permalink":"http://codeameba.github.io/2019/04/23/programming/cs-til-05/","excerpt":"","text":"컴공 5일차(19.04.23) 운영체제와 알고리즘이 적절히 버무려진 강의였다. 덕분에 강의가 끝날 무렵에는 내 머릿속도 잘 버무려졌다. 아아.. 갈 길이 멀다. 금일 강의 진행 순서 Binary search, big O Compiler vs interpreter Process / thread -&gt; multi thread -&gt; race condition -&gt; mural exclubion 절차지향 OOP Network 알고리즘/자료구조 Binary Search 데이터가 정렬되어 있어야 함(필수) 12345678910111213141516def binary_search(li, target): start=0 end=len(li)-1 while start &lt;= end: mid=(start+end)//2 if target == li[mid]: return mid elif target &lt; li[mid]: end=mid-1 elif target &gt; li[mid]: start=mid+1 return Noneli=[1, 3, 5, 7, 9, 15, 17]target = 7binary_search(li, target) linear search : T(n) = n binary search : T(n) = log2n 아래의 영상을 이해할 수 있다면 BEST Big-O 시간 복잡도 랭킹 O(1) : constant time(상수시간) 입력값 n이 주어졌을 때, 알고리즘이 문제를 해결하는데 오직 한 단계만 거침 O(log n) : log time(로그시간) 입력값 n이 주어졌을 때, 문제를 해결하는데 필요한 단계들이 연산마다 특정 요인에 의해 줄어듭니다. ex) BST(insert/search/delete) O(n) : linear time(선형시간, 직선적 시간) 문제를 해결하기 위한 단계의 수와 입력값 n이 1:1 관계를 가집니다. O(n log n) : log linear time(선형 로그 시간) ex) quick sort, merge sort 비교정렬(comparison sorting)의 경우 O(n log n)보다 성능이 좋을 수 없음. O(n2) : quadratic time(2차 시간) 문제를 해결하기 위한 단계의 수는 입력값 n의 제곱입니다. O(n3) : cubic time O(2n) : exponential time OS Job scheduling scheduler -&gt; context switching process status(프로세스 상태) -&gt; thread -&gt; multithreading 참고 페이지 프로세스(https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4) 운영 체제 - 위키백과, 우리 모두의 백과사전 Scheduling Priorities - Windows applications | Microsoft Docs Scheduler -3- (Preemption &amp; Context Switch) – 문c 블로그 선점형(새치기, pre-emptive) 스케쥴링 / 비선점형(non-preemptive) 스케쥴링 pre-emptive -&gt; multitasking Priority algorithm Round-Robin algorithm -&gt; 정해진 시간 동안 실행 time slice / quantum Concurrency programming(동시성 프로그래밍) 논리적인 용어로 동시에 실행되는 것처럼 보이는 것입니다. 싱글 코어(멀티 코어에서도 가능)에서 멀티스레드를 동작시키기 위한 방식으로 멀티 태스킹을 위해 여러 개의 스레드가 번갈아 가면서 실행되는 방식입니다. 동시성을 이용한 싱글 코어의 멀티 태스킹은 각 스레드들이 병렬적으로 실행되는 것처럼 보이지만 사실은 서로 번갈아 가면서 실행되고 있는 방식입니다. (출처: 1) 동시성 프로그래밍과 비동기 프로그래밍 &gt; 부스트코스 iOS 프로그래밍 : edwith) 과거엔 주로 multithreading race-condition / dead-lock ::Asynchronous I/O -&gt; IO Bound -&gt; javascript 핵심개념 꼭 공부할 것!:: 프로그램의 주 실행 흐름을 멈추어서 기다리는 부분 없이 바로 다음 작업을 실행할 수 있게 하는 방식입니다. 즉, 코드의 실행 결과 처리를 별도의 공간에 맡겨둔 뒤 결과를 기다리지 않고 바로 다음 코드를 실행하는 병렬처리 방식입니다. 비동기 프로그래밍은 언어 및 프레임워크에서 지원하는 여러 방법으로 구현할 수 있습니다.(출처: 1) 동시성 프로그래밍과 비동기 프로그래밍 &gt; 부스트코스 iOS 프로그래밍 : edwith) program 하드디스크에 저장되어 있는 하나의 이미지(code, data) process 메인 메모리에 올라와서 실행을 시작한 프로그램 실행된 프로그램마다 P(process)ID 발급 프로세서는 하드웨어적인 측면에서 컴퓨터 내에서 프로그램을 수행하는 하드웨어 유닛입니다. 대표적으로 중앙처리장치(Central Processing Unit - CPU)가 이에 속합니다. 한 컴퓨터가 여러 개의 프로세서를 갖는다면 멀티 프로세서라고 말합니다. 듀얼 프로세서라고 한다면 한 컴퓨터에 두 개의 프로세서가 운용된다고 할 수 있습니다. (출처: https://www.edwith.org/boostcourse-ios/lecture/16866/ ) 프로그램과 프로세스 프로그램은 일반적으로 보조기억 장치에 저장된 실행코드 즉, 생명이 없는 상태를 말합니다. 프로세스는 프로그램을 구동하여 프로그램 자체와 프로그램의 상태가 메모리상에서 실행되는 작업 단위를 말합니다. 동시에 여러 개의 프로세스를 운용하는 시분할 방식을 멀티태스킹이라고 합니다. 이러한 프로세스 관리는 운영체제에서 담당합니다. (출처: 1) 동시성 프로그래밍과 비동기 프로그래밍 &gt; 부스트코스 iOS 프로그래밍 : edwith) Context Switching instruction PCB(process controls block) context switching은 느려서 자주 하면 안 좋지만, 안 할 수는 없음 문맥 교환 - 위키백과, 우리 모두의 백과사전 Process (computing) - Wikipedia Process vs Thread Process 실행흐름 Thread 스레드는 하나의 프로세스 내에서 실행되는 작업흐름의 단위를 말합니다. 보통 한 프로세스는 하나의 스레드를 가지고 있지만, 프로세스 환경에 따라 둘 이상의 스레드를 동시에 실행할 수 있습니다. 이러한 방식을 멀티스레딩이라고 합니다. 그리고 프로그램 실행이 시작될 때부터 동작하는 스레드를 메인 스레드라 하고 그 외에 나중에 생성된 스레드를 서브 스레드 또는 세컨더리 스레드라고 합니다. (출처: 1) 동시성 프로그래밍과 비동기 프로그래밍 &gt; 부스트코스 iOS 프로그래밍 : edwith) 인스트럭션의 나열 process에 포함됨 GIL(global interpreter lock) multi-thread exam123456789101112131415161718192021222324252627import threadingn=1000offset=n//4def thread_main(li, i): for idx in range(offset i, offset(1+1)): li[idx]=2 li=[i for i in range(1, 1001)]threads=[]#스레드를 생성for i in range(4): th=threading.Thread( target=thread_main, args=(li, i)) threads.append(th)#멀티스레딩for th in threads: th.start()#메인 스레드에서 나머지 스레드들이 모든 실행을 끝날 때까지 기다림.for th in threads: th.join()print(li) 동시성(Concurrency) 프로그래밍/ 병렬(Parallelism) 프로그래밍 둘은 다른 개념 동시성 프로그래밍은 하드웨어적으로도 나누어져야 함 공유자원(shared resource)에 같이 접근하면 멀티스레딩의 효율(race condition)이 좋지 않음 공유자원 대표적인 건 ‘전역 변수’ race-condition exam 12345678910111213141516171819202122232425262728293031323334import threading# 공유 자원# 모든 스레드에서 접근이 가능한 자원# 전역 변수g_num=0# Lock 객체lock=threading.Lock()def thread_main(): global g_num # critical section # 임계 영역 # 어떤 스레드에서 공유 자원에 접근한 후 # 수정, 변경 하려는 코드 lock.acquire() for _ in range(1000000): g_num+=1 lock.release()threads=[]for _ in range(50): th=threading.Thread(target=thread_main) threads.append(th)for th in threads: th.start()for th in threads: th.join()print(g_num) 재귀함수(Recursion) 함수 호출 도중에 자기 자신을 다시 호출하는 것 base case(기저 조건, 종료 조건, 탈출 조건) 1234567def func(n): # base case if n &lt;= 0: return func(n-1)func(5) 재귀함수를 만드는 방법 패턴을 찾는 -&gt; 점화식을 만든다! 기저 조건을 만든다 예제 factorial(계승) : 3! = 3 * 2 * 1 = 3 * 2! 점화식: fac(n) = fac(n-1) * n 기저조건: n==1 or n==0 return 1 12345678def factorial(n): if n==0 or n==1: return 1 return factorial(n-1) * nfor i in range(1, 6): print(factorial(i)) 피보나치 수열(Fibonacci Series)예제 점화식: fibo(n-2)+fibo(n-1) 기저조건: if n==1 then 0 / if n==2 then 1 123456789def fibonacci(n): if n==1: return 0 elif n==2: return 1 return fibonacci(n-2) + fibonacci(n-1)for i in range(1, 11): print(fibonacci(i), end=' ') 다음 시간에 계속… 참고자료 edwith wikipedia 시간 복잡도 - 위키백과 이미지 출처 https://unsplash.com/","categories":[{"name":"CS","slug":"CS","permalink":"http://codeameba.github.io/categories/CS/"}],"tags":[{"name":"일기","slug":"일기","permalink":"http://codeameba.github.io/tags/%EC%9D%BC%EA%B8%B0/"},{"name":"til","slug":"til","permalink":"http://codeameba.github.io/tags/til/"},{"name":"TIL","slug":"TIL","permalink":"http://codeameba.github.io/tags/TIL/"},{"name":"Today I Learned","slug":"Today-I-Learned","permalink":"http://codeameba.github.io/tags/Today-I-Learned/"},{"name":"오늘배운것들","slug":"오늘배운것들","permalink":"http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"},{"name":"패스트캠퍼스","slug":"패스트캠퍼스","permalink":"http://codeameba.github.io/tags/%ED%8C%A8%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%8D%BC%EC%8A%A4/"}]},{"title":"깃(git)과 터미널(terminal)의 주요 명령어","slug":"programming/tip-git-command","date":"2019-04-22T16:00:42.000Z","updated":"2020-02-03T07:47:26.950Z","comments":true,"path":"2019/04/23/programming/tip-git-command/","link":"","permalink":"http://codeameba.github.io/2019/04/23/programming/tip-git-command/","excerpt":"","text":"깃(git)이란?위키백과에서 말하길, 깃(git)은 프로그램 등의 소스 코드 관리를 위한 분산 버전 관리 시스템이라고 한다. 다소 어려운 말로 설명이 되었는데, 내가 이해한 개념으로 다시 말하자면, ‘끔찍한 사태를 예방하기 위한 일종의 보험’ 같은 것이다. 여기서 끔찍한 사태란, 서비스를 개발하며 일어날 수 있는 모든 최악의 상황들을 말한다. 이래도 깃의 필요성을 느끼지 못 하는 사람이 있을 수 있으니, 조금 더 친절하게 가벼운 예시를 들어보겠다. 예시 1 개발자A는 평소 USB를 애용하며 파일을 전달할 때에도 수고롭게 USB에 담아서 전달한다. 그날도 중요한 프로젝트의 소스코드를 USB에 고이 담아 동료에게 전달했다. 본인이 모르는 사이에 바이러스에 감염되었다는 사실도 모른 채… 예시 2 개발자B는 본인이 깃 명령어를 모른다는 것에 자격지심을 느껴 일개 시스템보다 인간이 우수하다는 보여주겠다며, 본인만의 폴더에 파일명을 하나하나 정성껏 지정하여 업데이트 내역을 관리했다. 그러던 어느날 극도로 피로한 상태에서 야근을 하던 개발자B는 작업하던 파일을 저장하고 가벼운 마음으로 퇴근을 했다. ‘다른 이름으로 저장하기’가 아닌, ‘저장’을 했다는 사실도 모른 채… 요즘 유행한다는 열린결말로 예시를 들어보았다. 각 예시의 결말은 당신의 상상에 맡기겠다. 물론, 두 사례 모두 현실성 없는 극단적인 예시이며, 이후에 딱히 별일이 없었을지도 모른다. 하지만, 개발자는 언제나 최악을 상황까지 고려하여 차선책을 마련해야만 한다고 나는 생각한다. 최악의 상황이 본인만의 일이라면 모르겠지만, 모두의 부담이 될 수도 있다. 따라서 버전별 소스코드를 저장 및 관리가 가능하고, 만일의 상황에서도 빠른 대처가 가능한 깃의 사용은 필수다. 깃(git)을 설치해보자OS X 깃 설치 링크Windows 깃 설치 링크 필수 명령어개인적으로 자주 사용하게 되는 터미널(terminal)과 깃(git)명령어를 소개한다. 카페에서 터미널을 실행하고 현란한 타이핑으로 명령어들을 실행하면 상당히 멋있다(고 나는 생각한다). 만약 깃을 처음 쓰거나, 컴퓨터를 바꿨다면…전역 사용자와 이메일을 등록해야 한다. 사용자 등록을 안 하더라도 깃헙은 사용할 수 있으나, 소중한 커밋(commit)이 집계되지 않아서 푸르른 잔디밭의 꿈이 날아간다. 사용자 등록: git config --global user.name &quot;본인이름&quot; 이메일 등록: git config --global user.email &quot;이메일주소&quot; 전역 사용자 정보 조회: git config --global --list 저장소에 따라 별도의 사용자와 이메일을 등록하려면, 사용자 등록: git config user.name &quot;본인이름&quot; 이메일 등록: git config user.email &quot;이메일주소&quot; 사용자 정보 조회: git config --list 자주 쓰는 터미널 명령어 현재 위치 확인: pwd 현재 위치의 폴더 확인: ls 최상위 위치로 이동: cd 한 단계 상위로 이동: cd .. 파일 생성: touch 파일명 폴더 생성: mkdir 폴더명 Make Directory의 이니셜로 기억하면 쉽다. 폴더 안에 또 폴더 만들기: mkdir -p 폴더명/{하위폴더1,하위폴더2,하위폴더3} 파일 삭제: rm 파일명 폴더 삭제: rm -rf 폴더명 또는 rmdir 폴더명 폴더로 이동: cd 폴더명 자주 쓰는 깃 명령어 현 위치의 디렉토리 초기화: git init 현 위치의 디렉토리와 원격 저장소 연결: git remote add 이름 저장소URL 이름은 관용적으로 origin을 쓴다. 저장소URL 위치는 아래의 이미지 참고. 원격 저장소 복제: git clone 저장소URL 저장소를 복제하면 별도의 remote 연결 과정은 생략해도 된다. 원격 저장소 내려받기: git pull 파일을 업로드 하기 전에 현재 상태를 내려받아야 한다. 안 그러면 에러 메시지가 나온다. 깃에 특정 파일 추가: git add 파일명 깃에 모든 파일 추가: git add . 커밋(commit): git commit -m &quot;설명&quot; 현 상태 확인: git status 가끔 쓰는 깃 명령어 브랜치 생성: git branch 브랜치이름 브랜치 목록 보기: git branch Master가 기본이며, Develop과 feature 등을 주로 추가하게 된다. 다른 브랜치로 이동: git checkout 브랜치이름 이정도가 현재까지 내가 주로 사용하는 명령어들이다. 이 밖에도 팀 프로젝트를 할 때에는 git flow를 쓰기도 하는데, 이건 아직 제대로 숙지하지 못한 기능이라 이번 포스팅에서는 제외하도록 하겠다. 추후 제대로 숙달하거든 그때 보다 충실한 내용을 업로드 할 것을 약속한다. 물론, 주 용도는 내가 까먹었을 때 보기 위함이다. 그래도 일단, 여기까지 익혔다면, 손가락이 쉬지 않고 움직일 정도는 된다. 카페로 가자! 터미널에 각종 명령어를 연습하며 폭풍간지를 뽐내보자. 사실, 그리 생산적인 행동이라고는 할 수 없지만, 내 경험으로 봤을 때 상당히 기분이 좋아진다. 고양감이라고 해야할까? 코피 터지게 공부해서 간지나게 코딩까지 하고 싶다는 나름의 동기부여도 된다.한 가지 주의사항이라면, 카페에 시니어 개발자가 있는지 확인해야 한다는 것이다. 이불킥은 싫으니까. 참고자료 https://git-scm.com/book/ko/v2 이미지 출처 https://unsplash.com/","categories":[{"name":"tip","slug":"tip","permalink":"http://codeameba.github.io/categories/tip/"}],"tags":[{"name":"git","slug":"git","permalink":"http://codeameba.github.io/tags/git/"},{"name":"github","slug":"github","permalink":"http://codeameba.github.io/tags/github/"},{"name":"terminal","slug":"terminal","permalink":"http://codeameba.github.io/tags/terminal/"},{"name":"터미널","slug":"터미널","permalink":"http://codeameba.github.io/tags/%ED%84%B0%EB%AF%B8%EB%84%90/"},{"name":"커맨드","slug":"커맨드","permalink":"http://codeameba.github.io/tags/%EC%BB%A4%EB%A7%A8%EB%93%9C/"},{"name":"깃","slug":"깃","permalink":"http://codeameba.github.io/tags/%EA%B9%83/"},{"name":"깃헙","slug":"깃헙","permalink":"http://codeameba.github.io/tags/%EA%B9%83%ED%97%99/"}]},{"title":"컴퓨터공학 4일차 TIL(2019.04.22)","slug":"programming/cs-til-04","date":"2019-04-21T16:00:42.000Z","updated":"2020-02-03T07:47:26.902Z","comments":true,"path":"2019/04/22/programming/cs-til-04/","link":"","permalink":"http://codeameba.github.io/2019/04/22/programming/cs-til-04/","excerpt":"","text":"Instagram에서 이 게시물 보기 👨‍💻🍷 . . #fubiz #somewheremagazine #inspirationcultmag #dreamermagazine #소니이미지갤러리 #sonyimagegallery #sonyalpha #a7m3 #sel55f18z #minimalzine #gominimalmag #moodygrams #lensculture #peoplewhocode #seoul_korea #codinglife 정수영(Sooyoung Jeong)(@aprilgreenery)님의 공유 게시물님, 2019 4월 20 8:46오전 PDT 컴공 4일차(19.04.22) 오늘 수업은 상당히 개념적인 내용이 주를 이루었다. 배울 것은 많은데, 수업 시간은 짧고, 시간은 점점 빨라지는 기분이라 왠지 모르게 초조해진다.기초지식을 쌓을 겸, 기회가 되면 자격증도 취득할 수 있도록, 정보처리기사 공부를 통해서 공부하는 것도 괜찮은 방안이 될 것 같다. 함수 Namespace : 변수가 출력될 때 본인과 가까운 순서로 실행되며 그 영역을 namespace라고 함. 변수가 저장된 공간.12345678910111213a=10def f(): t=10 def g(): b=20 def h(): nonlocal b #다른 지역 변수 b를 선택 b=30 print(b,'in h') h() print(b, 'in g') g()f() Stack frame: 함수가 실행될 때 쌓이는 메모리 공간(자바스크립트의 call stack) 인자 전달 방식에 따른 함수의 구분 call by value : 값을 가져와서 스택을 쌓음. 스택 밖으로 넘어갈 수는 없음. call by reference : 주소값을 가져와서(참조하여) 스택을 쌓음. 스택을 넘어서 값을 가져오거나 수정이 가능함. call by object reference immutable object는 함수 내부에서 값을 변경할 수 없다. First - Class Function 프로그래밍 언어 중 함수를 다른 변수와 동일하게 다루는 언어를 함수우선순위(First-class function)를 가졌다고 표현합니다. 예를 들어 함수를 다른 함수의 전달인자(Argument)로 사용하고, 함수에서 함수를 리턴하거나 변수의 값으로 함수를 할당할 수 있습니다. 출처First-class Function - 용어 사전 | MDN First-Class function은… 함수를 인자(argument)로 전달 함수를 리턴(return) 값으로 전달 함수를 변수에 전달 익명 함수 이름이 없는 함수 몇 번 사용 안 할 때 주로 씀 123456789101112def func(a, b): return a + b# 람다는 반드시 리턴이라서 return 생략f = lambda a, b: a + bli=[3, 2, 5, 6, 1, 8]li2=li.copy()li2.sort(reverse=True)li2.sort(key=lambda x: x%2==2, reverse=True) list comprehension1li2=[i*2 for i in range(1, 101)] map, filter, reduce lazy evaluation(게으른 연산) map : for와의 차이점은 연산의 실행 시점을 주도적으로 정할 수 있다는 점. 123li=[1, 2, 3, 4]m=map(lambda x: x**2, li)next(m) filter : 기준을 정하여 원하는 값만 걸러냄 123li=[5, -4, 3, -2, 6]f=filter(lambda x: x &gt; 0, li)next(f) filter와 map의 동시 사용 예시 12li=[4, -2, 5, 3]list(map(lambda x: x**2 ,filter(lambda x: x &gt; 0, li))) reduce: 원하는 값이 나올 때까지 리스트를 줄여줌123# 최대값 구하기li=[5, 2, 7, 13, 2, 6, 10]reduce(lambda a, b: a if a &gt; b else b, li) 삼항 연산자(python)123a=10# 참일 때 값 if 조건문 else 거짓일 때 값string='big' if a &gt; 7 else 'small' 예제12345678910li=['a', 'b', 'c', 'd', 'a', 'a', 'a', 'b', 'c']#result#dic=&#123;'a' : 4, 'b' : 2, 'c' : 2, 'd' : 1&#125;#use#dic.get()#dic.update() or dicreduce(lambda dic, ch: dic.update(&#123;ch : dic.get(ch, 0)+1&#125;) or dic, li, &#123;&#125;) reduce는 내장함수가 아니라서 from functools import reduce 추가해야 함 클로저(closure) 함수 내부에 상태 정보를 저장해두고, 함수 결과가 이 내부의 상태 정보에 따라 출력 결과가 달라짐. 일반적인 함수(function)은 하나의 input에 대해 하나의 output만을 가짐. 하지만 method, closure부터는 이 법칙이 깨짐. (과거에)OOP를 쓸 수 없을 때 울며 겨자 먹기로 썼다. 지역변수(local variable)가 필요한 이유 함수가 실행 도중에 결과 데이터를 저장하기 위해서 상태정보: 특정한 데이터의 현재 상태 스택프레임(stack frame) 존재의 이유 어떤 함수가 실행될 때 필요한 상태정보를 저장하기 위해 상태정보는 지역변수가 지정 계좌 클로저 함수 상태값에 따라 결과값이 달라짐?1234567891011121314def account(cus_name, balance): def inner(money): nonlocal balance balance+=money return cus_name, balance return innermy_acnt = account('greg', 5000)your_acnt = account('john', 300)my_acnt(500)#('greg', 5500)your_acnt(500)#('john', 800) 선형 탐색(Linear Search)12345678li=[5, 4, 3, 1, 2, 10, 25]target = 3def linear_search(li, target): for idx in range(len(li)): if li[idx] == target: return idx return Nonelinear_search(li, target) 알고리즘 성능 평가 절대 시간 X 상대 시간으로 측정: 연산 횟수, 최악의 경우 선형탐색의 소요 시간은 n에 바례 이진 탐색(Binary Search) 데이터가 정렬되어 있어야 함(필수) 1234567def binary_search(li, target): \"\"\" binary_search(li, target) -&gt; idx 타겟을 찾았다면 인덱스 반환 찾기 못 하면 None \"\"\" pass 다음 시간에 계속…","categories":[{"name":"CS","slug":"CS","permalink":"http://codeameba.github.io/categories/CS/"}],"tags":[{"name":"일기","slug":"일기","permalink":"http://codeameba.github.io/tags/%EC%9D%BC%EA%B8%B0/"},{"name":"til","slug":"til","permalink":"http://codeameba.github.io/tags/til/"},{"name":"TIL","slug":"TIL","permalink":"http://codeameba.github.io/tags/TIL/"},{"name":"Today I Learned","slug":"Today-I-Learned","permalink":"http://codeameba.github.io/tags/Today-I-Learned/"},{"name":"오늘배운것들","slug":"오늘배운것들","permalink":"http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"},{"name":"패스트캠퍼스","slug":"패스트캠퍼스","permalink":"http://codeameba.github.io/tags/%ED%8C%A8%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%8D%BC%EC%8A%A4/"}]},{"title":"컴퓨터공학 3일차 TIL(2019.04.19)","slug":"programming/cs-til-03","date":"2019-04-18T16:00:42.000Z","updated":"2020-02-03T07:47:26.540Z","comments":true,"path":"2019/04/19/programming/cs-til-03/","link":"","permalink":"http://codeameba.github.io/2019/04/19/programming/cs-til-03/","excerpt":"","text":"컴공 3일차(19.04.19) 자료구조 중 BST는 꼭 알아야 함 파이썬은 hash로 구성됨 이산수학, 집합, 선형대수 &gt; 프로그래머의 필수 수학 새로운 언어를 공부할 때 보는 순서 자료형 연산자 제어문, 반복문 함수 - call by ref? or call by value? class(OOP) 정보은닉 상속지원여부 가상함수지원여부 expression(식) “abc” , 1 : 단항식(unary expression) 무언가를 반환할 수 있으면 식 파이썬에서는 함수도 식 기본 입력 방식 stdin(standard input) : keyboard stdout(standard output) : monitor stderr(standard error) : monitor 함수는 첫 글자 ‘소문자’ / 클래스는 첫 글자 ‘대문자’파이썬2 와 파이썬3 의 차이 내부구조가 다름 파이썬2는 유니코드 지원 안 함 파이썬3에서 문자열이 편리해짐 ASCII / UNICODE 신호(부호)를 문자로 바꾸는 것이 ‘인코드’ 예) 모스부호 문자를 신호로 바꾸는 것이 ‘디코드’ a(character)=97(code point) ASCII는 7bit까지만 지원 가능하다는 게 단점 참고자료 https://ko.wikipedia.org/wiki/ASCII https://ko.wikipedia.org/wiki/%EC%9C%A0%EB%8B%88%EC%BD%94%EB%93%9C","categories":[{"name":"CS","slug":"CS","permalink":"http://codeameba.github.io/categories/CS/"}],"tags":[{"name":"일기","slug":"일기","permalink":"http://codeameba.github.io/tags/%EC%9D%BC%EA%B8%B0/"},{"name":"til","slug":"til","permalink":"http://codeameba.github.io/tags/til/"},{"name":"TIL","slug":"TIL","permalink":"http://codeameba.github.io/tags/TIL/"},{"name":"Today I Learned","slug":"Today-I-Learned","permalink":"http://codeameba.github.io/tags/Today-I-Learned/"},{"name":"오늘배운것들","slug":"오늘배운것들","permalink":"http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"},{"name":"패스트캠퍼스","slug":"패스트캠퍼스","permalink":"http://codeameba.github.io/tags/%ED%8C%A8%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%8D%BC%EC%8A%A4/"}]},{"title":"컴퓨터공학 2일차 TIL(2019.04.18)","slug":"programming/cs-til-02","date":"2019-04-17T16:00:42.000Z","updated":"2020-02-03T07:47:26.540Z","comments":true,"path":"2019/04/18/programming/cs-til-02/","link":"","permalink":"http://codeameba.github.io/2019/04/18/programming/cs-til-02/","excerpt":"","text":"컴공 2일차(2019.04.18) 프로그래머가 하는 일은 추상화(abstraction) 함수(function, routine, procedure, subroutine) procedural programming =절차지향 객체(object) OOP(object - oriented - programming) 객체지향 함수에서의 추상화란, ‘함수 시그니처(함수이름, 매개변수, 결과값)’ 또는 ‘인터페이스’와 ‘내부구현’을 구분(seperation)하는 것 Documentation은 함수 시그니처를 모아놓은 것 내부구현은 알고리즘으로 이루어져있고, 이를 테스트할 때 O(n)를 이용 함수를 만들 때 유의할 점 함수이름은, 누가 보더라도 어떤 용도인지 알 수 있도록 명확하게 매개변수, return 등 인터페이스를 동일하게 설계해야 함. 이를 기능명세라고 함. 2진수 정규화(normalization) 정규화: 정수부를 1자리수, 0이 아닌 자연수 예: 123.82 -&gt; 1.23482 x 10 **2 mantissa 부분은 정밀도를 의미한다. Epsilon언어 추상화파이썬mutable object(변경 가능 객체) 리스트 딕셔너리 집합(set) immutable object(변경 불가능 객체) 정수, 상수, 정수 문자열 튜플","categories":[{"name":"CS","slug":"CS","permalink":"http://codeameba.github.io/categories/CS/"}],"tags":[{"name":"일기","slug":"일기","permalink":"http://codeameba.github.io/tags/%EC%9D%BC%EA%B8%B0/"},{"name":"til","slug":"til","permalink":"http://codeameba.github.io/tags/til/"},{"name":"TIL","slug":"TIL","permalink":"http://codeameba.github.io/tags/TIL/"},{"name":"Today I Learned","slug":"Today-I-Learned","permalink":"http://codeameba.github.io/tags/Today-I-Learned/"},{"name":"오늘배운것들","slug":"오늘배운것들","permalink":"http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"},{"name":"패스트캠퍼스","slug":"패스트캠퍼스","permalink":"http://codeameba.github.io/tags/%ED%8C%A8%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%8D%BC%EC%8A%A4/"}]},{"title":"컴퓨터공학 1일차 TIL(2019.04.17)","slug":"programming/cs-til-01","date":"2019-04-16T16:00:42.000Z","updated":"2020-02-03T07:47:26.540Z","comments":true,"path":"2019/04/17/programming/cs-til-01/","link":"","permalink":"http://codeameba.github.io/2019/04/17/programming/cs-til-01/","excerpt":"","text":"컴공 1일차(2019.04.17) 위의 영상에 등장하는 용어를 모두 이해하는 것이 목표 컴퓨터는 전압으로 0, 1을 구분 2진수, 10진수, 16진수? - 정수를 표현하는 방식의 차이 10진수: 한 자리에 올 수 있는 숫자가 10개(09) radix2진수: 0과 116진수: 0f - 16개 JS의 단점: number의 타입이 하나밖에 없음(double = 8byte) I/O 작업을 위한 언어이기 때문에 정수 표현 범위가 있음. 하기 링크 참고. https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER https://en.wikipedia.org/wiki/IEEE_754","categories":[{"name":"CS","slug":"CS","permalink":"http://codeameba.github.io/categories/CS/"}],"tags":[{"name":"일기","slug":"일기","permalink":"http://codeameba.github.io/tags/%EC%9D%BC%EA%B8%B0/"},{"name":"til","slug":"til","permalink":"http://codeameba.github.io/tags/til/"},{"name":"TIL","slug":"TIL","permalink":"http://codeameba.github.io/tags/TIL/"},{"name":"Today I Learned","slug":"Today-I-Learned","permalink":"http://codeameba.github.io/tags/Today-I-Learned/"},{"name":"오늘배운것들","slug":"오늘배운것들","permalink":"http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"},{"name":"패스트캠퍼스","slug":"패스트캠퍼스","permalink":"http://codeameba.github.io/tags/%ED%8C%A8%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%8D%BC%EC%8A%A4/"}]},{"title":"CSS 박스 모델(Box Model)을 알아보자","slug":"programming/css-box-model","date":"2019-04-16T12:05:00.000Z","updated":"2020-02-03T07:47:26.902Z","comments":true,"path":"2019/04/16/programming/css-box-model/","link":"","permalink":"http://codeameba.github.io/2019/04/16/programming/css-box-model/","excerpt":"","text":"CSS의 기본이자 핵심은 BOXCSS에서 가장 기본적이자 가장 중요한 개념은 단연 박스 모델(Box model)이라고 할 수 있겠다. 이것을 모르면 절대 웹 페이지의 레이아웃을 구성할 수가 없다. 박스 모델은 아래의 그림과 같다. Content는 내용, Padding은 안쪽 여백, Border는 테두리, Margin은 바깥 여백을 말한다. 이것들이 웹 페이지의 레이아웃을 정하는 가장 기본적인 요소들이라고 할 수 있다. 아무 웹 페이지에서라도 개발자 도구를 실행 시키면 쉽게 확인할 수 있는데, 이를 통해 웹 페이지를 구성하는 모든 것이 결국 박스의 집합이라는 사실을 알 수 있다. 개발자 도구 실행 단축키 윈도우: F12 맥: option + command + i BOX를 다루는 법박스를 이루는 각각의 요소(padding, border, margin)는 크기 임의로 조정할 수 있다. CSS의 문법을 따르며 다음과 같이 작성한다. 물론, 기본적으로 HTML 문서에 종속(Cascade)되어 있기 때문에, HTML 문서 내의 &lt;style&gt;&lt;/style&gt; 태그 사이에 작성하거나 별도의 CSS 파일을 만들어 HTML 파일에 링크를 해야 한다. 링크된 HTML 문서에 &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;가 있다는 가정 하에 다음과 같이 padding과 border에 값을 지정해보겠다. 12345.box &#123; background: deeppink; padding: 15px; border: 3px solid black;&#125; 그러면, 다음과 같은 형태의 박스를 확인할 수 있다. 가로, 세로 값을 지정하지 않았기 때문에 &lt;div&gt;의 기본값인 block이 적용되어 화면 전체를 차지하며, 기본 margin이 적용되어 가장자리에 여백이 있는 것을 확인할 수 있다. 마찬가지로 margin에도 임의의 값을 지정할 수 있으며, 기본으로 주어진 8px의 margin을 제거할 수도 있다. box-sizing 위의 BOX 01과 BOX 02의 사이즈는 같은가 다른가? 놀랍게도 같은 크기다. 좀 더 자세히 말하자면, 눈에 보이는 사이즈는 다르지만, 실제 적용된 너비와 높이는 동일하다. 코드는 아래와 같다. 1234567891011121314151617181920&lt;style&gt; div &#123; width: 300px; height: 300px; margin: 30px auto; padding: 15px; text-align: center; font-size: 3rem; font-weight: 800; box-shadow: 3px 3px 15px gray; border: 3px solid black; &#125; .box-01 &#123; background: palevioletred; box-sizing: border-box; &#125; .box-02 &#123; background: paleturquoise; &#125;&lt;/style&gt; 차이점을 발견했는가? 그렇다. BOX 01에는 box-sizing: border-box;가 적용되어 있다. 이것은 지정된 박스 크기(width, height)에 border와 padding이 포함된 형태로 나타나며, 위의 예시에서 볼 수 있듯이 두 박스가 모두 padding: 15px을 갖고 있지만 보여지는 크기가 다르다. 쉽게 이해하려면, border와 padding의 값은 적용되지 않는다고 생각하면 좋다. 하지만, ‘내부에 포함되었을 뿐, 사라진 것은 아니라는 점을 명심하자.’ 이러한 특성을 지닌 border-box를 사용하는 이유는 테두리(border나 여백(padding)에 상관 없이 예측 가능한 크기의 박스를 얻기 위함이다. border-box 외에도 다음과 같은 속성값이 존재한다. content-box: 기본값 padding-box: 박스의 크기(width, height)에 border와 margin을 제외한 padding까지만 포함한다. 각각의 차이점을 쉽게 이해할 수 있는 예시를 들어보겠다. 아래와 같은 박스가 있다고 쳤을 때, 12345width: 300px;height: 300px;border: 5px solid black;padding 10px;margin: 10px; 각 box-sizing값에 따라 실제로 차지하는 영역은 다음과 같다.content-box(기본값): width: 350px, height: 350pxpadding-box: width: 320px, height: 320pxborder-box: width: 330px, height: 330px 참고자료 MDN(https://developer.mozilla.org/ko/docs/Web/CSS/box-sizing) 이미지 출처 https://unsplash.com/","categories":[{"name":"CSS","slug":"CSS","permalink":"http://codeameba.github.io/categories/CSS/"}],"tags":[{"name":"html","slug":"html","permalink":"http://codeameba.github.io/tags/html/"},{"name":"markup","slug":"markup","permalink":"http://codeameba.github.io/tags/markup/"},{"name":"html기초","slug":"html기초","permalink":"http://codeameba.github.io/tags/html%EA%B8%B0%EC%B4%88/"},{"name":"웹 표준","slug":"웹-표준","permalink":"http://codeameba.github.io/tags/%EC%9B%B9-%ED%91%9C%EC%A4%80/"},{"name":"웹 접근성","slug":"웹-접근성","permalink":"http://codeameba.github.io/tags/%EC%9B%B9-%EC%A0%91%EA%B7%BC%EC%84%B1/"},{"name":"web standard","slug":"web-standard","permalink":"http://codeameba.github.io/tags/web-standard/"},{"name":"web accessibility","slug":"web-accessibility","permalink":"http://codeameba.github.io/tags/web-accessibility/"},{"name":"박스모델","slug":"박스모델","permalink":"http://codeameba.github.io/tags/%EB%B0%95%EC%8A%A4%EB%AA%A8%EB%8D%B8/"},{"name":"box model","slug":"box-model","permalink":"http://codeameba.github.io/tags/box-model/"}]},{"title":"구글 애널리틱스(Google analytics)로 블로그 유입 분석을 해보자","slug":"blog/tip-google-analytics","date":"2019-04-15T16:00:42.000Z","updated":"2020-02-20T22:13:43.262Z","comments":true,"path":"2019/04/16/blog/tip-google-analytics/","link":"","permalink":"http://codeameba.github.io/2019/04/16/blog/tip-google-analytics/","excerpt":"","text":"구글 애널리틱스(Google analytics)를 쓰는 이유 github 블로그를 hexo를 통해 개설한 뒤, 그 동안 몇 가지 기능을 추가했다. 대표적으로 디스커스(DISQUS)를 활용한 댓글 기능과 구글 애널리틱스(Google analytics)를 활용한 유입 분석 기능이다. 사실 댓글 기능은 아직 아무도 댓글을 달아주지 않았기 때문에 별 의미를 못 느끼겠지만, 구글 애널리틱스는 상당히 마음에 든다. ‘내 블로그에 누가 들어오기나 할까’ 싶었는데, 유입 데이터를 확인해보니 제법 쏠쏠하다. 특히, 구글느님답게 단순한 방문자수 조회만 되는 게 아니라 페이지뷰, 유입 기기, 유입 경로, 사용자 흐름, 접속 지역 등 상당히 다양한 정보를 얻을 수 있어서 이 데이터를 어떻게 이용하느냐에 따라 블로그를 전략적으로 운영할 수 있을 거라고 생각한다. 참고로 지난 3일간 구글 애널리틱스를 통해 수집된 주요 데이터 현황은 다음과 같다. 솔직히 지금 당장은 수집된 데이터도 미미하고, 블로그 콘텐츠도 부실하기 때문에 의미있는 인사이트를 얻기에는 무리가 있다. 하지만, 블로그를 지속적으로 운영할 수 있는 동기부여 차원에서 큰 의미가 있다고 본다. 내가 쓴 글을 누군가는 분명 보고 있다는 사실이 의욕과 책임감을 불러일으킨다. 그런 의미에서 다른 누군가도 나와 같은 기분을 느꼈으면 하는 바람에 구글 애널리틱스 연동 방법을 소개한다. HEXO 블로그에 구글 애널리틱스를 연동해보자 먼저, 본인의 구글 계정으로 구글 애널리틱스에 가입을 해야 한다. 가입하기를 클릭하면 아래와 같은 창이 뜬다. 구글 애널리틱스 바로가기 각 빈칸에 적절한 내용을 입력한 후, 가장 하단의 **추적 ID 가져오기**라는 파란색 버튼을 클릭하면 된다. 가입완료 버튼이 아니다. 그리고, 몇 가지 동의를 하면, 아래와 같이 추적 ID가 보이는 가입 완료 페이지가 보일 것이다. 이 추적 ID를 통해 HEXO 블로그와 구글 애널리틱스를 연동할 수가 있다. 또는, 하단의 소스코드를 본인의 웹 페이지에 붙여 넣는 것으로도 가능한데, 대부분의 HEXO theme/_config.yml에는 구글 애널리틱스 추적 ID를 기입하는 곳이 있으며, 굉장히 간편하다. 내가 쓰는 clean-blog theme의 경우 다음과 같이 되어 있다. 12# Google Analytics Tracking IDgoogle_analytics: //your tracking ID 모든 내용을 마친 뒤, hexo deloy -g 하면, 구글 애널리틱스의 블로그 연동 완료다. 다만, 24시간을 주기로 데이터가 업데이트 되기 때문에 연동 즉시 뭔가를 확인할 수는 없으니 참고하길 바란다. 이미지 출처 https://unsplash.com/","categories":[{"name":"tip","slug":"tip","permalink":"http://codeameba.github.io/categories/tip/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://codeameba.github.io/tags/hexo/"},{"name":"블로그","slug":"블로그","permalink":"http://codeameba.github.io/tags/%EB%B8%94%EB%A1%9C%EA%B7%B8/"},{"name":"blog","slug":"blog","permalink":"http://codeameba.github.io/tags/blog/"},{"name":"구글 애널리틱스","slug":"구글-애널리틱스","permalink":"http://codeameba.github.io/tags/%EA%B5%AC%EA%B8%80-%EC%95%A0%EB%84%90%EB%A6%AC%ED%8B%B1%EC%8A%A4/"},{"name":"유입분석","slug":"유입분석","permalink":"http://codeameba.github.io/tags/%EC%9C%A0%EC%9E%85%EB%B6%84%EC%84%9D/"},{"name":"google analytics","slug":"google-analytics","permalink":"http://codeameba.github.io/tags/google-analytics/"}]},{"title":"문법성 검사를 하자","slug":"programming/tip-validation","date":"2019-04-14T16:00:42.000Z","updated":"2020-02-03T07:47:26.950Z","comments":true,"path":"2019/04/15/programming/tip-validation/","link":"","permalink":"http://codeameba.github.io/2019/04/15/programming/tip-validation/","excerpt":"","text":"문법성 검사(Validation)를 하자 나에게 하는 당부브라우저는 무척 친절해서 웬만큼 심한 오류가 아니면 그대로 웹 페이지를 띄워준다. 또한, 문법적인 오류를 사람이 찾아내는 것에도 한계가 있기 때문에 아래의 링크를 통해 한 번씩 문법성 검사를 하는 것이 좋다. 물론, 당장 실행이 된다는 것에만 만족하고 넘어갈 수도 있다. 하지만, 훗날 한 명의 몫을 하는 개발자가 되었을 때, 정말 한 점 부끄럼이 없다고 당당히 말할 수 있을까? 그러니까 문법성 검사를 습관화하자. 그렇게 오래 걸리지도 않으며, 돈이 드는 것도 아니다. 기왕 하는 거 쉬운길 보다는 제대로 된 길로 가자. HTML ValidationCSS Validation 이미지 출처 https://unsplash.com/","categories":[{"name":"HTML","slug":"HTML","permalink":"http://codeameba.github.io/categories/HTML/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://codeameba.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"http://codeameba.github.io/tags/CSS/"},{"name":"validation","slug":"validation","permalink":"http://codeameba.github.io/tags/validation/"},{"name":"문법검사","slug":"문법검사","permalink":"http://codeameba.github.io/tags/%EB%AC%B8%EB%B2%95%EA%B2%80%EC%82%AC/"}]},{"title":"HTML의 구조와 시멘틱 설계","slug":"programming/html-03","date":"2019-04-13T16:00:42.000Z","updated":"2020-02-03T07:47:26.919Z","comments":true,"path":"2019/04/14/programming/html-03/","link":"","permalink":"http://codeameba.github.io/2019/04/14/programming/html-03/","excerpt":"","text":"Instagram에서 이 게시물 보기 성수동, 2019 꽃이 피었는데 볼 시간이 없네 . . #fubiz #somewheremagazine #inspirationcultmag #dreamermagazine #소니이미지갤러리 #sonyimagegallery #sonyalpha #a7m3 #sel55f18z #streetphotography #life_is_street #ourstreets #minimalzine #gominimalmag #moodygrams #streetleaks #lensculture #cherryblossom #springagain 정수영(Sooyoung Jeong)(@aprilgreenery)님의 공유 게시물님, 2019 4월 12 10:01오후 PDT 올해도 역시 봄이 오고, 꽃이 피었는데, 볼 시간이 없다. 그나마 날씨 좋은 날에 특강이 있어서 겸사 겸사 근처의 벚꽃을 찍었다. 화사하게 포스팅을 시작해본다. HTML의 구조HTML의 구조로는 대표적으로 3단 구조와 4단 구조가 있으며, 웹 사이트의 용도와 성격에 따라 영역을 추가 및 제거하거나 위치를 임의로 지정하는 등의 변형을 하기도 한다. 3단 구조는 크게 헤더, 콘텐츠, 푸터 영역으로 구성된다. 4단 구조는 크게 헤더, 네비게이션, 콘텐츠, 푸터 영역으로 구성된다. 콘텐츠의 선형화HTML 문서를 작성할 때에는 논리적 순서에 의한 선형화를 이루어야 한다. 다시 말해, 아래와 같이 흔하게 볼 수 있는 게시판에서단순히 레이아웃만 생각한다면 아래처럼 구성하는 오류를 범하게 된다. 12345678910111213&lt;body&gt; &lt;section&gt; &lt;h2&gt;게시판&lt;/h2&gt; &lt;a href=\"#\"&gt;더보기&lt;/a&gt; &lt;ul&gt; &lt;li&gt;동해물과 백두산이&lt;/li&gt; &lt;li&gt;마르고 닳도록&lt;/li&gt; &lt;li&gt;하느님이 보우하사&lt;/li&gt; &lt;li&gt;우리나라 만세&lt;/li&gt; &lt;li&gt;무궁화 삼천리&lt;/li&gt; &lt;/ul&gt; &lt;/section&gt;&lt;/body&gt; 언뜻 보기에는 잘못된 부분이 없는 것처럼 보일 수 있겠으나, 키보드(Tab)로 접근할 경우를 고려하면 무엇이 잘못되었는지 쉽게 알 수 있다. 위와 같이 적용한다면 ‘게시판’ 다음에 바로 ‘더보기’에 접근하게 된다. ‘이게 뭐 대수라고…’라는 생각을 할 수도 있겠지만, 음성지원 프로그램의 도움을 받는 시각장애인의 입장을 고려해야만 한다. 따라서, ‘더보기’는 마지막이 되는 것이 올바른 선형화이며, 즉, 콘텐츠의 선형화는 웹 접근성의 기본이라고 할 수 있다. 웹 접근성과 관련하여 더욱 자세한 내용은 아래의 링크에서 확인할 수 있다.웹 접근성과 웹의 본질 - HTML은 의미를 담는 언어 시멘틱(Semantic)한 설계 HTML을 공부하다 보면, 웹 표준, 웹 접근성과 더불어 가장 많이 접하게 되는 단어가 시멘틱(Semantic)이다. 시멘틱은 사전적으로 의미의, 의미론적인이라는 뜻을 지니고 있다. 이것은 웹 접근성 측면에서의 의미를 뜻하기도 하지만, 동시에 ‘브라우저가 이해할 수 있도록’ 하는 것이기도 하다. 무슨 말이냐 하면, 태그를 묶을 때 단순히 편하다는 이유로 &lt;div&gt;&lt;/div&gt;를 남발하는 경우가 왕왕 있는데, &lt;div&gt;는 아무런 의미가 없기 때문에 중요한 내용의 콘텐츠가 담겨있다고 하더라도 브라우저는 우선순위를 낮게 평가한다는 것이다. 그래서 우리는 콘텐츠의 성격에 따라 의미를 분명하게 나타낼 수 있도록 &lt;section&gt;, &lt;article&gt;, &lt;nav&gt;, &lt;h1&gt;, &lt;p&gt; 등의 시멘틱 태그들을 적극적이고, 적절하게 사용해야만 한다. 이것은 또한, SEO(Search Engine Optimization) 측면에서도 탁월하게 작용하여 시멘틱하게 설계된 웹 사이트는 검색에서도 우위를 점할 수 있다. 시멘틱 대그의 종류는 아래의 링크를 통해 확인할 수 있다.HTML의 시멘틱 태그 - W3School 참고자료 http://darum.daum.net/accessibility/pc/index_3_3_1 http://www.wah.or.kr/Accessibility/define.asp https://www.w3schools.com/html/html5_semantic_elements.asp 이미지 출처 https://unsplash.com/","categories":[{"name":"HTML","slug":"HTML","permalink":"http://codeameba.github.io/categories/HTML/"}],"tags":[{"name":"html","slug":"html","permalink":"http://codeameba.github.io/tags/html/"},{"name":"markup","slug":"markup","permalink":"http://codeameba.github.io/tags/markup/"},{"name":"html기초","slug":"html기초","permalink":"http://codeameba.github.io/tags/html%EA%B8%B0%EC%B4%88/"},{"name":"웹 표준","slug":"웹-표준","permalink":"http://codeameba.github.io/tags/%EC%9B%B9-%ED%91%9C%EC%A4%80/"},{"name":"웹 접근성","slug":"웹-접근성","permalink":"http://codeameba.github.io/tags/%EC%9B%B9-%EC%A0%91%EA%B7%BC%EC%84%B1/"},{"name":"web standard","slug":"web-standard","permalink":"http://codeameba.github.io/tags/web-standard/"},{"name":"web accessibility","slug":"web-accessibility","permalink":"http://codeameba.github.io/tags/web-accessibility/"}]},{"title":"알아두면 정신건강에 이로운 Emmet","slug":"programming/tip-emmet","date":"2019-04-13T16:00:42.000Z","updated":"2020-02-03T07:47:26.950Z","comments":true,"path":"2019/04/14/programming/tip-emmet/","link":"","permalink":"http://codeameba.github.io/2019/04/14/programming/tip-emmet/","excerpt":"","text":"Instagram에서 이 게시물 보기 눈인사😌🙂 . . #일상스냅 #ordinaryday #묘물사진 #portrait #냥스타그램 #livingwithcats #holidayvibes #fubiz #somewheremagazine #inspirationcultmag #dreamermagazine #sonyimagegallery #sonyalpha #소니이미지갤러리 #a7m3 #sel55f18z #minimalzine #gominimalmag #moodygrams #catsofinstagram 정수영(Sooyoung Jeong)(@aprilgreenery)님의 공유 게시물님, 2019 2월 19 3:22오전 PST 노곤노곤한 일요일 오후, 우리집 귀염둥이 자랑하며 포스팅을 시작한다. EmmetEmmet(자동완성)을 처음 알게 되었을 때의 그 감동을 잊을 수가 없다.Emmet을 알기 전까지는 당연하겠지만 IDE를 실행 시키면 &lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;를 기계적으로 작성하곤 했다. 매번 이렇게 직접 타이핑 하는 것이 교육적 측면에서는 좋다고 생각하지만, 뭔가 스마트하지는 않다고 느끼던 차에 Emmet의 존재를 알게 된 것이다. 앞에서 작성했던 HTML 기본 양식을 Emmet을 사용하면, ! 혹은, html:5만으로 완성할 수가 있다. 조금 집중해서 한다면 0.5초도 걸리지 않을 것이라 확신한다.그 외에도 다양한 단축키를 제공하고 있는데, 예를 들어 아래와 같은 리스트를 작성해야 하는 경우, 12345678910&lt;article&gt; &lt;h1&gt;코드아메바의 구매 예정 도서&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;코드 컴플리트&lt;/li&gt; &lt;li&gt;클린코드&lt;/li&gt; &lt;li&gt;리팩토링&lt;/li&gt; &lt;li&gt;실용주의 프로그래머&lt;/li&gt; &lt;li&gt;프로그래밍 심리학&lt;/li&gt; &lt;/ul&gt;&lt;/article&gt; 예시 코드를 최선을 다해 타이핑 했는데도 3분 가량 소요되었다. 하지만, 같은 코드를 Emmet으로 작성한다면? 1article&gt;h1&#123;코드아메바의 구매 예정 도서&#125;+ul&gt;li*5 이게 끝이다. 30초도 안 걸렸다. 물론, &lt;li&gt;&lt;/li&gt;의 내용은 추가로 작성해야하지만, 이것만으로도 소요시간을 대폭 줄일 수가 있다. 이런 Emmet 공식은 종류가 무척 다양하며 아래의 링크에서 확인할 수 있다. VSCode의 경우 기본적으로 탑재되어 있는 기능인데, 만약 없다면 확장프로그램을 검색해보자. VSCode에서의 Emmet 사용법 Emmet 단축키 모음 참고자료 https://emmet.io/ https://code.visualstudio.com/ 이미지 출처 https://unsplash.com/","categories":[{"name":"tip","slug":"tip","permalink":"http://codeameba.github.io/categories/tip/"}],"tags":[{"name":"tip","slug":"tip","permalink":"http://codeameba.github.io/tags/tip/"},{"name":"vscode","slug":"vscode","permalink":"http://codeameba.github.io/tags/vscode/"},{"name":"emmet","slug":"emmet","permalink":"http://codeameba.github.io/tags/emmet/"},{"name":"단축키","slug":"단축키","permalink":"http://codeameba.github.io/tags/%EB%8B%A8%EC%B6%95%ED%82%A4/"},{"name":"cheat","slug":"cheat","permalink":"http://codeameba.github.io/tags/cheat/"}]},{"title":"웹 사이트의 구조와 웹 접근성","slug":"programming/html-02","date":"2019-04-12T16:00:42.000Z","updated":"2020-02-03T07:47:26.902Z","comments":true,"path":"2019/04/13/programming/html-02/","link":"","permalink":"http://codeameba.github.io/2019/04/13/programming/html-02/","excerpt":"","text":"웹 사이트의 구조웹 사이트는 다음과 같은 세 개의 언어로 이루어진다. HTML: Hyper Text Markup Language를 뜻하며, 웹 페이지의 틀을 잡는 문서 형태의 언어. HTML은 아래와 같은 형태를 지닌다. 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=\"ko-KR\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;HTML의 기본 형태&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;HTML&lt;/h1&gt; &lt;p&gt;여는 태그와 닫는 태그 사이에 내용을 넣는 형태가 일반적&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; CSS: Cascading Style Sheets를 뜻하며, HTML에 종속(Cascade)되어 웹 문서를 꾸며주는 역할을 한다. CSS아래와 같은 형태를 지닌다. HTML의 &lt;head&gt;&lt;/head&gt;가 끝나기 전에 &lt;style&gt;&lt;/style&gt;로 삽입하거나 &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt;처럼 CSS파일을 별도로 만들어 링크를 하기도 한다. 효율성 측면에서 후자를 많이 쓴다. 1234567891011&lt;style&gt;h1 &#123; color: deeppink; font-size: 1.5rem; font-weight: 800;&#125;p &#123; color: darkslategray; font-style: italic;&#125;&lt;/style&gt; JavaScript: HTML과 CSS로만 이루어진 웹 페이지를 ‘정적 페이지’라고 부르며, 여기에 JavaScript가 더해져 ‘동적 페이지’가 된다. 참고로, JAVA와는 아무 관련이 없다. 아래와 같은 형태를 취하며, &lt;head&gt;&lt;/head&gt; 혹은 &lt;body&gt;&lt;/body&gt;에 위치할 수 있지만, 위에서 아래로 한 줄씩 실행되기 때문에 보통 &lt;body&gt;&lt;/body&gt;의 가장 아래에 위치한다. CSS와 마찬가지로 별도의 파일을 만들어 링크할 수 있다. 123&lt;script&gt; alert(\"Hello World!\"); //Hello World! 알림창&lt;/script&gt; 웹 표준(Web Standard)웹 사이트는 W3C(World Wide Web Consortium)가 정한 ‘웹 표준’을 준수하여 제작되어야 하며, 이것은 브라우저의 종류 및 버전에 따른 호환이 가능하도록 제시된 표준 지침으로, 특정 플랫폼이나 기기에 치우치지 않고 동일하게 구현되도록 최적화 하는 것에 의의가 있다. 웹 표준을 준수해야 하는 가장 큰 근거는 ‘웹 접근성(Web Accessibility)’에 있다. 웹 표준 관련 참고 도서: 제프리 젤드만(Jeffrey zeldman)의 웹 표준 가이드 웹 접근성(Web Accessibility)WWW(World Wide Web)의 창시자 팀 버너스 리(Tim Berners-Lee)는, “웹이란, 장애에 구애 받지 않고 모든 사람이 손쉽게 정보를 공유할 수 있는 공간”이라고 정의 하였으며, 이에 기초하여 내부적, 외부적 장애 요인에 무관하게 누구나 이용 가능할 수 있도록 웹 사이트를 설계하는 것이 ‘웹 접근성’을 고려한 설계이다. 관련 포스팅: 웹 접근성과 웹의 본질 - codeAmeba 이미지 출처 https://unsplash.com/","categories":[{"name":"HTML","slug":"HTML","permalink":"http://codeameba.github.io/categories/HTML/"}],"tags":[{"name":"html","slug":"html","permalink":"http://codeameba.github.io/tags/html/"},{"name":"markup","slug":"markup","permalink":"http://codeameba.github.io/tags/markup/"},{"name":"html기초","slug":"html기초","permalink":"http://codeameba.github.io/tags/html%EA%B8%B0%EC%B4%88/"},{"name":"웹 표준","slug":"웹-표준","permalink":"http://codeameba.github.io/tags/%EC%9B%B9-%ED%91%9C%EC%A4%80/"},{"name":"웹 접근성","slug":"웹-접근성","permalink":"http://codeameba.github.io/tags/%EC%9B%B9-%EC%A0%91%EA%B7%BC%EC%84%B1/"},{"name":"web standard","slug":"web-standard","permalink":"http://codeameba.github.io/tags/web-standard/"},{"name":"web accessibility","slug":"web-accessibility","permalink":"http://codeameba.github.io/tags/web-accessibility/"}]},{"title":"웹 접근성과 웹의 본질","slug":"programming/html-01","date":"2019-04-10T16:00:42.000Z","updated":"2020-02-03T07:47:26.902Z","comments":true,"path":"2019/04/11/programming/html-01/","link":"","permalink":"http://codeameba.github.io/2019/04/11/programming/html-01/","excerpt":"","text":"HTML은 의미를 담는 언어HTML은 Hyper Text Markup Language의 약자로 마크업을 담당하는 언어. 즉, 웹 상에서 의미가 있는 내용(Semantic)을 담는 언어라고 할 수 있다.&lt;section&gt;&lt;p&gt;paragraph&lt;/p&gt;&lt;/section&gt; 과 같이 여는 태그와 닫는 태그로 이루어져 있으며, 태그와 태그 사이에 또 다른 태그로 구성된 텍스트, 이미지, 링크 등의 콘텐츠가 위치한다. 따라서 우리가 웹 상에서 얻는 대부분의 유의미한 정보들은 HTML이라고 할 수 있겠다. 여기서 유의미하다는 것은, 단순히 해당 정보가 글인지, 사진인지, 영상인지 등의 정보의 성격을 브라우저에게 알려주는 것에 그치는 것이 아니다. 한 단계 더 나아가 사용자의 UX를 고려한 구조와 더불어 내부적, 외부적 장애요인에 의한 ‘정보 불평등’을 예방하기 위한 ‘웹 접근성’까지 포함하는 것이다. 웹 접근성(Web Accessibility): 월드 와이드 웹 (World Wide Web)을 창시한 팀 버너스 리(Tim Berners-Lee)는 웹이란, '장애에 구애 받지 않고 모든 사람들이 손쉽게 정보를 공유할 수 있는 공간'이라고 정의하였으며, 따라서 웹 콘텐츠를 제작할 때에는 누구나 접근할 수 있도록 제작하여야 한다고 하였다. 웹의 본질‘장애를 겪어본 적이 없다고 생각하는 보통의 사람들은’ 이러한 HTML의 순기능을 간과하기가 쉬운데, 그것은 단순히 내부적 혹은 신체적인 요인으로만 생각하기 때문이다. 외부적 요인까지 확대해서 본다면, 이미 누구나 겪었을 만한 일들이다. 신호가 약한 와이파이, 낮은 버전의 웹 브라우저, 오래된 컴퓨터 등 웹 접근을 방해하는 장애 요인들은 언제나 우리 주변에 도사리고 있다. 게다가 ‘노화’는 모든 사람들이 겪는 장애이기도 하다. 여기서 한 단계 더 나아가 시각, 청각 혹은 또 다른 내부적 장애를 지닌 사람들까지 웹을 통해 원하는 정보를 얻을 수 있도록 하자는 것이 웹의 본질이며, 누구나 쉽게 배울 수 있다는 평을 받는 언어인 HTML만으로도 실현이 가능한 이야기다. 프론트엔드 개발자의 역할 따라서 웹 콘텐츠 제작자들은 시멘틱하게 마크업을 해야 하는 책임이 있다. 웹 접근성을 고려한 시멘틱 마크업 구조를 만들지 않으면 법적인 불이익을 당한다는 것은 아니지만, 더 나은 세상을 만들기 위한 일종의 윤리적, 사회적 책임인 것이다.사실, 나 역시도 내 기준으로만 세상을 바라보고 판단하며 살아왔기 때문에, HTML의 이러한 기능들을 알지도 못 했고, 알았더라도 등한시 했을 것이다. 지금과 같은 생각을 같게 된 계기는 HTML 수업 시간에 선생님이 들려준 짧은 예시 상황이었다. 시각장애인들은 컴퓨터의 음성지원 기능을 통해 정보에 접근하는데, 음성지원 프로그램은 HTML의 시멘틱 태그와 구조적 순서에 큰 영향을 받는다. 만약, 이러한 것들을 고려하지 않은 웹사이트라면 음성지원 기능은 제역할을 하지 못 할 것이다. 가장 간단한 예를 들어 보자면, &lt;title&gt;태그 사이에 들어가는 내용은 해당 웹사이트에 접속했을 때, 음성지원 기능이 가장 먼저 읽게 되는데, 장식을 한다는 이유로 &lt;title&gt;:::::코드아메바::::::&lt;/title&gt; 이런 식으로 만든 경우가 간혹 있다. 이 경우, 음성지원 기능은 “콜론콜론콜론콜론콜론 코드아메마 콜론콜론콜론콜론콜론”이라고 말하게 된다. 물론 이외에도 시멘틱 구조를 고려하지 않은 웹사이트가 야기하는 폐해는 수도 없이 많으며, 이처럼 웹의 본질을 흐리는 웹사이트가 생겨나지 않도록, 웹의 표준화 관련 국제 기구인 월드 와이드 웹 컨소시엄(W3C ; World Wide Web Consortium)에서는 1997년, 웹 접근성 이니셔티브(WAI ; Web Accessibility Initiative)라는 산하 단체를 설립하여 웹 접근성을 전문적으로 연구하기 시작했다. 그 결과 중 하나가 웹 접근성을 위한 지침이다. WAI의 웹 콘텐츠 접근성 지침은 다음과 같다. 인지성(Perceivable)정보와 사용자 인터페이스 요소는 그들이 인지할 수 있도록 사용자에게 표시될 수 있어야 한다. 모든 텍스트가 아닌 콘텐츠에 대체 텍스트를 사람들이 원하는 인쇄, 점자, 음성, 기호 또는 간단 언어 등과 같은 형태로 제공해야 한다.시간을 바탕으로 한 미디어에 대한 대안을 제공해야 한다.정보와 구조의 손실 없이 콘텐츠를 다른 방식(예를 들면 더욱 간단한 형태로)들로 표현할 수 있어야 한다.사용자들이 보다 쉽게 보고 들을 수 있는 전경에서 배경을 분리한 콘텐츠를 만들어야 한다. 운용성(Operable)사용자 인터페이스 요소와 탐색은 운용 가능해야 한다. 키보드로 모든 기능을 사용할 수 있도록 해야 한다.읽기 및 콘텐츠를 사용하는 사용자에게 충분한 시간을 제공해야 한다.알려진 방법으로 발작을 일으킬 수 있는 콘텐츠를 디자인하지 않아야 한다.사용자가 탐색하고, 콘텐츠를 찾고 그들이 어디에 위치하고 있는지를 알 수 있도록 도와주는 방법을 제공해야 한다. 이해성(Understandable)정보와 사용자 인터페이스 운용은 이해할 수 있어야 한다. 텍스트 콘텐츠를 판독하고 이해할 수 있도록 만들어야 한다.웹 페이지의 탑재와 운용을 예측 가능한 방법으로 제작해야 한다.사용자의 실수를 방지하고 수정할 수 있도록 도와야 한다. 견고성(Robust)콘텐츠는 보조 기술을 포함한 넓고 다양한 사용자 에이전트에 의존하여 해석될 수 있도록 충분히 내구성을 가져야 한다. 보조 기술을 포함한 현재 및 미래의 사용자 에이전트의 호환성을 극대화해야 한다. 얼마 전, 팀 버너스 리(Tim Berners-Lee)는 컨퍼런스를 통해 현재의 웹은, 본인이 기대했던 웹의 본질에서 어긋나는 방향으로 가고 있는 것 같아서 안타깝다는 말을 전했다. 장애에 구애 받지 않고 모든 사람들이 손쉽게 정보를 공유할 수 있는 공간으로써의 웹이 하루 빨리 본래의 의미를 되찾기를 바라며, 나 역시도 누구나 당연하게 정보에 접근할 수 있는 웹 사이트를 만들 것을 이 자리를 빌어 다시 한 번 다짐해본다. “코드에 의미를 담는 것으로, 당신 또한 누군가에게 의미 있는 사람이 되기를 희망해본다.” 참고자료 웹 접근성 연구소(http://www.wah.or.kr/Accessibility/define.asp) https://seulbinim.github.io/WSA/accessibility.html#%EC%9B%B9%EC%A0%91%EA%B7%BC%EC%84%B1%EC%9D%98-%EA%B0%9C%EC%9A%94 이미지 출처 https://unsplash.com/","categories":[{"name":"HTML","slug":"HTML","permalink":"http://codeameba.github.io/categories/HTML/"}],"tags":[{"name":"markup","slug":"markup","permalink":"http://codeameba.github.io/tags/markup/"},{"name":"HTML","slug":"HTML","permalink":"http://codeameba.github.io/tags/HTML/"},{"name":"webdev","slug":"webdev","permalink":"http://codeameba.github.io/tags/webdev/"},{"name":"column","slug":"column","permalink":"http://codeameba.github.io/tags/column/"},{"name":"칼럼","slug":"칼럼","permalink":"http://codeameba.github.io/tags/%EC%B9%BC%EB%9F%BC/"}]},{"title":"서른둘, 개발자를 꿈꾸다","slug":"blog/diary-01","date":"2019-04-08T16:00:42.000Z","updated":"2020-02-15T07:26:08.787Z","comments":true,"path":"2019/04/09/blog/diary-01/","link":"","permalink":"http://codeameba.github.io/2019/04/09/blog/diary-01/","excerpt":"","text":"2018년 12월 14일 퇴사 2014년 4월 14일에 입사하여 5년 가까운 시간 동안 몸 담았던 회사를 나왔다. 누군가는 왜 나가냐며 회유하려 했고, 누군가는 나가서 무얼 할 거냐며 조롱인지 걱정인지 알 수 없는 말을 하였으며, 누군가는 뭘 하든 잘 해낼 거라며 속내를 알 수 없는 응원을 해주었다.누군가들에게는 갑작스러웠을 나의 행동이었겠지만, 내 나름대로는 제법 오랫동안 퇴사를 고려하고 있었기에 결심이 어려웠을 뿐, 딱히 갑자기라고는 생각하지 않았다.오히려, 나의 첫 직장이었으며, 갓 입사했을 때에는 10여명이 오순도순 일하던 작은 회사가 강남 땅에 사옥을 짓고, 신입사원 공채를 하는 제법 큰 회사로 성장하는 과정을 지켜본 입장에서 나름의 애정과 미련으로 수차례 퇴사를 미루었다. 서른둘, 개발자를 꿈꾸다 ‘앞으로 무엇을 할 것인가?’ 다양한 사람들로부터 수차례 들었던 질문이다. 대부분은, 서른둘에 5년차 마케터 경력이면 (동종업계)이직은 큰 걱정을 할 필요가 없다는 말을 했다. 그리고, 난 서른둘에 ‘개발자’라는 새로운 꿈을 꾸기 시작했다.인문계 고등학교 문과를 거쳐 4년제 화훼원예학과를 나와 1년 남짓 플로리스트로 지내고, 편집 디자인을 배워 포트폴리오를 들고 면접을 봤던 곳에서 마케터를 했던 내가 개발자가 되겠다니, 내가 생각하기에도 상당히 맥락이 없는 것 같긴 하다. 한편으로는 제법 먼 길을 돌아왔지만 이 모든 과정이 개발자가 되기 위한 과정이 아니었을까 하는 생각도 든다. 왜 개발자인가? 수학이 싫어서 문과를 선택했던 내가 이런 이야기를 하는 것이 나도 믿기지는 않지만, 중학생 시절 호기심에 C++ 관련 서적을 구매했었다. 물론, 당시 나의 보잘 것 없던 끈기로는 앞장을 몇 번 넘겨보는 게 전부였지만 말이다. 그럼에도 긴 시간 동안 이따금씩 나를 흔드는 것은 개발자에 대한 동경이었다. 랩탑의 까만 화면 위로 펼쳐진 알록달록한 코드들(당시에는 VSCode 같은 편리한 도구가 있다는 사실을 몰랐다.)과 현란하게 타이핑하는 손. 그것은 내가 생각하는 ‘가장 멋진 모습 베스트 5’ 안에 항상 들어가는 모습이었다. ‘그런 멋진 직업이 내 직업이 된다면?’ 그 작은 기대와 설렘으로 익숙지 않은 공부를 시작하게 되었다. 프론트엔드 개발자를 꿈꾸며 학원을 다닌지도 벌써 한 달 정도가 지났다. 총 6개월 과정이니 아직 많이 남았다고도 할 수 있겠지만, 배워야 하는 최소한의 지식만 해도 1년치는 될 것 같아서 그다지 긍정적인 상황은 아니라는 게 현실이다. 심지어 구매해놓고 읽지 못한 책이 스무 권은 족히 된다. 당연히 하루가 멀다 하고 야근을 하던 그때보다도 귀가 시간이 늦을 때가 많다. 그럼에도 불구하고 차가운 밤공기가 기분 좋고, 발걸음이 가볍다. 오늘 하루도 충실했다는 만족감에 가슴이 벅찬다.‘왜 개발자가 되려고 하느냐?’는 질문에 ‘멋있어서 되고 싶다’라고 했던 나의 대답은 100% 진심이다. 스스로가 멋있다고 생각하는 일을 하며, 그 일을 하고 있는 내 모습 역시 멋있다고 느끼는 것은 굉장한 동기부여가 된다. 지난 5년간 내 일을 멋지다고 느끼지 못 했던 내가 하는 말이니 믿어도 좋다. 물론, 이상과 현실의 괴리감을 감당하는 것은 각자의 몫이다. “과연 내년 이맘 때의 나는 멋있는 일을 하고 있을까?” 이미지 출처 https://unsplash.com/","categories":[{"name":"생각정리","slug":"생각정리","permalink":"http://codeameba.github.io/categories/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/"}],"tags":[{"name":"developer","slug":"developer","permalink":"http://codeameba.github.io/tags/developer/"},{"name":"개발자","slug":"개발자","permalink":"http://codeameba.github.io/tags/%EA%B0%9C%EB%B0%9C%EC%9E%90/"},{"name":"생각정리","slug":"생각정리","permalink":"http://codeameba.github.io/tags/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/"},{"name":"일기","slug":"일기","permalink":"http://codeameba.github.io/tags/%EC%9D%BC%EA%B8%B0/"},{"name":"퇴사","slug":"퇴사","permalink":"http://codeameba.github.io/tags/%ED%87%B4%EC%82%AC/"},{"name":"꿈","slug":"꿈","permalink":"http://codeameba.github.io/tags/%EA%BF%88/"}]},{"title":"Web Basic TIL(2019.03.25-03.29)","slug":"programming/web-basic-til-04","date":"2019-03-28T16:00:42.000Z","updated":"2020-02-03T07:47:26.950Z","comments":true,"path":"2019/03/29/programming/web-basic-til-04/","link":"","permalink":"http://codeameba.github.io/2019/03/29/programming/web-basic-til-04/","excerpt":"","text":"TIL 정리(2019.03.25-03.29) 모멘텀(momentum)같은 크롬 확장 프로그램을 사용하면서 내가 입력한 것이 어떻게 계속 유지가 되는 것인가 궁금했는데, 오늘 그 이유를 배웠다. 브라우저에는 Local Storage라고 하는 활용하기에 따라 무척 유용한 저장기능이 있었다. 간단하게 사용법도 배웠는데 API와 마찬가지로 많은 연습이 필요할 듯 싶다. 12345678910111213141516171819&lt;script type=\"text/javascript\"&gt; *// 데이터를 사전형으로 저장하기* var content = &#123;&#125;; *// dictionary* content[\"content1\"] = \"1111\"; content[\"content2\"] = \"2222\"; content[\"content3\"] = \"3333\"; console.log(content); *//사전형 변수를 문자열로 형변환* var content_string = JSON.stringify(content); *//문자열이었던 데이터를 다시 사전형으로 형변환* var content_dict = JSON.parse(content_string); for (var key in content_dict) &#123; *//해당 사전형 변수에서 하나의 값을 선택하여 꺼내기* $(\"#\" + key).cal(content_dict[key]); &#125;&lt;/script&gt; 1234567891011121314151617181920212223 &lt;script type=\"text/javascript\"&gt; */***Web storage**쿠키의 단점을 보완하기 위해 나온 저장소**server Session, Client Cookie**localStorage :**sessionStorage :**저장할 때는 저장할 데이터에 대한 키(key) 값**불러올 때는 저장할 때 사용한 키(key) 값을 이용해 불러온다. - getItem***/* var storage_key = \"content\"; $(function() &#123; $(\"#btn_save\").click(function() &#123; localStorage.setItem(storage_key, $(\"#content\").val()); &#125;); $(\"#btn_load\").click(function() &#123; content_data = localStorage.getItem(storage_key); $(\"#content\").val(content_data); &#125;); &#125;); &lt;/script&gt; 각자 원하는 쇼핑몰의 상품정보 페이지를 클로닝 해보라는 과제를 받고, 평소 애용하는 29cm의 상품페이지를 클로닝 했다. 겉 보기에 상당히 미니멀하고 눈에 띄는 요소가 없어서 만만하게 봤었는데, 막상 마우스포인터를 여기 저기에 올려보고 작은 기능 하나까지 꼼꼼하게 살펴보니 의외로 까다로운 기능들이 많아서 애를 먹었다. 결국 모든 기능은 커녕 레이아웃조차 제대로 만들지 못 했다. 아직 정규과정이 시작되지 않아서 그렇다는 핑계를 대고 싶기도 하지만… 그래도 의기소침해지는 것은 어쩔 수가 없는 것 같다. 일전에 배운 로컬스토리지를 활용해서 To Do List를 만들었다. 로컬스토리지에 저장하는 것까지는 비교적 수월했으나 delete를 클릭했을 때 다시 삭제되도록 하는 것은 다소 어려웠다. 그리고, 내용수정까지는 구현하지 못 했다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445 &lt;body&gt; &lt;h1&gt;ToDo&lt;/h1&gt; &lt;form id=\"form-add-todo\" class=\"form-add-todo\"&gt; &lt;input type=\"text\" id=\"new-todo-item\" class=\"new-todo-item\" name=\"todo\" placeholder=\"To Do What?\" autofocus /&gt; &lt;input type=\"submit\" id=\"add-todo-item\" class=\"add-todo-item\" value=\"add\" /&gt; &lt;/form&gt; &lt;form id=\"form-todo-list\"&gt;&lt;ul id=\"todo-list\" class=\"todo-list\"&gt;&lt;/ul&gt;&lt;/form&gt; &lt;script type=\"text/javascript\"&gt; $(document).ready(function() &#123; $(\"#add-todo-item\").click(function() &#123; event.preventDefault(); var todoItem = $(\"#new-todo-item\").val(); $(); $(\"#todo-list\").append( \"&lt;div class='input-group mb-3'&gt;&lt;div class='input-group-prepend'&gt;&lt;li&gt;&lt;input type='checkbox'\" + \" name='todo-item-done'\" + \" class='todo-item-done'\" + \" value='\" + todoItem + \"' /&gt; \" + todoItem + \" &lt;button class='todo-item-delete'&gt;\" + \"X&lt;/button&gt;&lt;/li&gt;&lt;/div&gt;&lt;/div&gt;\" ); $(\"#new-todo-item\").val(\"\"); &#125;); $(\".todo-item-delete\").click(function() &#123; $(this).remove(); &#125;); &#125;);&lt;/script&gt; 3월 마지막 주에는 팀과제가 주어졌다. 팀별로 하나의 주제를 정해 싱글 페이지 사이트를 만드는 것이 과제였다. 우리팀은 ’New York times’에서 영감을 얻어 몇 가지 기능을 추가하여 e-sports 소식들을 담은 ’The Fast Times’를 만들기로 했다. 얼마 전에 배운 git flow를 이용하여 프로젝트를 진행했는데, 어디서 꼬였는지 master branch가 두 개가 되었다. 이를 어쩐담. 브랜치 모양이 영 예쁘지 않아서 결국 레포를 새로 만들었다. 수차례 시뮬레이션을 거쳤지만 여전히 깃을 활용한 협업은 어려운 부분이 많은 것 같다. The Fast Times의 기본적인 레이아웃은 New York Times를 따랐으나 효과나 기능적인 측면에서는 상당히 차별화가 되었다. 팀원 중 한 명은.자바스크립트를 통해 시계를 넣었고, 날씨 API를 가져와서 접속지역에 따른 날씨 정보를 받아올 수 있게 하였다. 또한, 파이썬 크롤링 통해 관련 기사를 보여줄 수 있게 되었다. 또 다른 팀원은 전체적인 레이아웃을 깔끔하게 구성하였으며, 슬라이드 메뉴 등을 구현하였다. 나는 주로 CSS를 활용하여 Carousel을 구현하고, 양쪽의 기사의 경우 마우스를 올렸을 때 카드가 넘어가는 듯한 효과를 줄 수 있도록 Transform을 적용했다. 어찌어찌 마무리는 되었으나, 비교적 나의 기여도가 가장 저조한 것 같아 마음이 무겁다. The Fast Times 링크 The Fast Times","categories":[{"name":"웹기초","slug":"웹기초","permalink":"http://codeameba.github.io/categories/%EC%9B%B9%EA%B8%B0%EC%B4%88/"}],"tags":[{"name":"일기","slug":"일기","permalink":"http://codeameba.github.io/tags/%EC%9D%BC%EA%B8%B0/"},{"name":"til","slug":"til","permalink":"http://codeameba.github.io/tags/til/"},{"name":"TIL","slug":"TIL","permalink":"http://codeameba.github.io/tags/TIL/"},{"name":"Today I Learned","slug":"Today-I-Learned","permalink":"http://codeameba.github.io/tags/Today-I-Learned/"},{"name":"오늘배운것들","slug":"오늘배운것들","permalink":"http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"},{"name":"패스트캠퍼스","slug":"패스트캠퍼스","permalink":"http://codeameba.github.io/tags/%ED%8C%A8%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%8D%BC%EC%8A%A4/"}]},{"title":"Web Basic TIL(2019.03.18-03.22)","slug":"programming/web-basic-til-02","date":"2019-03-21T16:00:42.000Z","updated":"2020-02-03T07:47:26.950Z","comments":true,"path":"2019/03/22/programming/web-basic-til-02/","link":"","permalink":"http://codeameba.github.io/2019/03/22/programming/web-basic-til-02/","excerpt":"","text":"TIL 정리(2019.03.18-03.22) 부트스트랩과 자바스크립트로 로또 번호 생성기를 만들어보았다. 물론, 대부분 구글느님의 도움으로 이루어졌지만, 나름대로의 뿌듯함이 있다. 12345678910111213141516171819202122232425262728293031&lt;script type=\"text/javascript\"&gt; $(function() &#123; $('#lottoOutput').click(function() &#123; $('#lottoNumbers tbody').html(''); // 옵션으로 횟수 선택 var selectCount = $(\"#count option:selected\").val(); for(j=0;j&lt;Number(selectCount);j++) &#123; var original_numbers = []; for(i=1;i&lt;46;i++) &#123; original_numbers.push(i); &#125; var numbers = []; for(i=0;i&lt;6;i++) &#123; var number_index = Math.floor((Math.random() * original_numbers.length)); var get_number = original_numbers[number_index]; numbers.push(get_number); original_numbers.splice(number_index,1); &#125; numbers.sort(function(*a*, *b*)&#123;return a-b&#125;); var row = '&lt;tr&gt;&lt;th scope=\"row\"&gt;'+(j+1)+'&lt;/th&gt;&lt;td&gt;'+numbers[0]+'&lt;/td&gt;&lt;td&gt;'+numbers[1]+'&lt;/td&gt;&lt;td&gt;'+numbers[2]+'&lt;/td&gt;&lt;td&gt;'+numbers[5]+'&lt;/td&gt;&lt;td&gt;'+numbers[4]+'&lt;/td&gt;&lt;td&gt;'+numbers[5]+'&lt;/td&gt;' $('#lottoNumbers tbody').append(row); &#125; &#125;); &#125;); // 프린트 출력 function lottoPrint() &#123; window.print(); &#125;;&lt;/script&gt; 카카오, 네이버 등의 회사마다 개발자를 위한 사이트가 있다는 사실을 알게 되었다. 상당히 유용한 API가 많았는데, 막상 가져다가 써보려 하니 생각처럼 쉽게 되지 않았다. 뭐 하나 기능이라도 추가해보려 하면 제대로 작동 되던 다른 기능 하나가 막히거나 하는 것이 마치 큐브를 맞추는 기분이었다. 부트스트랩의 도움 없이 오로지 CSS만으로 드롭다운 메뉴를 만드는 과제가 주어졌다. 이 간단한 기능에 이토록 긴 코드가 필요할 줄이야. 심지어 제대로 구현하기도 쉽지 않아서 잠시 좌절감을 맛봤다. 그래도 어설프게나마 구현은 했다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121 &lt;style&gt; * &#123; box-sizing: border-box; &#125; li &#123; display: inline-block; &#125; div &#123; text-align: center; &#125; #firstTopSlide &#123; background-color: blue; position: relative; width: 100px; line-height: 25px; display:inline-block; &#125; #secondTopSlide &#123; background-color: blue; position: relative; width: 100px; line-height: 25px; display:inline-block; &#125; #thirdTopSlide &#123; background-color: blue; position: relative; width: 100px; line-height: 25px; display:inline-block; &#125; #firstMenuArea &#123; background-color: red; position: absolute; display: none; top: 30px; width: 100px; height: auto; &#125; #secondMenuArea &#123; background-color: red; position: absolute; display: none; top: 30px; width: 100px; height: auto; left: 112px; &#125; #thirdMenuArea &#123; background-color: red; position: absolute; display: none; top: 30px; width: 100px; height: auto; left: 216px; &#125; .dropMenu &#123; padding: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"firstTopSlide\"&gt; MENU 01 &lt;/div&gt; &lt;div id=\"firstMenuArea\"&gt; &lt;ul class=\"dropMenu\"&gt; &lt;li&gt;content1&lt;/li&gt; &lt;li&gt;content2&lt;/li&gt; &lt;li&gt;content3&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div id=\"secondTopSlide\"&gt; MENU 02 &lt;/div&gt; &lt;div id=\"secondMenuArea\"&gt; &lt;ul class=\"dropMenu\"&gt; &lt;li&gt;content1&lt;/li&gt; &lt;li&gt;content2&lt;/li&gt; &lt;li&gt;content3&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div id=\"thirdTopSlide\"&gt; MENU 03 &lt;/div&gt; &lt;div id=\"thirdMenuArea\"&gt; &lt;ul class=\"dropMenu\"&gt; &lt;li&gt;content1&lt;/li&gt; &lt;li&gt;content2&lt;/li&gt; &lt;li&gt;content3&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;script type=\"text/javascript\"&gt; $(document).ready(function() &#123; $(\"#firstTopSlide\").mouseenter(function() &#123; $(\"#firstMenuArea\").slideDown(); $(\"#firstTopSlide\").mouseleave(function() &#123; $(\"#firstMenuArea\").slideUp(); &#125;); &#125;); $(\"#secondTopSlide\").mouseenter(function() &#123; $(\"#secondMenuArea\").slideDown(); $(\"#secondTopSlide\").mouseleave(function() &#123; $(\"#secondMenuArea\").slideUp(); &#125;); &#125;); $(document).ready(function() &#123; $(\"#thirdTopSlide\").mouseenter(function() &#123; $(\"#thirdMenuArea\").slideDown(); $(\"#thirdTopSlide\").mouseleave(function() &#123; $(\"#thirdMenuArea\").slideUp(); &#125;); &#125;); &#125;); &#125;);&lt;/script&gt; 깃헙에서 제공되는 url을 활용한 hexo라는 블로그 제작 방법을 배웠다. 원하는 url을 얻고 싶어서 그동안 쌓아둔 커밋들이 아깝지만 깃헙 계정을 새로 만들었다. 학원에서 양산된 개발자를 다소 비하하는 말로 ‘코드몽키’라고 하던데, 지금의 나는 그 수준에도 못 미친다고 생각해서 ‘코드아메바(codeAmeba)’라는 ID로 정했다. 비록 시작은 미미했으나 그 끝은 창대하길 바란다.","categories":[{"name":"웹기초","slug":"웹기초","permalink":"http://codeameba.github.io/categories/%EC%9B%B9%EA%B8%B0%EC%B4%88/"}],"tags":[{"name":"일기","slug":"일기","permalink":"http://codeameba.github.io/tags/%EC%9D%BC%EA%B8%B0/"},{"name":"til","slug":"til","permalink":"http://codeameba.github.io/tags/til/"},{"name":"TIL","slug":"TIL","permalink":"http://codeameba.github.io/tags/TIL/"},{"name":"Today I Learned","slug":"Today-I-Learned","permalink":"http://codeameba.github.io/tags/Today-I-Learned/"},{"name":"오늘배운것들","slug":"오늘배운것들","permalink":"http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"},{"name":"패스트캠퍼스","slug":"패스트캠퍼스","permalink":"http://codeameba.github.io/tags/%ED%8C%A8%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%8D%BC%EC%8A%A4/"}]},{"title":"Web Basic TIL(2019.03.11-03.15)","slug":"programming/web-basic-til-03","date":"2019-03-14T16:00:42.000Z","updated":"2020-02-03T07:47:26.950Z","comments":true,"path":"2019/03/15/programming/web-basic-til-03/","link":"","permalink":"http://codeameba.github.io/2019/03/15/programming/web-basic-til-03/","excerpt":"","text":"Instagram에서 이 게시물 보기 Seoul, 2019 . . #fubiz #somewheremagazine #inspirationcultmag #dreamermagazine #fujifilm_kr #fujifeed #xe3 #streetphotography #life_is_street #ourstreets #minimalzine #gominimalmag #moodygrams #streetleaks #lensculture #imaginarymagnitude #fujifilm_global 정수영(Sooyoung Jeong)(@aprilgreenery)님의 공유 게시물님, 2019 2월 6 10:06오전 PST TIL 정리(2019.03.11-03.15) 제이쿼리며, 부트스트랩이며, 쏟아지는 정보의 홍수 속에 정신이 혼미해졌다. 앞으로 배울 것들을 가볍게 훑는 느낌이라더니… 새롭게 각오를 다지게 되었다. 구글의 위대함을 몸소 느낀 날이었다. 아무것도 모르는 상태에서 unsplash.com을 클로닝하려니 믿을 것은 구글밖에 없었다. 그 결과 많이 허술하긴 하지만 나름 성공적으로 첫 과제를 마쳤다. 단순히 비주얼만 따라하려고 했다면 조금 더 쉬웠을 테지만, 상단에 고정된 메뉴라던가, 백그라운드 이미지 위의 검색창 등을 최대한 원본에 가깝게 구현하는 것에 집착하다보니 시간이 다소 부족한 감이 있었다. 연산자 산술 연산자 : +, - , , / , %, * 문자 연산자 : + ’숫자 -&gt; 문자, 문자 -&gt; 숫자’ Type Casting 형변환 프로그래밍 입력, 저장, 처리, 출력에 관한 문법 입력: prompt, form tag 저장: 변수, 쿠키, 웹 스토리지, 데이터베이스 처리: 연산, 분기, 반복 출력: console.log, 화면에 DOM 추가 변수: 어떤 값을 담는 그릇 그릇: 종류 - 일반, 원시 -&gt; 숫자, 문자, 불대수 여러가지 여러종류를 담는 그릇: 배열(리스트, 딕트, 튜플) 변수에 무엇을 담아서 사용하는 이유 - 컴퓨터는 암산 불가 변수: 만들기,값 읽기, 값 바꾸기, 값 사용(연산의 피연산자, 함수의 매개변수) a = 10; a라는 이름을 가진 저장공간을 만들고, 거기에 값을 저장(할당)한다. = 할당 연산자라고 함, +,-,*,/ =의 의미 일반적으로는 같다지만, 프로그래밍에서는 “저장한다”의 의미. ==을 같다의 의미로 사용. 숫자, 불리언값 등은 값을 그대로 쓴다. 문자열은 홑따옴표 혹은 쌍따옴표로 감싼다. 왜? : 문자열을 따옴표 없이 표기하면, 변수 혹은 예약어 등과 혼동될 수 있음.name = “Ja\\nke” &lt;—escaping 처리 - escape문자, 특별한 용도로 사용. 변수명을 만드는 방법 숫자는 변수 이름 맨 앞에 사용하지 않음. 특수문자는 _(언더바)만 사용. 변수명은 대소문자를 구분한다. 명사, 동사로 변수명을 작성한다. 예약어는 사용 금지 변수명을 작성하는 방법의 종류 카멜 케이스 : yourName 파스칼 케이스 : YourName 스네이크 케이스 : your_name 헝가리안 표기법 : strNeme, intNumber - 변수명 앞에 어떤 데이터를 저장할 것인지 기록해두는 방법. 프로그래밍 진행 방법 순차: 코드가 위에서 아래로 한줄씩 실행 분기: A를 실행할지 B를 실행할지 선택하는 것(조건에 따라) 반복: A, B 중에서 실행할 코드를 여러번 반복실행하고 싶을 때 조건문 If문은 if - else if - else 키워드로 구성 if : 만약 조건식이 참이라면 해당 부분의 실행구문을 실행하겠다. 딱 한 번만 가능. else if: 그게 아니라 다음 조건식이 참이라면 해당 부분의 실행구문 실행하겠다. 0~무제한 else : 0~11234567if ([조건식]) &#123;[실행구문] 쓰고 싶은 코드 무엇이든 가능&#125; else if ([조건식]) &#123;[실행구문]&#125; else ([조건식]) &#123;[실행구문]&#125; 조건식: 명제 - 참과 거짓을 판별할 수 있는 문장 true, false 라고 표기 - Boolean(bool) 비교구문 12345678a &gt; ba &lt; ba &gt;&#x3D; ba &lt;&#x3D; ba &#x3D;&#x3D; ba &#x3D;&#x3D;&#x3D; b : 종류까지 같냐?a !&#x3D; ba !&#x3D;&#x3D; b : 종류까지 다르냐? 버튼 클릭에 따른 이미지 전환을 과제로 받았다. 방식에 제한은 없었으며, 나는 제이쿼리를 사용해 버튼 클릭 시 &lt;img src=“”&gt;가 바뀌도록 해봤다. 코드는 다음과 같다. 이 자리를 빌어 stack over flow에 경의를 표한다. 1234567891011121314151617181920212223242526&lt;script type=\"text/javascript\"&gt; $(\".btn_cat1\").click(function() &#123; $(\".photo\").attr( \"src\", \"https://vignette.wikia.nocookie.net/pokemon/images/5/52/%ED%94%BC%EC%B9%B4%EC%B8%84_%EA%B3%B5%EC%8B%9D_%EC%9D%BC%EB%9F%AC%EC%8A%A4%ED%8A%B8.png/revision/latest?cb=20170405000019&amp;path-prefix=ko\" ); &#125;); $(\".btn_cat2\").click(function() &#123; $(\".photo\").attr( \"src\", \"https://vignette.wikia.nocookie.net/pokemon/images/a/aa/%EA%BC%AC%EB%B6%80%EA%B8%B0_%EA%B3%B5%EC%8B%9D_%EC%9D%BC%EB%9F%AC%EC%8A%A4%ED%8A%B8.png/revision/latest?cb=20170404233452&amp;path-prefix=ko\" ); &#125;); $(\".btn_cat3\").click(function() &#123; $(\".photo\").attr( \"src\", \"https://vignette.wikia.nocookie.net/pokemon/images/5/5e/%ED%8C%8C%EC%9D%B4%EB%A6%AC_%EA%B3%B5%EC%8B%9D_%EC%9D%BC%EB%9F%AC%EC%8A%A4%ED%8A%B8.png/revision/latest?cb=20170404233005&amp;path-prefix=ko\" ); &#125;); $(\".btn_cat4\").click(function() &#123; $(\".photo\").attr( \"src\", \"https://vignette.wikia.nocookie.net/pokemon/images/5/57/%EC%9D%B4%EC%83%81%ED%95%B4%EC%94%A8_%EA%B3%B5%EC%8B%9D_%EC%9D%BC%EB%9F%AC%EC%8A%A4%ED%8A%B8.png/revision/latest?cb=20170404232618&amp;path-prefix=ko\" ); &#125;);&lt;/script&gt; alert창으로 숫자를 입력 받아 섭씨를 화씨로, 화씨를 섭씨로 변환하는 프로그램을 만들어봤다. 코드는 다음과 같다.123456789101112131415161718192021222324252627282930313233343536373839&lt;script type=\"text/javascript\"&gt; var turnC = 0; var turnF = 0; while (true) &#123; console.log(\"번호를 선택하세요.\"); console.log(\"1. 섭씨를 화씨로 변환\"); console.log(\"2. 화씨를 섭씨로 변환\"); console.log(\"3. 프로그램 종료\"); var menu = prompt(\"메뉴를 선택하세요.\", \"\"); if (menu == \"3\") &#123; break; &#125; if (menu == \"1\") &#123; if (turnF == 0) &#123; tempC = prompt(\"섭씨 온도를 입력해주세요.\", \"\"); tempC = Number(tempC); tempF = (tempC * 1.8 + 32).toFixed(1); console.log(tempF + \"°F\"); saveC = tempC; turnC++; &#125; else if (turnF == 1) &#123; console.log(tempC + \"°C는 \" + saveF + \"°F\"); turnF = 0; &#125; &#125; else if (menu == \"2\") &#123; if (turnC == 0) &#123; tempF = prompt(\"화씨 온도를 입력해주세요.\", \"\"); tempF = Number(tempF); tempC = ((tempF - 32) / 1.8).toFixed(1); console.log(tempC + \"°C\"); saveF = tempF; turnF++; &#125; else if (turnC == \"1\") &#123; console.log(tempF + \"°F는 \" + saveC + \"°C\"); turnC = 0; &#125; &#125; &#125;&lt;/script&gt; 다양한 자바스크립트의 Method를 배웠다. window 객체: 브라우저를 제어하는 객체 .open(주소): 새로운 창을 연다. .close(): 현재 창을 닫는다. .print() : 현재 창을 출력하는 다이얼로그를 나타낸다. alert(): 경고 메시지 출력변수 = prompt(“질문”,”기본값”): 입력받기 변수 = confirm(“확인 문구”): true, false 값을 반환 받는다. .innerHeight, .innerWidth : 창(보이는 영역)의 높이와 너비 pageXOffset, . pageYOffset : 스크롤된 수치resizeTo(w, h), resizeBy(w, h): By +,-.scrollTo(x, y), .scrollBy(x, y): By +,- 꾸준히 여러번 실행할 코드 12345변수 = window.setInterval(function() &#123;[실행할 코드]&#125;, 1000);window.clearInterval(변수); 한 번 실행할 코드 12345변수 = window.setTimeout(function() &#123;[실행할 코드]&#125;, 1000);window.clearTimeout(변수); screen.height, width : 화면 해상도 크기 screen.availHeight, availWidth: 실제 이용 가능한 화면 영역 history.length : 쌓여있는 페이지 갯수 .back() : 이전 페이지 .forword() : 다음 페이지 .go(정수): +,- 페이지 이동 navigator 정보를 이용해서 고객 분석에 사용 navigator.platform : 운영체제 종류 navigator.userAgent : 브라우저 종류 navigator.language : 언어 종류12navigator.geolocation.getCurrentPosition(function(*position*) &#123;console.log(position.coords.latitude, position.coords.latitude);&#125;): 위치 확인 location.href : 현재 주소 location.protocol : http 메서드 location.host : 도메인 주소 location.pathname : 경로 location.search : query string location.hash : anchor 값 location.href = “주소” :페이지 이동 location.replace(“주소”) : 페이지 갈아끼기 location.reload() : 페이지 새로고침 Jquery와 form 태그의 활용 123456789101112131415161718192021222324252627282930 &lt;script type=\"text/javascript\"&gt; /*form 태그의 입력완료 이벤트: submit각 input 태그의 값은 $(요소).val() 읽고변경하려면 $(요소).val(값) 으로 하면 된다.*/ $(document).ready(function() &#123; $(\"form\").submit(function() &#123; e.preventDefault(); alert($('input[name=\"id\"]').val()); $('input[name=\"name\"]').val($('input[name=\"id\"]').val()); &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--form: 사용자가 입력받기 위해 사용하는 태그action: 입력받은 내용을 전달할 페이지method: get, post--&gt; &lt;form class=\"\" action=\"#\" method=\"post\"&gt; &lt;input type=\"text\" name=\"name\" value=\"\" /&gt; &lt;input type=\"text\" name=\"id\" value=\"\" /&gt; &lt;input type=\"password\" name=\"password\" value=\"\" /&gt; &lt;input type=\"submit\" name=\"\" value=\"가입완료\" /&gt; &lt;/form&gt; &lt;/body&gt; jquery에서 각 이벤트는 $(요소).eventName(실행할 함수); $(요소).attr(‘속성이름’); : 해당 요소의 속성값을 읽어온다. $(요소).show(), .hide(), .toggle(): 요소를 보이거나 숨긴다. $(요소).addClass(‘클래스이름’), .removeClass(‘클래스이름’),.toggleClass(‘클래스이름’) : 클래스를 추가 삭제 하는 역할 컨텐츠 변경 - 값을 변경 $(요소).html(), .text() : 내부 값 읽기 $(요소).html(값), .text(값) : 내부 값을 변경 컨텐츠 변경 - 값을 추가 $(요소).html($(요소).html()+”추가깂”) $(요소).append(“추가값”) $(요소).prepend(“추가값”) 값을 삭제 $(요소).remove() : 요소를 제거 $(요소).remove(‘selector’) : 해당 요소의 자식 노드 중 selector에 해당하는 자식을 삭제 css 요소로 삭제 $(요소).css(‘display’, ‘block’); $(요소).css({‘display’:’block’,’color’:’red’});","categories":[{"name":"웹기초","slug":"웹기초","permalink":"http://codeameba.github.io/categories/%EC%9B%B9%EA%B8%B0%EC%B4%88/"}],"tags":[{"name":"일기","slug":"일기","permalink":"http://codeameba.github.io/tags/%EC%9D%BC%EA%B8%B0/"},{"name":"til","slug":"til","permalink":"http://codeameba.github.io/tags/til/"},{"name":"TIL","slug":"TIL","permalink":"http://codeameba.github.io/tags/TIL/"},{"name":"Today I Learned","slug":"Today-I-Learned","permalink":"http://codeameba.github.io/tags/Today-I-Learned/"},{"name":"오늘배운것들","slug":"오늘배운것들","permalink":"http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"},{"name":"패스트캠퍼스","slug":"패스트캠퍼스","permalink":"http://codeameba.github.io/tags/%ED%8C%A8%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%8D%BC%EC%8A%A4/"}]},{"title":"Web Basic TIL(2019.03.04-03.08)","slug":"programming/web-basic-til-01","date":"2019-03-07T16:00:42.000Z","updated":"2020-02-03T07:47:26.950Z","comments":true,"path":"2019/03/08/programming/web-basic-til-01/","link":"","permalink":"http://codeameba.github.io/2019/03/08/programming/web-basic-til-01/","excerpt":"","text":"Instagram에서 이 게시물 보기 집사야 왜 답지 않게 공부를 하냥(feat. 둥이둥절) . . #일상스냅 #ordinaryday #묘물사진 #portrait #냥스타그램 #livingwithcats #holidayvibes #fubiz #somewheremagazine #inspirationcultmag #dreamermagazine #sonyimagegallery #sonyalpha #소니이미지갤러리 #a7m3 #sel55f18z #minimalzine #gominimalmag #moodygrams #catsofinstagram #morningvibes #whatareyoudoing #coding #peoplewhocode 정수영(Sooyoung Jeong)(@aprilgreenery)님의 공유 게시물님, 2018 12월 25 10:04오후 PST TIL 정리(2019.03.04-03.08) 설렘과 걱정으로 점철되었던 개강 첫날이 지났다. 여느 교실의 첫날이 그렇듯 어색하고 무거운 공기 속에 나 역시 다소 긴장이 되었다. 그래도 교실을 가득 채운 폭 넓은 연령대의 많은 사람들이 모두 같은 목적을 갖고 있다는 점에서 묘한 동질감이 느껴졌다. 이번 기수부터 기존 4개월 과정에서 6개월 과정으로 기간이 늘었다고 한다. 또한 커리큘럼에도 대폭 변화가 있다고 하는데, 어떨지는 아직 잘 모르겠다. 터미널 명령어(CLI)와 깃(git) 사용법을 배웠다. 개강 전, 구글링으로 혼자 해보려 애쓰다가 여러모로 고생만 했던 것들이라 조심스러웠는데, 생각보다 쉽게 되는 바람에 조금 억울한 기분이 들었다. 이전 기수까지는 없다가 새롭게 생긴 과정을 통해 앞으로 배워야할 내용들을 한 달에 걸쳐 전반적으로 살펴본다고 한다. 본인이 따라하고 싶은 웹사이트의 내부 구조를 알아보라는 과제를 받았다. 이전부터 애용하던 무료 이미지 사이트인 unsplash.com으로 정하고 어떤 태그들이 이용되었는지 살펴봤다. 그 과정에서 크롬의 다양한 확장프로그램을 알게 되었고 상당히 유용한 툴들을 설치했다. unsplash.com의 주요 태그라이브러리 React 1. HTML html : HTML문서의 가장 기본이 되는 태그 head : HTML문서의 시작. title, script, style, meta 등의 태그를 포함한다. meta : 웹페이지에서는 보이지 않는 정보를 제공하는 태그 link : 외부 리소스를 현재 문서에 연결한다. style : 특정 태그의 색상이나 형태 등의 스타일을 정의한다. script : JavaScript를 추가할 때 사용한다. title : 웹 페이지의 제목을 나타내며, 브라우저의 탭에 나타남. body : 텍스트, 이미지 등 주요 내용들이 포함되는 태그. div : 영역을 나눌 때 사용하며, 줄 바꿈이 됨(block). header : 웹 사이트의 네비게이션이나 페이지에 대한 정보를 담는 태그. ul : 순서가 없는 목록을 작성할 때 사용하며, 글머리 기호가 붙는다. img : 이미지를 삽입할 때 사용하는 태그로, src를 통해 이미지의 경로를 지정한다. button : 버튼을 만드는 태그. nav : 다른 페이지로 이동하는 링크를 보여주는 태그. span : div와 마찬가지로 영역을 나눌 때 사용하지만, 줄 바꿈이 되지 않음(inline). 2. CSS font-family : 글꼴을 설정하는 속성 margin : 바깥쪽 여백 font-size : 글꼴의 크기 line-height : 줄 높이 조절 @media min-width : 최소 너비 설정 font-weight : 글꼴 굵기 설정 text-transform : 대문자 혹은 소문자로 바꾸는 속성 text-decoration : 선으로 텍스트를 꾸밀 수 있는 속성 letter-spacing : 자간 설정 text-shadow : 글자에 그림자 효과 overflow : 내용이 요소의 크기를 벗어났을 때 처리 방법을 정하는 속성 white-space : 공백 처리 방법을 정하는 속성 float : 요소를 정렬할 때 사용하는 속성 display : 요소가 보여지는 방법을 정하는 속성. 주로 4가지 방법이 쓰임. none(보이지 않음), block(블록 박스), inline(인라인 박스), inline-block(블록과 인라인의 중간 형태) vertical-align : 텍스트를 수직으로 정렬하는 속성. 블록 요소에는 적용이 안 됨. clear : float 속성이 적용된 요소를 처리할 때 사용. max-width : 최대 너비 설정 padding : 안쪽 여백 background-color : 배경색 지정 transition : 속성의 전환을 부드럽게 표현함 visibility : 태그의 가시성을 지정함. visible(보임), hidden(숨김), collapse(겹침), inherit(기본값, 부모 요소의 값을 상속) opacity : 투명도 설정","categories":[{"name":"웹기초","slug":"웹기초","permalink":"http://codeameba.github.io/categories/%EC%9B%B9%EA%B8%B0%EC%B4%88/"}],"tags":[{"name":"일기","slug":"일기","permalink":"http://codeameba.github.io/tags/%EC%9D%BC%EA%B8%B0/"},{"name":"til","slug":"til","permalink":"http://codeameba.github.io/tags/til/"},{"name":"TIL","slug":"TIL","permalink":"http://codeameba.github.io/tags/TIL/"},{"name":"Today I Learned","slug":"Today-I-Learned","permalink":"http://codeameba.github.io/tags/Today-I-Learned/"},{"name":"오늘배운것들","slug":"오늘배운것들","permalink":"http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"},{"name":"패스트캠퍼스","slug":"패스트캠퍼스","permalink":"http://codeameba.github.io/tags/%ED%8C%A8%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%8D%BC%EC%8A%A4/"}]}]}