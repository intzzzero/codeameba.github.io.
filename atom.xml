<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AmebaLab</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://codeameba.github.io/"/>
  <updated>2020-05-25T09:16:30.190Z</updated>
  <id>http://codeameba.github.io/</id>
  
  <author>
    <name>Sooyoung Jeong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[TIL] CSS 박스 모델(Box Model)을 알아보자</title>
    <link href="http://codeameba.github.io/2020/05/25/programming/css-box-model/"/>
    <id>http://codeameba.github.io/2020/05/25/programming/css-box-model/</id>
    <published>2020-05-25T09:15:00.000Z</published>
    <updated>2020-05-25T09:16:30.190Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CSS의-기본이자-핵심은-BOX"><a href="#CSS의-기본이자-핵심은-BOX" class="headerlink" title="CSS의 기본이자 핵심은 BOX"></a>CSS의 기본이자 핵심은 BOX</h2><p>CSS에서 가장 기본적이자 가장 중요한 개념은 단연 <strong>박스 모델(Box model)</strong>이라고 할 수 있겠다. 이것을 모르면 절대 웹 페이지의 레이아웃을 구성할 수가 없다. 박스 모델은 아래의 그림과 같다.</p><img src="/images/css-box-model.jpg"><p>Content는 내용, Padding은 안쪽 여백, Border는 테두리, Margin은 바깥 여백을 말한다. 이것들이 웹 페이지의 레이아웃을 정하는 가장 기본적인 요소들이라고 할 수 있다. </p><img src="/images/box-model-screenshot.jpg"><p>아무 웹 페이지에서라도 개발자 도구를 실행 시키면 쉽게 확인할 수 있는데, 이를 통해 웹 페이지를 구성하는 모든 것이 결국 박스의 집합이라는 사실을 알 수 있다.</p><blockquote><p><strong>개발자 도구 실행 단축키</strong></p><ul><li>윈도우: F12</li><li>맥: option + command + i</li></ul></blockquote><h2 id="BOX를-다루는-법"><a href="#BOX를-다루는-법" class="headerlink" title="BOX를 다루는 법"></a>BOX를 다루는 법</h2><p>박스를 이루는 각각의 요소(padding, border, margin)는 크기 임의로 조정할 수 있다. CSS의 문법을 따르며 다음과 같이 작성한다. 물론, 기본적으로 HTML 문서에 종속(Cascade)되어 있기 때문에, HTML 문서 내의 <code>&lt;style&gt;&lt;/style&gt;</code> 태그 사이에 작성하거나 별도의 CSS 파일을 만들어 HTML 파일에 링크를 해야 한다. 링크된 HTML 문서에 <code>&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</code>가 있다는 가정 하에 다음과 같이 padding과 border에 값을 지정해보겠다.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: deeppink;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">3px</span> solid black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그러면, 다음과 같은 형태의 박스를 확인할 수 있다. 가로, 세로 값을 지정하지 않았기 때문에 <code>&lt;div&gt;</code>의 기본값인 block이 적용되어 화면 전체를 차지하며, 기본 margin이 적용되어 가장자리에 여백이 있는 것을 확인할 수 있다.</p><img src="/images/class-box-02.jpg"><p>마찬가지로 margin에도 임의의 값을 지정할 수 있으며, 기본으로 주어진 8px의 margin을 제거할 수도 있다.</p><h2 id="box-sizing"><a href="#box-sizing" class="headerlink" title="box-sizing"></a>box-sizing</h2><img src="/images/box-sizing.jpg"><p>위의 BOX 01과 BOX 02의 사이즈는 같은가 다른가? 놀랍게도 같은 크기다. 좀 더 자세히 말하자면, 눈에 보이는 사이즈는 다르지만, 실제 적용된 너비와 높이는 동일하다. 코드는 아래와 같다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    div &#123;</span><br><span class="line">        width: 300px;</span><br><span class="line">        height: 300px;</span><br><span class="line">        margin: 30px auto;</span><br><span class="line">        padding: 15px;</span><br><span class="line">        text-align: center;</span><br><span class="line">        font-size: 3rem;</span><br><span class="line">        font-weight: 800;</span><br><span class="line">        box-shadow: 3px 3px 15px gray;</span><br><span class="line">        border: 3px solid black;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.box-01</span> &#123;</span></span><br><span class="line">        background: palevioletred;</span><br><span class="line">        box-sizing: border-box;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.box-02</span> &#123;</span></span><br><span class="line">        background: paleturquoise;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>차이점을 발견했는가? 그렇다. BOX 01에는 <code>box-sizing: border-box;</code>가 적용되어 있다. 이것은 <strong>지정된 박스 크기(width, height)에 border와 padding이 포함된 형태</strong>로 나타나며, 위의 예시에서 볼 수 있듯이 두 박스가 모두 <code>padding: 15px</code>을 갖고 있지만 보여지는 크기가 다르다.</p><p>쉽게 이해하려면, border와 padding의 값은 적용되지 않는다고 생각하면 좋다. 하지만, ‘내부에 포함되었을 뿐, 사라진 것은 아니라는 점을 명심하자.’ 이러한 특성을 지닌 <code>border-box</code>를 사용하는 이유는 <strong>테두리(border나 여백(padding)에 상관 없이 예측 가능한 크기의 박스를 얻기 위함</strong>이다.</p><p><code>border-box</code> 외에도 다음과 같은 속성값이 존재한다.</p><ul><li><code>content-box</code>: 기본값</li><li><code>padding-box</code>: 박스의 크기(width, height)에 border와 margin을 제외한 padding까지만 포함한다.</li></ul><p>각각의 차이점을 쉽게 이해할 수 있는 예시를 들어보겠다. 아래와 같은 박스가 있다고 쳤을 때,</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">width</span>: 300<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">height</span>: 300<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">border</span>: 5<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-tag">black</span>;</span><br><span class="line"><span class="selector-tag">padding</span>: 10<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">margin</span>: 10<span class="selector-tag">px</span>;</span><br></pre></td></tr></table></figure><p>각 <code>box-sizing</code>값에 따라 실제로 차지하는 영역은 다음과 같다.<br><strong>content-box(기본값)</strong>: width: 350px, height: 350px<br><strong>padding-box</strong>: width: 320px, height: 320px<br><strong>border-box</strong>: width: 330px, height: 330px</p><img src="https://images.unsplash.com/photo-1515378791036-0648a3ef77b2?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1950&q=80"><p><strong>참고:</strong><br>    - <a href="https://developer.mozilla.org/ko/docs/Web/CSS/box-sizing" target="_blank" rel="external nofollow noopener noreferrer">box-sizing - CSS: Cascading Style Sheets | MDN</a>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CSS의-기본이자-핵심은-BOX&quot;&gt;&lt;a href=&quot;#CSS의-기본이자-핵심은-BOX&quot; class=&quot;headerlink&quot; title=&quot;CSS의 기본이자 핵심은 BOX&quot;&gt;&lt;/a&gt;CSS의 기본이자 핵심은 BOX&lt;/h2&gt;&lt;p&gt;CSS에서 가장 기
      
    
    </summary>
    
    
      <category term="CSS" scheme="http://codeameba.github.io/categories/CSS/"/>
    
    
      <category term="CSS" scheme="http://codeameba.github.io/tags/CSS/"/>
    
      <category term="박스모델" scheme="http://codeameba.github.io/tags/%EB%B0%95%EC%8A%A4%EB%AA%A8%EB%8D%B8/"/>
    
      <category term="box model" scheme="http://codeameba.github.io/tags/box-model/"/>
    
  </entry>
  
  <entry>
    <title>[TIL] CSS의 상속(Inheritance)에 대해 알아보자</title>
    <link href="http://codeameba.github.io/2020/05/25/programming/css-inherit/"/>
    <id>http://codeameba.github.io/2020/05/25/programming/css-inherit/</id>
    <published>2020-05-25T08:15:42.000Z</published>
    <updated>2020-05-25T08:23:03.382Z</updated>
    
    <content type="html"><![CDATA[<h2 id="상속-Inheritance-이란"><a href="#상속-Inheritance-이란" class="headerlink" title="상속(Inheritance)이란?"></a>상속(Inheritance)이란?</h2><p>CSS에는 상속이라는 개념이 있다. 말 그대로 부모 요소(Element)의 속성값(Value)을 그대로 물려받는다는 의미인데, 모든 속성값에 상속이 적용되는 것은 아니기 때문에 처음 상속을 배웠을 때 다소 어렵게 느꼈던 기억이 있다.<br>‘백문이불여일견’이랬으니, 우선 아래의 코드와 결과를 확인해보자.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.first</span> &#123;</span></span><br><span class="line">            color: deeppink;</span><br><span class="line">            background-color: rgb(49, 49, 49);</span><br><span class="line">            width: 500px;</span><br><span class="line">            height: 500px;</span><br><span class="line">            font-size: 2rem;</span><br><span class="line">            margin: 150px auto;</span><br><span class="line">            box-shadow: 3px 3px 10px gray;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"first"</span>&gt;</span></span><br><span class="line">        이것은 부모</span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"second"</span>&gt;</span></span><br><span class="line">            이것은 자식</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><img src="/images/css-inherit-box.jpg"><p>코드에서 볼 수 있듯이 first의 하위 태그의 클래스가 second인데, CSS는 first에만 적용했음에도 second까지 변했다. 이것이 CSS의 상속을 단적으로 보여주는 예라고 할 수 있다.</p><p>물론 모든 속성이 상속 되지는 않는데, 이는 개발자도구를 실행해보면 아래와 같이 쉽게 확인할 수가 있다.</p><img src="/images/css-inherit.jpg"><p><code>Inherited form div.first</code>라고  명시된 곳을 보면 어떤 속성값들이 상속 되었는지 알 수가 있는데, 그 중에서도 활성화 되어있는 <code>color</code>와 <code>fort-size</code>가 second에 상속, 적용되었다.</p><p>이를 통해 우리가 깨달을 수 있는 것은, 상속이 되어야 편한 속성값들만 상속이 된다는 점이다. 결론적으로, <strong>상속이 있는 이유는 생산성을 높이기 위함</strong>이라고 이해할 수가 있다.  만약, 모든 속성값이 상속 된다면,</p><img src="/images/css-inherit-box2.jpg"><p>이러한 결과가 나왔을 것이다. CSS를 다뤄봤다면 잘 알 테지만, 상속된 속성값 중 필요 없는 것들을 제거 하는 일에 상당한 시간을 할애하게 될 것이다.</p><p><strong>모든 속성값 상속 후 필요 없는 속성값 제거 VS 필요한 속성값 추가</strong><br>둘 중 무엇이 더 효율적일지는 곰곰이 생각해보면 누구나 알 수 있을 것이다. 아래와 같이 상속 되지 않는 속성값은 따로 추가하면 되는 것이고, 이미 상속된 속성값 또한 자식 요소에 부여한 속성값이 더 우선 적용 되기 때문에 손쉽게 변경이 가능하다.</p><p>그리고, 상속이 되지 않는 속성을 강제로 상속 시키고 싶을 때에는, 아래의 코드에서 <code>margin</code>과 같이 속성값으로 <code>inherit</code>을 부여하면 상속이 된다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.first</span> &#123;</span></span><br><span class="line">            color: deeppink;</span><br><span class="line">            background-color: rgb(49, 49, 49);</span><br><span class="line">            width: 500px;</span><br><span class="line">            height: 500px;</span><br><span class="line">            font-size: 2rem;</span><br><span class="line">            margin: 150px auto;</span><br><span class="line">            box-shadow: 3px 3px 10px gray;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.second</span> &#123;</span></span><br><span class="line">            color: lime;</span><br><span class="line">            background-color: brown;</span><br><span class="line">            margin: inherit;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"first"</span>&gt;</span></span><br><span class="line">        이것은 부모</span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"second"</span>&gt;</span></span><br><span class="line">            이것은 자식</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><img src="/images/css-inherit-box3.jpg"><p>상속이 되는 속성값과, 되지 않는 속성값은 아래의 링크에서 자세히 확인할 수 있으니 참고하길 바란다.</p><p>링크 바로가기: <a href="https://www.w3.org/TR/CSS21/propidx.html" target="_blank" rel="external nofollow noopener noreferrer">Full property table</a></p><p><strong>참고:</strong></p><ul><li><a href="https://developer.mozilla.org/ko/docs/Web/CSS/inheritance" target="_blank" rel="external nofollow noopener noreferrer">상속 - CSS: Cascading Style Sheets | MDN</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;상속-Inheritance-이란&quot;&gt;&lt;a href=&quot;#상속-Inheritance-이란&quot; class=&quot;headerlink&quot; title=&quot;상속(Inheritance)이란?&quot;&gt;&lt;/a&gt;상속(Inheritance)이란?&lt;/h2&gt;&lt;p&gt;CSS에는 상속
      
    
    </summary>
    
    
      <category term="CSS" scheme="http://codeameba.github.io/categories/CSS/"/>
    
    
      <category term="tip" scheme="http://codeameba.github.io/tags/tip/"/>
    
      <category term="css" scheme="http://codeameba.github.io/tags/css/"/>
    
      <category term="inherit" scheme="http://codeameba.github.io/tags/inherit/"/>
    
      <category term="상속" scheme="http://codeameba.github.io/tags/%EC%83%81%EC%86%8D/"/>
    
  </entry>
  
  <entry>
    <title>[TIL] 문자열 메소드의 활용</title>
    <link href="http://codeameba.github.io/2020/05/23/programming/string-method/"/>
    <id>http://codeameba.github.io/2020/05/23/programming/string-method/</id>
    <published>2020-05-23T10:12:42.000Z</published>
    <updated>2020-05-24T09:18:11.829Z</updated>
    
    <content type="html"><![CDATA[<p>String 메서드 중에는 정규표현식을 활용하면 보다 유용한 경우가 많다.</p><h2 id="search"><a href="#search" class="headerlink" title="search"></a>search</h2><p>인수로 전달한 정규표현식과 일치한 최초 문자열의 첫 번째 문자 위치를 반환하며, 일치하는 문자가 없으면 -1 반환한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> randomString = <span class="string">'Porta Tortor Mollis sit Condimentum Ligula'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(randomString.search(<span class="regexp">/sit/</span>)); <span class="comment">// 20</span></span><br><span class="line"><span class="built_in">console</span>.log(randomString.search(<span class="regexp">/a/</span>)); <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(randomString.search(<span class="regexp">/apple/</span>)); <span class="comment">// -1</span></span><br></pre></td></tr></table></figure><h2 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h2><p>첫 번째 인수로 받은 문자열을 검색하여 두 번째 인수로 받은 문자열로 교체한다.<br><strong>원본 문자열을 수정하지 않음.</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> randomString = <span class="string">'Porta Tortor Mollis sit Condimentum Ligula'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(randomString.replace(<span class="regexp">/a/</span>, <span class="string">'b'</span>)); <span class="comment">// Portb Tortor Mollis sit Condimentum Ligula</span></span><br></pre></td></tr></table></figure><p><code>g</code> 플래그를 설정하지 않으면 첫 문자만 교체함. <code>replace</code> 두 번째 인수로 함수를 넘길 수도 있음.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> personalInfo = <span class="string">'Jane, jane@example.com, 010-1234-5678'</span>;</span><br><span class="line"><span class="keyword">let</span> result = personalInfo.replace(<span class="regexp">/0(\d&#123;1,4&#125;-\d&#123;1,4&#125;-\d&#123;4&#125;)/g</span>, <span class="string">'+82-$1'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// Jane, jane@example.com, +82-10-1234-5678</span></span><br></pre></td></tr></table></figure><h2 id="match"><a href="#match" class="headerlink" title="match"></a>match</h2><p>첫 번째 인수로 받은 문자열 또는 정규표현식과 일치하는 문자열을 순서대로 저장하여 배열로 반환하며, <strong>원본 문자열을 수정하지 않음.</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> randomString = <span class="string">'Porta Tortor Mollis sit Condimentum Ligula'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(randomString.match(<span class="regexp">/sit/g</span>)); <span class="comment">// ["sit"]</span></span><br></pre></td></tr></table></figure><p>각종 정보가 혼재된 문자열에서 원하는 정보만 배열에 저장하고 싶을 때 유용함</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> url = <span class="regexp">/((([A-Za-z]&#123;3,9&#125;:(?:\/\/)?)(?:[\-;:&amp;=\+\$,\w]+@)?[A-Za-z0-9\.\-]+|(?:www\.|[\-;:&amp;=\+\$,\w]+@)[A-Za-z0-9\.\-]+)((?:\/[\+~%\/\.\w\-_]*)?\??(?:[\-\+=&amp;;%@\.\w_]*)#?(?:[\.\!\/\\\w]*))?)/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> introduce = <span class="string">'안녕하세요. codeAmeba의 홈페이지는 http://www.codeameba.com/ 입니다.'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(introduce.match(url)[<span class="number">0</span>]); <span class="comment">// http://www.codeameba.com/</span></span><br></pre></td></tr></table></figure><h2 id="split"><a href="#split" class="headerlink" title="split"></a>split</h2><p>첫 번째 인수를 기준으로 문자열을 나누어 배열에 담아 반환한다. 인수로 문자열, 정규표현식 등이 들어가며, 생략할 경우 원본 문자열 전체를 배열로 반환한다.<br><strong>원본 문자열을 수정하지 않음.</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> randomString = <span class="string">'Porta Tortor Mollis sit Condimentum Ligula'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(randomString.split(<span class="string">' '</span>));</span><br><span class="line"><span class="comment">// ["Porta", "Tortor", "Mollis", "sit", "Condimentum", "Ligula"]</span></span><br></pre></td></tr></table></figure><p><strong>참고:</strong></p><ul><li><a href="https://javascript.info/regexp-methods" target="_blank" rel="external nofollow noopener noreferrer">Methods of RegExp and String</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;String 메서드 중에는 정규표현식을 활용하면 보다 유용한 경우가 많다.&lt;/p&gt;
&lt;h2 id=&quot;search&quot;&gt;&lt;a href=&quot;#search&quot; class=&quot;headerlink&quot; title=&quot;search&quot;&gt;&lt;/a&gt;search&lt;/h2&gt;&lt;p&gt;인수로 전
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://codeameba.github.io/categories/JavaScript/"/>
    
    
      <category term="til" scheme="http://codeameba.github.io/tags/til/"/>
    
      <category term="TIL" scheme="http://codeameba.github.io/tags/TIL/"/>
    
      <category term="Today I Learned" scheme="http://codeameba.github.io/tags/Today-I-Learned/"/>
    
      <category term="오늘배운것들" scheme="http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"/>
    
      <category term="자바스크립트" scheme="http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"/>
    
      <category term="Javascript" scheme="http://codeameba.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>저작권 연도를 자동으로 업데이트 하는 방법</title>
    <link href="http://codeameba.github.io/2020/05/22/programming/auto-copyright-update/"/>
    <id>http://codeameba.github.io/2020/05/22/programming/auto-copyright-update/</id>
    <published>2020-05-21T16:15:42.000Z</published>
    <updated>2020-05-22T08:52:15.800Z</updated>
    
    <content type="html"><![CDATA[<p>웹사이트를 돌아다니다 보면 하단의 저작권 표시가 지난 연도일 경우가 왕왕 있다. 대개 외주를 통해 웹사이트를 만들고 관리자가 직접 코드를 수정할 역량이 되지 않기에 벌어지는 일이라고 생각이 된다. 하지만, 개발자가 애초에 약간의 배려를 했다면 매년 자동으로 업데이트가 될 수 있었을 것이다.</p><p>아마 대부분 아래의 코드와 같이 저작권 표시가 들어갈 것이다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">footer</span> <span class="attr">class</span>=<span class="string">“footer”</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"copyright"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="symbol">&amp;copy;</span> 2020 codeAmeba<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure><p>이렇게 되면 해가 지날 때마다 HTML 파일을 열어 수정을 해야 한다. 단지 연도만 고치면 되는데 말이다. 이 얼마나 수고스러운 일인가.</p><p>약간의 자바스크립트 코드만 덧붙이면 이 귀찮은 짓을 더 이상 하지 않아도 된다. 이때 이용하는 것은 당연하게도  <code>Date</code> 메서드다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">footer</span> <span class="attr">class</span>=<span class="string">“footer”</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">“copyright”</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="symbol">&amp;copy;</span> <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">“year”</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span> codeAmeba<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> yearEl = <span class="built_in">document</span>.querySelector(‘.year’);</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span></span><br><span class="line"><span class="actionscript">  <span class="keyword">const</span> year = date.getFullYear();</span></span><br><span class="line">  yearEl.innerHTML = year;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>이처럼 자바스크립트 코드 몇 줄만으로 배려할줄 아는 개발자가 되는 것이다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;웹사이트를 돌아다니다 보면 하단의 저작권 표시가 지난 연도일 경우가 왕왕 있다. 대개 외주를 통해 웹사이트를 만들고 관리자가 직접 코드를 수정할 역량이 되지 않기에 벌어지는 일이라고 생각이 된다. 하지만, 개발자가 애초에 약간의 배려를 했다면 매
      
    
    </summary>
    
    
      <category term="tip" scheme="http://codeameba.github.io/categories/tip/"/>
    
    
      <category term="copyright" scheme="http://codeameba.github.io/tags/copyright/"/>
    
      <category term="tip" scheme="http://codeameba.github.io/tags/tip/"/>
    
      <category term="저작권" scheme="http://codeameba.github.io/tags/%EC%A0%80%EC%9E%91%EA%B6%8C/"/>
    
  </entry>
  
  <entry>
    <title>[TIL] What is this?</title>
    <link href="http://codeameba.github.io/2020/05/20/programming/what-is-this/"/>
    <id>http://codeameba.github.io/2020/05/20/programming/what-is-this/</id>
    <published>2020-05-20T09:12:42.000Z</published>
    <updated>2020-05-22T08:54:35.156Z</updated>
    
    <content type="html"><![CDATA[<p><strong><code>this</code>는 호출하는 방식에 따라 달라지며, 크게 다섯 가지 경우로 나눌 수 있다.</strong></p><h2 id="1-전역에서-this는-언제나-window"><a href="#1-전역에서-this는-언제나-window" class="headerlink" title="1. 전역에서 this는 언제나 window"></a>1. 전역에서 this는 언제나 window</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// Window</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="2-일반-함수-호출은-언제나-window"><a href="#2-일반-함수-호출은-언제나-window" class="headerlink" title="2. 일반 함수 호출은 언제나 window"></a>2. 일반 함수 호출은 언제나 window</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">normalFunc1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">normalFunc1(); <span class="comment">// Window</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">normalFunc2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">innerFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  innerFunc();</span><br><span class="line">&#125;</span><br><span class="line">normalFunc2(); <span class="comment">// Window</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 메소드 내부의 일반 함수에서도 window</span></span><br><span class="line"><span class="comment">// 그러나 화살표 함수는 자동으로 외부 환경에 바인딩 되어 외부 환경이 this로 나온다.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  method: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">innerFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    innerFunc();</span><br><span class="line">  &#125;,</span><br><span class="line">  secondMethod: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> arrowFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    arrowFunc();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.method();  <span class="comment">// Window</span></span><br><span class="line">obj.secondMethod(); <span class="comment">// &#123;e: ƒ, g: ƒ&#125;</span></span><br></pre></td></tr></table></figure><h2 id="3-메소드-호출에서의-this는-점-앞에-있는-것-즉-메소드가-담긴-객체"><a href="#3-메소드-호출에서의-this는-점-앞에-있는-것-즉-메소드가-담긴-객체" class="headerlink" title="3. 메소드 호출에서의 this는 .(점) 앞에 있는 것. 즉, 메소드가 담긴 객체"></a>3. 메소드 호출에서의 this는 .(점) 앞에 있는 것. 즉, 메소드가 담긴 객체</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  prop: <span class="string">'Hello world'</span>,</span><br><span class="line">  method: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.prop);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.method(); <span class="comment">// Hello world</span></span><br></pre></td></tr></table></figure><p>그러나 메소드 내부함수의 경우는 또 얘기가 달라진다. 이때는 일반 함수에서의 this와 마찬가지로 전역을 가리킨다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> prop = <span class="string">'This is window'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  prop: <span class="string">'Bye world'</span>,</span><br><span class="line">  method: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.prop);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">innerFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.prop);</span><br><span class="line">    &#125;</span><br><span class="line">    innerFunc();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.method(); <span class="comment">// Bye world</span></span><br><span class="line">              <span class="comment">// This is window</span></span><br></pre></td></tr></table></figure><p>위와 같은 문제에 대처하기 위한 방법으로 <strong>this를 변수에 할당하는 우회법</strong>이 있다.<br>그리고, 내부함수를 화살표 함수로 작성하면 외부환경인 메소드의 this를 그대로 바인딩한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  prop: <span class="string">'Nice to meet you world'</span>,</span><br><span class="line">  method: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// this를 that에 할당</span></span><br><span class="line">    <span class="keyword">const</span> that = <span class="keyword">this</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">innerFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(that.prop);</span><br><span class="line">    &#125;</span><br><span class="line">    innerFunc();</span><br><span class="line">  &#125;,</span><br><span class="line">  secondMethod: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> innerArrow = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.prop);</span><br><span class="line">    &#125;</span><br><span class="line">    innerArrow();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.method(); <span class="comment">// Nice to meet you world</span></span><br><span class="line">obj.secondMethod(); <span class="comment">// Nice to meet you world</span></span><br></pre></td></tr></table></figure><h2 id="4-콜백에서의-this는-기본적으로는-일반-함수처럼-전역을-가리킨다"><a href="#4-콜백에서의-this는-기본적으로는-일반-함수처럼-전역을-가리킨다" class="headerlink" title="4. 콜백에서의 this는 기본적으로는 일반 함수처럼 전역을 가리킨다"></a>4. 콜백에서의 this는 기본적으로는 일반 함수처럼 전역을 가리킨다</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  prop: <span class="string">'This is callback'</span>,</span><br><span class="line">  method: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.prop);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  secondMethod: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.prop);</span><br><span class="line">    &#125;.bind(obj), <span class="number">1000</span>); <span class="comment">// &lt;- binding</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 화살표 함수로 작성하면 외부 환경에 바인딩</span></span><br><span class="line">obj.method(); <span class="comment">// This is callback</span></span><br><span class="line">obj.secondMethod(); <span class="comment">// This is callback</span></span><br></pre></td></tr></table></figure><p><strong>하지만, call, apply, bind 메서드를 통해 this를 명시적으로 바인딩 할 수 있다.</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>, x, y, z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = &#123;</span><br><span class="line">  c: <span class="string">'Hello'</span></span><br><span class="line">&#125;;</span><br><span class="line">a.call(b, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// &#123;c: "Hello"&#125; 1 2 3</span></span><br><span class="line">a.apply(b, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// &#123;c: "Hello"&#125; 1 2 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = a.bind(b);</span><br><span class="line">c(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// &#123;c: "Hello"&#125; 1 2 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d = a.bind(b, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">d(<span class="number">3</span>); <span class="comment">// &#123;c: "Hello"&#125; 1 2 3</span></span><br></pre></td></tr></table></figure><h2 id="5-생성자-함수에서의-this는-instance"><a href="#5-생성자-함수에서의-this는-instance" class="headerlink" title="5. 생성자 함수에서의 this는 instance"></a>5. 생성자 함수에서의 this는 instance</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, species) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.species = species;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.whatIsThis = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> Animal(<span class="string">'Max'</span>, <span class="string">'Dog'</span>);</span><br><span class="line">dog.whatIsThis(); <span class="comment">// Animal &#123;name: "Max", species: "Dog"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cat = <span class="keyword">new</span> Animal(<span class="string">'Alice'</span>, <span class="string">'Cat'</span>);</span><br><span class="line">cat.whatIsThis(); <span class="comment">// Animal &#123;name: "Alice", species: "Cat"&#125;</span></span><br></pre></td></tr></table></figure><p><strong>참고:</strong></p><ul><li><a href="https://poiemaweb.com/js-this" target="_blank" rel="external nofollow noopener noreferrer">this | PoiemaWeb</a></li><li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/this" target="_blank" rel="external nofollow noopener noreferrer">this - JavaScript | MDN</a></li><li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Function/call" target="_blank" rel="external nofollow noopener noreferrer">Function.prototype.call() - JavaScript | MDN</a></li><li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" target="_blank" rel="external nofollow noopener noreferrer">Function.prototype.apply() - JavaScript | MDN</a></li><li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="external nofollow noopener noreferrer">Function.prototype.bind() - JavaScript | MDN</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;code&gt;this&lt;/code&gt;는 호출하는 방식에 따라 달라지며, 크게 다섯 가지 경우로 나눌 수 있다.&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-전역에서-this는-언제나-window&quot;&gt;&lt;a href=&quot;#1-전역에서-this는-언
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://codeameba.github.io/categories/JavaScript/"/>
    
    
      <category term="til" scheme="http://codeameba.github.io/tags/til/"/>
    
      <category term="TIL" scheme="http://codeameba.github.io/tags/TIL/"/>
    
      <category term="Today I Learned" scheme="http://codeameba.github.io/tags/Today-I-Learned/"/>
    
      <category term="오늘배운것들" scheme="http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"/>
    
      <category term="자바스크립트" scheme="http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"/>
    
      <category term="Javascript" scheme="http://codeameba.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>[TIL] 타입스크립트의 데이터 타입</title>
    <link href="http://codeameba.github.io/2020/05/18/programming/ts-data-type/"/>
    <id>http://codeameba.github.io/2020/05/18/programming/ts-data-type/</id>
    <published>2020-05-18T10:22:42.000Z</published>
    <updated>2020-05-18T10:33:28.617Z</updated>
    
    <content type="html"><![CDATA[<h2 id="타입을-명시하는-방법"><a href="#타입을-명시하는-방법" class="headerlink" title="타입을 명시하는 방법"></a>타입을 명시하는 방법</h2><p>TypeScript는 변수명 뒤에 타입을 명시한다. 명시한 타입과 다른 타입의 값을 할당하면 트랜스파일링 도중 오류가 발생한다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo: <span class="built_in">string</span> = <span class="string">'Hello world'</span>;</span><br><span class="line"><span class="keyword">let</span> bar: <span class="built_in">number</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> baz: <span class="built_in">boolean</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>함수의 경우, parameter와 return value에 대해 타입을 명시한다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> multiply = (x: <span class="built_in">number</span>, y: <span class="built_in">number</span>): <span class="function"><span class="params">number</span> =&gt;</span> x * y;</span><br></pre></td></tr></table></figure><p>arguments에는 따로 타입을 명시하지는 않지만 parameter의 타입과 다른 타입을 전달할 경우 오류가 발생한다. 린트를 이용하면 리터럴 시점에 알 수 있다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(add(<span class="number">3</span>, <span class="string">'5'</span>)); <span class="comment">// error TS2345: Argument of type '"5"' is not assignable to parameter of type 'number'.</span></span><br></pre></td></tr></table></figure><h2 id="타입스크립트에만-존재하는-데이터-타입들"><a href="#타입스크립트에만-존재하는-데이터-타입들" class="headerlink" title="타입스크립트에만 존재하는 데이터 타입들"></a>타입스크립트에만 존재하는 데이터 타입들</h2><p>TypeScript는 JavaScript의 모든 데이터 타입을 사용할 수 있으며, 추가적으로 TypeScript 고유의 데이터 타입을 사용할 수도 있다.<br><strong>(ex: array, tuple, enum, any, void, never)</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// array : 요소의 타입까지 함께 명시</span></span><br><span class="line"><span class="keyword">let</span> arr1: <span class="built_in">any</span>[] = [<span class="number">1</span>, <span class="string">'two'</span>, <span class="literal">false</span>];</span><br><span class="line"><span class="keyword">let</span> arr2: <span class="built_in">number</span>[] = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>];</span><br><span class="line"><span class="keyword">let</span> arr3: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; <span class="comment">// 제네릭 배열 타입</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// tuple : 요소의 개수와 순서를 미리 정해 놓고 배열을 표현</span></span><br><span class="line"><span class="keyword">let</span> tuple1: [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line">tuple1 = [<span class="string">'one'</span>, <span class="number">2</span>]; <span class="comment">// pass</span></span><br><span class="line">tuple1 = [<span class="number">1</span>, <span class="string">'two'</span>]; <span class="comment">// error</span></span><br><span class="line">tuple1 = [<span class="string">'one'</span>, <span class="number">2</span>, <span class="string">'three'</span>, <span class="number">4</span>]; <span class="comment">// error</span></span><br><span class="line">tuple1.push(<span class="literal">true</span>); <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// enum : 숫자값 집합에 이름을 지정한 것</span></span><br><span class="line"><span class="keyword">enum</span> Color1 &#123;Red, Green, Blue&#125;;</span><br><span class="line"><span class="keyword">let</span> c1: Color1 = Color1.Green;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 별도의 숫자를 지정하지 않으면 0부터 시작하는 인덱스가 순서대로 할당 됨</span></span><br><span class="line"><span class="built_in">console</span>.log(c1) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Color2 &#123;Red = <span class="number">1</span>, Green, Blue&#125;;</span><br><span class="line"><span class="keyword">let</span> c2: Color2 = Color2.Green;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 한 요소에 숫자를 할당하면 숫자가 할당된 요소를 기준으로 다른 요소의 숫자가 순서대로 할당 됨</span></span><br><span class="line"><span class="built_in">console</span>.log(c2); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Color3 &#123;Red = <span class="number">1</span>, Green = <span class="number">3</span>, Blue = <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> c3: Color3 = Color3.Green;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 각 요소에 숫자를 할당하면 해당 요소의 값이 됨</span></span><br><span class="line"><span class="built_in">console</span>.log(c3); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// any : 타입을 알 수 없거나 타입 체크가 필요 없는 변수에 사용함. 아무 타입에나 사용 가능.</span></span><br><span class="line"><span class="keyword">let</span> notSure: <span class="built_in">any</span> = <span class="number">5</span>;</span><br><span class="line">notSure = <span class="string">'Hello world'</span>;</span><br><span class="line">notSure = <span class="literal">true</span>; <span class="comment">// 어떤 타입으로 재할당을 해도 오류가 없음.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// void : 보통 함수에서 반환값이 없을 때 사용함.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">noReturn</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello world'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// never : 결코 발생하지 않는 값</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">neverStop</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>참고:</strong></p><ul><li><a href="https://poiemaweb.com/typescript-typing" target="_blank" rel="external nofollow noopener noreferrer">poiemaweb</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;타입을-명시하는-방법&quot;&gt;&lt;a href=&quot;#타입을-명시하는-방법&quot; class=&quot;headerlink&quot; title=&quot;타입을 명시하는 방법&quot;&gt;&lt;/a&gt;타입을 명시하는 방법&lt;/h2&gt;&lt;p&gt;TypeScript는 변수명 뒤에 타입을 명시한다. 명시한 타
      
    
    </summary>
    
    
      <category term="TypeScript" scheme="http://codeameba.github.io/categories/TypeScript/"/>
    
    
      <category term="til" scheme="http://codeameba.github.io/tags/til/"/>
    
      <category term="TIL" scheme="http://codeameba.github.io/tags/TIL/"/>
    
      <category term="Today I Learned" scheme="http://codeameba.github.io/tags/Today-I-Learned/"/>
    
      <category term="오늘배운것들" scheme="http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"/>
    
      <category term="타입스크립트" scheme="http://codeameba.github.io/tags/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"/>
    
      <category term="TypeScript" scheme="http://codeameba.github.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>[TIL] 다양한 활용이 가능한 전개 연산자(spread operator)</title>
    <link href="http://codeameba.github.io/2020/05/17/programming/spread-operator/"/>
    <id>http://codeameba.github.io/2020/05/17/programming/spread-operator/</id>
    <published>2020-05-17T10:12:42.000Z</published>
    <updated>2020-05-17T10:22:11.171Z</updated>
    
    <content type="html"><![CDATA[<h2 id="…-spread-operator"><a href="#…-spread-operator" class="headerlink" title="…(spread operator)"></a>…(spread operator)</h2><p><code>...</code>(spread operator)는 이터러블한 객체를 반환하는 표현식 앞에 쓸 수 있으며, 이를 통해 이터러블 객체를 배열 또는 함수의 인수 목록으로 펼칠 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 이터러블 객체를 풀어줌</span></span><br><span class="line"><span class="built_in">console</span>.log(...<span class="string">'ABC'</span>); <span class="comment">// A B C</span></span><br><span class="line"><span class="built_in">console</span>.log(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]); <span class="comment">// 1 2 3 4</span></span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>, ...[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>]) <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 인수를 전달할 때 풀어서 전달</span></span><br><span class="line"><span class="keyword">const</span> favorFruits = <span class="function">(<span class="params">fruit</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> myFavor = [];</span><br><span class="line">  myFavor.push(...fruit);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">console</span>.log(myFavor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fruits = [<span class="string">'apple'</span>, <span class="string">'grape'</span>, <span class="string">'melon'</span>, <span class="string">'cherry'</span>];</span><br><span class="line">favorFruits(fruits); <span class="comment">// ["apple", "grape", "melon", "cherry"]</span></span><br><span class="line">favorFruits(...fruits); <span class="comment">// ["a", "p", "p", "l", "e"]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...을 사용하여 concat 대신 push로 연결 가능</span></span><br><span class="line"><span class="keyword">const</span> newFruits = [<span class="string">'mango'</span>, <span class="string">'blueberry'</span>];</span><br><span class="line">fruits.push(...newFruits);</span><br><span class="line"><span class="built_in">console</span>.log(fruits); <span class="comment">// ["apple", "grape", "melon", "cherry", "mango", "blueberry"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 배열 내 최댓값 구하기</span></span><br><span class="line"><span class="keyword">const</span> nums = [<span class="number">3</span>, <span class="number">12</span>, <span class="number">72</span>, <span class="number">35</span>, <span class="number">56</span>, <span class="number">5</span>, <span class="number">88</span>, <span class="number">2</span>, <span class="number">17</span>, <span class="number">29</span>, <span class="number">47</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(...nums)); <span class="comment">// 88</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;…-spread-operator&quot;&gt;&lt;a href=&quot;#…-spread-operator&quot; class=&quot;headerlink&quot; title=&quot;…(spread operator)&quot;&gt;&lt;/a&gt;…(spread operator)&lt;/h2&gt;&lt;p&gt;&lt;code&gt;..
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://codeameba.github.io/categories/JavaScript/"/>
    
    
      <category term="til" scheme="http://codeameba.github.io/tags/til/"/>
    
      <category term="TIL" scheme="http://codeameba.github.io/tags/TIL/"/>
    
      <category term="Today I Learned" scheme="http://codeameba.github.io/tags/Today-I-Learned/"/>
    
      <category term="오늘배운것들" scheme="http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"/>
    
      <category term="자바스크립트" scheme="http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"/>
    
      <category term="Javascript" scheme="http://codeameba.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>[TIL] 인스턴스로 인스턴스 만들기</title>
    <link href="http://codeameba.github.io/2020/05/14/programming/make-instance-use-instance/"/>
    <id>http://codeameba.github.io/2020/05/14/programming/make-instance-use-instance/</id>
    <published>2020-05-14T11:12:42.000Z</published>
    <updated>2020-05-14T10:22:42.494Z</updated>
    
    <content type="html"><![CDATA[<h2 id="생성자-함수를-지닌-인스턴스"><a href="#생성자-함수를-지닌-인스턴스" class="headerlink" title="생성자 함수를 지닌 인스턴스"></a>생성자 함수를 지닌 인스턴스</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(first, last, age, gender, interests) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = &#123;</span><br><span class="line">      first: first,</span><br><span class="line">      last: last</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.gender = gender === <span class="string">'male'</span> ? <span class="string">'He'</span> : <span class="string">'She'</span>;</span><br><span class="line">    <span class="keyword">this</span>.interests = interests; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bio = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(</span><br><span class="line">      <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name.first&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.name.last&#125;</span> is <span class="subst">$&#123;<span class="keyword">this</span>.age&#125;</span> years old. <span class="subst">$&#123;<span class="keyword">this</span>.gender&#125;</span> likes <span class="subst">$&#123;<span class="keyword">this</span>.interests[<span class="number">0</span>]&#125;</span> and <span class="subst">$&#123;<span class="keyword">this</span>.interests[<span class="number">1</span>]&#125;</span>.`</span></span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line">  greeting = <span class="function"><span class="keyword">function</span>(<span class="params">myName</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hello I'm <span class="subst">$&#123;<span class="keyword">this</span>.name.first&#125;</span>. Nice to meet you <span class="subst">$&#123;myName&#125;</span>.`</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> john = <span class="keyword">new</span> Person(<span class="string">'John'</span>, <span class="string">'Miles'</span>, <span class="number">32</span>, <span class="string">'male'</span>, [<span class="string">'coding'</span>, <span class="string">'reading'</span>]);</span><br><span class="line"><span class="keyword">const</span> Jane = <span class="keyword">new</span> Person(‘Jane<span class="string">', '</span>Carol<span class="string">', 29, '</span>female<span class="string">', ['</span>painting<span class="string">', '</span>watching movie<span class="string">']);</span></span><br></pre></td></tr></table></figure><p>위와 같은 <code>class</code>와 그것을 통해 생성된 인스턴스가 있을 때, <strong>부득이하게 생성자 함수를 예측할 수 없는 상황에서 새로운 인스턴스를 생성해야 하는 경우에 처했다고 가정한다.</strong></p><p>이럴 때에는 프로토타입 체인을 통해 인스턴스 내부에 구현되어 있는 생성자 함수 <code>constructor</code>를 쓰면 가능하다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(jane.__proto__); <span class="comment">// &#123;constructor: ƒ&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(jane.constructor);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">class Person &#123;</span></span><br><span class="line"><span class="comment">constructor(first, last, age, gender, interests) &#123;</span></span><br><span class="line"><span class="comment">this.name = &#123;</span></span><br><span class="line"><span class="comment">first: first,</span></span><br><span class="line"><span class="comment">last: last</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">this.age = age;</span></span><br><span class="line"><span class="comment">this.gender = gender === 'male' ? 'He' : 'She';</span></span><br><span class="line"><span class="comment">this.interests =…</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>인스턴스의 생성자 함수를 콘솔에서 확인해보면 위와 같이 슈퍼클래스의 생성자가 그대로 담겨있는 것을 볼 수 있다. 그리고, 이를 통해 일반적이지 않은 방법으로 새로운 인스턴스를 만들어낼 수 있다.</p><h2 id="인스턴스로-인스턴스-만들기"><a href="#인스턴스로-인스턴스-만들기" class="headerlink" title="인스턴스로 인스턴스 만들기"></a>인스턴스로 인스턴스 만들기</h2><p>인스턴스로 인스턴스를 만들기는 어렵지 않다. 아래와 같이 <code>new</code> 키워드와 <code>constructor()</code>를 통해 간단히 만들 수가 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sam = <span class="keyword">new</span> jane.constructor(‘Sam’, ‘Winchester<span class="string">', 25, '</span>male<span class="string">', ['</span>singing<span class="string">', '</span>running<span class="string">']);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">console.log(sam.name); // &#123;first: "Sam", last: "Winchester"&#125;</span></span><br><span class="line"><span class="string">console.log(sam.bio()); // Sam Winchester is 25 years old. He likes singing and running.</span></span><br><span class="line"><span class="string">console.log(sam.greeting(‘Jane’)); // Hello I'</span>m Sam. Nice to meet you Jane.</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;생성자-함수를-지닌-인스턴스&quot;&gt;&lt;a href=&quot;#생성자-함수를-지닌-인스턴스&quot; class=&quot;headerlink&quot; title=&quot;생성자 함수를 지닌 인스턴스&quot;&gt;&lt;/a&gt;생성자 함수를 지닌 인스턴스&lt;/h2&gt;&lt;figure class=&quot;highli
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://codeameba.github.io/categories/JavaScript/"/>
    
    
      <category term="til" scheme="http://codeameba.github.io/tags/til/"/>
    
      <category term="TIL" scheme="http://codeameba.github.io/tags/TIL/"/>
    
      <category term="Today I Learned" scheme="http://codeameba.github.io/tags/Today-I-Learned/"/>
    
      <category term="오늘배운것들" scheme="http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"/>
    
      <category term="자바스크립트" scheme="http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"/>
    
      <category term="Javascript" scheme="http://codeameba.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>[TIL] 모든 요소에 특정 작업을 수행하는 반복 메서드</title>
    <link href="http://codeameba.github.io/2020/05/11/programming/array-method-iteration/"/>
    <id>http://codeameba.github.io/2020/05/11/programming/array-method-iteration/</id>
    <published>2020-05-11T09:40:42.000Z</published>
    <updated>2020-05-13T18:03:13.501Z</updated>
    
    <content type="html"><![CDATA[<h2 id="반복-메서드"><a href="#반복-메서드" class="headerlink" title="반복 메서드"></a>반복 메서드</h2><p>배열 메서드는 크게 세 종류로 나눈다.</p><ul><li><strong>수정 메서드</strong> : 원본 배열을 수정함</li><li><strong>접근자 메서드</strong> : 배열에 접근하여 새로운 배열을 반환</li><li><strong>반복 메서드</strong> : 배열의 요소들을 순회하며 작업을 수행</li></ul><p>이번 시간에는 주요 <strong>반복 메서드</strong> 들을 살펴본다.</p><h2 id="반복-메서드의-공통-성질"><a href="#반복-메서드의-공통-성질" class="headerlink" title="반복 메서드의 공통 성질"></a>반복 메서드의 공통 성질</h2><ol><li>반복 메서드의 인수로 전달한 함수는 배열의 모든 요소들에 호출되어 적용되며, 희소 배열의 경우 비어있는 요소는 건너뜀</li><li>반복 메서드 대부분은 첫 번째 인수로 함수를 받으며, 이 함수에는 <strong>최대 세 개의 인수</strong> 를 전달할 수 있다. 첫 번째 인수만 전달하는 경우가 많으며, 각각의 인수는 다음과 같다.<ul><li>첫 번째 인수(value): 현재 처리하는 요소의 값</li><li>두 번째 인수(index): 현재 처리하는 요소의 인덱스</li><li>세 번째 인수(array): 메서드가 적용되는 배열의 참조</li></ul></li><li><code>reduce</code>와 <code>reduceRight</code>를 제외한 반복 메서드에는 두 번째 인수를 지정할 수 있다. 두 번째 인수는 첫 번째 인수로 받은 함수 안의 <code>this</code>값이며 생략 가능하다.</li></ol><h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h2><p><code>forEach()</code>는 인수로 받은 함수를 요소 하나 하나마다 실행한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fruits = [‘apple’, ‘banana’, ‘melon’, ‘peach’, ‘blueberry’];</span><br><span class="line"></span><br><span class="line">fruits.forEach(<span class="function">(<span class="params">fruit</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`I Love <span class="subst">$&#123;fruit&#125;</span>`</span>));</span><br><span class="line"><span class="comment">// I Love apple</span></span><br><span class="line"><span class="comment">// I Love banana</span></span><br><span class="line"><span class="comment">// I Love melon</span></span><br><span class="line"><span class="comment">// I Love peach</span></span><br><span class="line"><span class="comment">// I Love blueberry</span></span><br><span class="line"></span><br><span class="line">fruits.forEach(<span class="function">(<span class="params">fruit, index</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;fruit&#125;</span> is <span class="subst">$&#123;index + <span class="number">1</span>&#125;</span>th fruit.`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// apple is 1th fruit.</span></span><br><span class="line"><span class="comment">// banana is 2th fruit.</span></span><br><span class="line"><span class="comment">// melon is 3th fruit.</span></span><br><span class="line"><span class="comment">// peach is 4th fruit.</span></span><br><span class="line"><span class="comment">// blueberry is 5th fruit.</span></span><br></pre></td></tr></table></figure><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p><code>map()</code>은 인수로 받은 함수를 요소별로 한 번씩 실행하며, 함수가 반환한 값으로 새로운 배열을 생성한다. <code>map()</code>의 인수로 넘기는 함수는 반드시 값을 반환해야 한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fruits = [‘apple’, ‘banana’, ‘melon’, ‘peach’, ‘blueberry’];</span><br><span class="line"><span class="keyword">const</span> myFruits = fruits.map(<span class="function">(<span class="params">fruit</span>) =&gt;</span> fruit.toUpperCase());</span><br><span class="line"><span class="built_in">console</span>.log(myFruits); </span><br><span class="line"><span class="comment">// [“APPLE”, “BANANA”, “MELON”, “PEACH”, “BLUEBERRY”]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>];</span><br><span class="line"><span class="keyword">const</span> sqrt = numbers.map(<span class="built_in">Math</span>.sqrt);</span><br><span class="line"><span class="built_in">console</span>.log(sqrt); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> persons = [</span><br><span class="line">  &#123;<span class="attr">name</span>: ‘Tom’, <span class="attr">age</span>: <span class="number">17</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>: ‘James’, <span class="attr">age</span>: <span class="number">19</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>: ‘Sam’, <span class="attr">age</span>: <span class="number">15</span>&#125;</span><br><span class="line">];</span><br><span class="line"><span class="keyword">const</span> names = persons.map(<span class="function"><span class="params">person</span> =&gt;</span> person.name);</span><br><span class="line"><span class="keyword">const</span> ages = persons.map(<span class="function"><span class="params">person</span> =&gt;</span> person.age);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`names: <span class="subst">$&#123;names&#125;</span> / ages: <span class="subst">$&#123;ages&#125;</span>`</span>);</span><br><span class="line"><span class="comment">// names: Tom,James,Sam / ages: 17,19,15</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(persons.map(<span class="function"><span class="params">person</span> =&gt;</span> person.name).map(<span class="function"><span class="params">name</span> =&gt;</span> name.length));</span><br><span class="line"><span class="comment">// [3, 5, 3]</span></span><br></pre></td></tr></table></figure><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p><code>filter()</code>는 조건에 충족하는 요소만 걸러 새로운 배열로 반환한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fruits = [‘apple’, ‘banana’, ‘melon’, ‘peach’, ‘blueberry’];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> includeM = fruits.filter(<span class="function">(<span class="params">fruit</span>) =&gt;</span> fruit.includes(‘m’));</span><br><span class="line"><span class="built_in">console</span>.log(includeM); <span class="comment">// [“melon”]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> longerThan5Length = fruits.filter(<span class="function"><span class="params">fruit</span> =&gt;</span> fruit.length &gt; <span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(longerThan5Length); <span class="comment">// [“banana”, “blueberry”]</span></span><br></pre></td></tr></table></figure><h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h2><p><code>reduce()</code>는 배열을 기반으로 하나의 값을 도출할 때 사용한다. reduce의 인수로 넘기는 함수의 첫 번째 인수는 <strong>accumulator(누산기)</strong> 라고 할 수 있으며, 함수의 결과가 누적되어 저장되고 마지막 함수까지 호출되면 이 값이 <code>reduce()</code>의 반환값이 된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myNums = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> result = myNums.reduce(<span class="function">(<span class="params">sum, current</span>) =&gt;</span> sum + current, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 27</span></span><br></pre></td></tr></table></figure><p><code>reduce()</code>에 전달된 함수는 위와 같이 두 개의 인수를 받는 게 일반적이다.<br>위 코드의 실행 절차에 따른 <code>sum</code>과 <code>current</code>의 상태 변화는 다음과 같다.</p><ol><li><code>sum = 0</code> / <code>current = 1</code></li><li><code>sum = 0 + 1</code> / <code>current = 5</code></li><li><code>sum = 0 + 1 + 5</code> / <code>current = 3</code></li><li><code>sum = 0 + 1 + 5 + 3</code> / <code>current = 7</code></li><li><code>sum = 0 + 1 + 5 + 3 + 7</code> / <code>current = 9</code></li><li><code>sum = 0 + 1 + 5 + 3 + 7 + 9</code> / <code>current = 2</code></li><li><code>return sum = 0 + 1 + 5 + 3 + 7 + 9 + 2</code></li></ol><p>끝의 <code>0</code>은 <code>reduce()</code>의 마지막 인수로 초깃값을 뜻하며 <code>sum</code>에 할당된다. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">9</span>];</span><br><span class="line"><span class="keyword">let</span> newResult = arr.reduce(<span class="function">(<span class="params">sum, current</span>) =&gt;</span> sum + current);</span><br><span class="line"><span class="built_in">console</span>.log(newResult); <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> emptyArr = [];</span><br><span class="line"><span class="keyword">let</span> newResult = emptyArr.reduce(<span class="function">(<span class="params">sum, current</span>) =&gt;</span> sum + current);</span><br><span class="line"><span class="built_in">console</span>.log(newResult); <span class="comment">// TypeError: Reduce of empty array with no initial value</span></span><br></pre></td></tr></table></figure><p>초깃값을 생략할 경우 배열의 첫 번째 요소를 초깃값으로 사용한다. 다만, 배열이 비었을 경우 초깃값으로 사용할 요소가 없기 때문에 <code>error</code>가 발생한다.</p><p>이러한 <code>reduce()</code>의 특성을 활용하면 꼭 요소들의 합 뿐만 아니라 다양한 방법으로 사용할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 모든 배열 요소의 곱</span></span><br><span class="line"><span class="built_in">console</span>.log(a.reduce(<span class="function">(<span class="params">pre, val</span>) =&gt;</span> pre * val)); <span class="comment">// 252</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 배열 요소 중 가장 큰 값</span></span><br><span class="line"><span class="built_in">console</span>.log(a.reduce(<span class="function">(<span class="params">pre, val</span>) =&gt;</span> pre &gt; val ? pre : val)); <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> names = [<span class="string">'Tom'</span>, <span class="string">'Jane'</span>, <span class="string">'Sam'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 문자열 연결</span></span><br><span class="line"><span class="built_in">console</span>.log(names.reduce(<span class="function">(<span class="params">pre, val</span>) =&gt;</span> pre + <span class="string">' '</span> + val)); <span class="comment">// Tom Jane Sam</span></span><br></pre></td></tr></table></figure><h3 id="reduceRight"><a href="#reduceRight" class="headerlink" title="reduceRight"></a>reduceRight</h3><p><code>reduce()</code>와 유사한 메서드로 <code>reduceRight()</code>가 있다. 원리와 사용법은 동일하며 배열의 오른쪽 요소부터 작업을 수행한다는 점이 다르다.</p><p><strong>참고:</strong></p><ul><li><a href="https://ko.javascript.info/array-methods" target="_blank" rel="external nofollow noopener noreferrer">배열과 메서드</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;반복-메서드&quot;&gt;&lt;a href=&quot;#반복-메서드&quot; class=&quot;headerlink&quot; title=&quot;반복 메서드&quot;&gt;&lt;/a&gt;반복 메서드&lt;/h2&gt;&lt;p&gt;배열 메서드는 크게 세 종류로 나눈다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;수정 메서드&lt;/str
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://codeameba.github.io/categories/JavaScript/"/>
    
    
      <category term="til" scheme="http://codeameba.github.io/tags/til/"/>
    
      <category term="TIL" scheme="http://codeameba.github.io/tags/TIL/"/>
    
      <category term="Today I Learned" scheme="http://codeameba.github.io/tags/Today-I-Learned/"/>
    
      <category term="오늘배운것들" scheme="http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"/>
    
      <category term="자바스크립트" scheme="http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"/>
    
      <category term="Javascript" scheme="http://codeameba.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>[TIL] 새로운 배열을 반환하는 배열 메서드</title>
    <link href="http://codeameba.github.io/2020/05/09/programming/array-method-return-new-array/"/>
    <id>http://codeameba.github.io/2020/05/09/programming/array-method-return-new-array/</id>
    <published>2020-05-09T11:20:42.000Z</published>
    <updated>2020-05-13T18:03:17.448Z</updated>
    
    <content type="html"><![CDATA[<h2 id="접근자-메서드"><a href="#접근자-메서드" class="headerlink" title="접근자 메서드"></a>접근자 메서드</h2><p>배열 메서드는 크게 세 종류로 나눈다.</p><ul><li><strong>수정 메서드</strong> : 원본 배열을 수정함</li><li><strong>접근자 메서드</strong> : 배열에 접근하여 새로운 배열을 반환</li><li><strong>반복 메서드</strong> : 배열의 요소들을 순회하며 작업을 수행</li></ul><p>이번 시간에는 주요 <strong>접근자 메서드</strong> 들을 살펴본다.</p><h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><p><code>join()</code>은 모든 요소를 문자열로 변환 후 인수로 받은 문자와 연결하여 반환한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fruits = [‘apple’, ‘banana’, ‘melon’, ‘peach’, ‘blueberry’];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fruits.join(‘-‘));</span><br><span class="line"><span class="comment">// apple-banana-melon-peach-blueberry</span></span><br></pre></td></tr></table></figure><h2 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h2><p><code>concat()</code>은 인수로 받은 값을 배열에 추가하여 새로운 배열을 생성한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fruits = [‘apple’, ‘banana’, ‘melon’, ‘peach’, ‘blueberry’];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fruits.concat(‘cherry’, ‘grape’));</span><br><span class="line"><span class="comment">// ["apple", "banana", "melon", "peach", "blueberry", "cherry", "grape"]</span></span><br></pre></td></tr></table></figure><p>인수를 배열로 전달할 경우에는 자동으로 배열을 해체한 후 합친다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(fruits.concat([‘cherry’, ‘grape’]));</span><br><span class="line"><span class="comment">// ["apple", "banana", "melon", "peach", "blueberry", "cherry", "grape"]</span></span><br></pre></td></tr></table></figure><p>그러나, 가장 바깥의 배열만 자동으로 해체하기 때문에 중복된 배열은 배열 그대로 추가된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(fruits.concat([‘lemon’, [‘strawberry’, ‘watermelon’]]));</span><br><span class="line"><span class="comment">// ["apple", "banana", "melon", "peach", "blueberry", "lemon", [“strawberry”, “watermelon”]]</span></span><br></pre></td></tr></table></figure><h2 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h2><p><code>slice()</code>는 선택된 만큼의 요소를 새로운 배열로 반환한다. 두 개의 인수를 받으며, 첫 번째 인수는 <strong>시작 인덱스</strong> , 두 번째 인수는 <strong>끝 인덱스</strong> 다.</p><p><code>slice(시작, 끝)</code> : 시작 인덱스의 요소부터 끝 인덱스 바로 앞까지 새로운 배열로 반환한다. 두 번째 인수를 생략 가능하며 그럴 경우 시작 인덱스부터 모든 요소를 배열로 반환한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fruits = [‘apple’, ‘banana’, ‘melon’, ‘peach’, ‘blueberry’];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fruits.slice(<span class="number">1</span>, <span class="number">4</span>));</span><br><span class="line"><span class="comment">// ["banana", "melon", "peach"]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fruits.slice(<span class="number">3</span>));</span><br><span class="line"><span class="comment">// ["peach", "blueberry"]</span></span><br></pre></td></tr></table></figure><h2 id="indexOf-lastIndexOf"><a href="#indexOf-lastIndexOf" class="headerlink" title="indexOf, lastIndexOf"></a>indexOf, lastIndexOf</h2><p><code>indexOf()</code>와 <code>lastIndexOf()</code>는 인수로 전달한 요소의 인덱스를 반환한다.<br><code>indexOf()</code>는 배열 왼쪽부터 검색하고, <code>lastIndexOf()</code>는 배열 오른쪽부터 검색하여 반환한다. 만약, 찾는 요소가 배열에 없을 때에는 <code>-1</code>을 반환한다.<br>두 번째 인수는 검색을 시작할 인덱스이며 생략 가능하다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">9</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(numbers.indexOf(<span class="number">5</span>)); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(numbers.lastIndexOf(<span class="number">5</span>)); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><h2 id="toString-toLocaleString"><a href="#toString-toLocaleString" class="headerlink" title="toString, toLocaleString"></a>toString, toLocaleString</h2><p><code>toString()</code>과 <code>toLocaleString()</code>은 배열의 요소를 문자열로 반환 후 쉼표로 연결하여 반환한다. 둘의 차이는 <code>toLocaleString()</code>의 경우 해당 지역에 맞는 문자열로 번역하여 반환한다는 점이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log([‘Seoul’, ‘Republic <span class="keyword">of</span> Korea’, date].toString());</span><br><span class="line"><span class="comment">// Seoul,Republic of Korea,Sat May 09 2020 20:00:19</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log([‘Seoul’, ‘Republic <span class="keyword">of</span> Korea’, date].toLocaleString());</span><br><span class="line"><span class="comment">// Seoul,Republic of Korea,2020. 5. 9. 오후 8:00:19</span></span><br></pre></td></tr></table></figure><p><code>Object.prototype</code>에 동일한 이름을 가진 메서드가 존재하지만, <code>Array</code>에 새롭게 정의한 메서드이므로 다른 메서드로 볼 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString === <span class="built_in">Array</span>.prototype.toString <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString === <span class="built_in">Array</span>.prototype.__proto__.toString <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>참고:</strong></p><ul><li><a href="https://ko.javascript.info/array-methods" target="_blank" rel="external nofollow noopener noreferrer">배열과 메서드</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;접근자-메서드&quot;&gt;&lt;a href=&quot;#접근자-메서드&quot; class=&quot;headerlink&quot; title=&quot;접근자 메서드&quot;&gt;&lt;/a&gt;접근자 메서드&lt;/h2&gt;&lt;p&gt;배열 메서드는 크게 세 종류로 나눈다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;수정 메서드&lt;
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://codeameba.github.io/categories/JavaScript/"/>
    
    
      <category term="til" scheme="http://codeameba.github.io/tags/til/"/>
    
      <category term="TIL" scheme="http://codeameba.github.io/tags/TIL/"/>
    
      <category term="Today I Learned" scheme="http://codeameba.github.io/tags/Today-I-Learned/"/>
    
      <category term="오늘배운것들" scheme="http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"/>
    
      <category term="자바스크립트" scheme="http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"/>
    
      <category term="Javascript" scheme="http://codeameba.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>[TIL] 원본 배열을 수정하는 배열 메서드</title>
    <link href="http://codeameba.github.io/2020/05/08/programming/array-method-changed-original/"/>
    <id>http://codeameba.github.io/2020/05/08/programming/array-method-changed-original/</id>
    <published>2020-05-08T09:12:42.000Z</published>
    <updated>2020-05-13T18:03:08.377Z</updated>
    
    <content type="html"><![CDATA[<h2 id="수정-메서드"><a href="#수정-메서드" class="headerlink" title="수정 메서드"></a>수정 메서드</h2><p>배열 메서드는 크게 세 종류로 나눈다.</p><ul><li><strong>수정 메서드</strong> : 원본 배열을 수정함</li><li><strong>접근자 메서드</strong> : 배열에 접근하여 새로운 배열을 반환</li><li><strong>반복 메서드</strong> : 배열의 요소들을 순회하며 작업을 수행</li></ul><p>이번 시간에는 주요 수정 메서드들을 살펴본다.</p><h2 id="push"><a href="#push" class="headerlink" title="push"></a>push</h2><p><code>push()</code>는 배열 마지막에 새로운 요소를 추가한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fruits = [‘apple’, ‘banana’, ‘melon’, ‘peach’, ‘blueberry’];</span><br><span class="line"></span><br><span class="line">fruits.push(‘pineapple’);</span><br><span class="line"><span class="built_in">console</span>.log(fruits);</span><br><span class="line"><span class="comment">// ["apple", "banana", "melon", "peach", "blueberry", "pineapple"]</span></span><br></pre></td></tr></table></figure><h2 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h2><p><code>pop()</code>은 배열 마지막 요소를 제거한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fruits = [‘apple’, ‘banana’, ‘melon’, ‘peach’, ‘blueberry’];</span><br><span class="line"></span><br><span class="line">fruits.pop();</span><br><span class="line"><span class="built_in">console</span>.log(fruits);</span><br><span class="line"><span class="comment">// ["apple", "banana", "melon", "peach"]</span></span><br></pre></td></tr></table></figure><h2 id="shift"><a href="#shift" class="headerlink" title="shift"></a>shift</h2><p><code>shift()</code>는 배열 맨 앞의 요소를 제거한 후 모든 요소를 왼쪽으로 이동 시킨다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fruits = [‘apple’, ‘banana’, ‘melon’, ‘peach’, ‘blueberry’];</span><br><span class="line"></span><br><span class="line">fruits.shift();</span><br><span class="line"><span class="built_in">console</span>.log(fruits);</span><br><span class="line"><span class="comment">// [‘banana’, ‘melon’, ‘peach’, ‘blueberry’]</span></span><br></pre></td></tr></table></figure><h2 id="unshift"><a href="#unshift" class="headerlink" title="unshift"></a>unshift</h2><p><code>unshift()</code>는 배열 맨 앞에 새로운 요소를 추가하며 기존의 요소들을 오른쪽으로 이동 시킨다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fruits = [‘apple’, ‘banana’, ‘melon’, ‘peach’, ‘blueberry’];</span><br><span class="line"></span><br><span class="line">fruits.unshift(‘pineapple’);</span><br><span class="line"><span class="built_in">console</span>.log(fruits);</span><br><span class="line"><span class="comment">// [‘pineapple’, ‘apple’, ‘banana’, ‘melon’, ‘peach’, ‘blueberry’]</span></span><br></pre></td></tr></table></figure><h2 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h2><p><code>splice</code>는 전달하는 인자 개수에 따라 특정 위치에 요소를 추가, 삭제, 교체할 수 있다.<br><strong><code>splice(시작 인덱스, 시작 인덱스부터 요소의 개수, 추가할 요소)</code></strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fruits = [‘apple’, ‘banana’, ‘melon’, ‘peach’, ‘blueberry’];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 인덱스 1부터 2개의 요소를 제거하고, ‘lemon’과 ‘grape’를 추가</span></span><br><span class="line">fruits.splice(<span class="number">1</span>, <span class="number">2</span>, ‘lemon’, ‘grape’);</span><br><span class="line"><span class="built_in">console</span>.log(fruits);</span><br><span class="line"><span class="comment">// ["apple", "lemon", "grape", "peach", "blueberry"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 첫 번째 인수만 넘기면 해당 인덱스 이후의 요소 모두 제거</span></span><br><span class="line">fruits.splice(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(fruits);</span><br><span class="line"><span class="comment">// ["apple", "lemon"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 두 번째 인수에 0을 넘기면 제거 없이 새로운 요소만 추가</span></span><br><span class="line">fruits.splice(<span class="number">1</span>, <span class="number">0</span>, ‘cherry’);</span><br><span class="line"><span class="built_in">console</span>.log(fruits);</span><br><span class="line"><span class="comment">// [“apple", "cherry", "lemon"]</span></span><br></pre></td></tr></table></figure><h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><p><code>sort()</code>는 배열 요소를 정렬할 때 사용한다. 비교함수를 넣어야 인접한 두 개 의 요소를 비교하여 정렬을 하며, 정렬 방식은 다음과 같다.</p><ul><li>f(a, b) &lt; 0 이면 a를 b보다 작은 인덱스로 정렬</li><li>f(a, b) == 0 이면 a와 b의 순서 그대로 둠</li><li>f(a, b) &gt; 0 이면 b를 a보다 작은 인덱스로 정렬</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">15</span>, <span class="number">3</span>, <span class="number">36</span>, <span class="number">2</span>, <span class="number">51</span>, <span class="number">7</span>, <span class="number">19</span>, <span class="number">24</span>];</span><br><span class="line"></span><br><span class="line">numbers.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123; <span class="keyword">return</span> a - b; &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(numbers); </span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 6, 7, 8, 15, 19, 24, 36, 51]</span></span><br></pre></td></tr></table></figure><p>비교함수를 지정하지 않으면 요소를 문자열로 변환하여 사전순(abc)으로 정렬한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fruits = [‘apple’, ‘banana’, ‘melon’, ‘peach’, ‘blueberry’];</span><br><span class="line"></span><br><span class="line">fruits.sort();</span><br><span class="line"><span class="built_in">console</span>.log(fruits); </span><br><span class="line"><span class="comment">// ["apple", "banana", "blueberry", "melon", "peach"]</span></span><br></pre></td></tr></table></figure><p><strong>참고:</strong></p><ul><li><a href="https://ko.javascript.info/array-methods" target="_blank" rel="external nofollow noopener noreferrer">배열과 메서드</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;수정-메서드&quot;&gt;&lt;a href=&quot;#수정-메서드&quot; class=&quot;headerlink&quot; title=&quot;수정 메서드&quot;&gt;&lt;/a&gt;수정 메서드&lt;/h2&gt;&lt;p&gt;배열 메서드는 크게 세 종류로 나눈다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;수정 메서드&lt;/str
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://codeameba.github.io/categories/JavaScript/"/>
    
    
      <category term="til" scheme="http://codeameba.github.io/tags/til/"/>
    
      <category term="TIL" scheme="http://codeameba.github.io/tags/TIL/"/>
    
      <category term="Today I Learned" scheme="http://codeameba.github.io/tags/Today-I-Learned/"/>
    
      <category term="오늘배운것들" scheme="http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"/>
    
      <category term="자바스크립트" scheme="http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"/>
    
      <category term="Javascript" scheme="http://codeameba.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>[TIL] 클로저(Closure) 복습</title>
    <link href="http://codeameba.github.io/2020/05/04/programming/closure-is-very-important/"/>
    <id>http://codeameba.github.io/2020/05/04/programming/closure-is-very-important/</id>
    <published>2020-05-04T10:45:42.000Z</published>
    <updated>2020-05-13T18:03:26.710Z</updated>
    
    <content type="html"><![CDATA[<h2 id="렉시컬-스코핑-Lexical-Scoping"><a href="#렉시컬-스코핑-Lexical-Scoping" class="headerlink" title="렉시컬 스코핑(Lexical Scoping)"></a>렉시컬 스코핑(Lexical Scoping)</h2><p>클로저의 개념을 이해하기 위해서는 우선 렉시컬 스코핑을 이해해야 하며, 렉시컬 스코핑을 이해하기 위해서는 실행 컨텍스트(Execution Context)를 이해할 필요가 있다.</p><p>아래와 같은 코드가 있을 때, 실행 컨텍스트와 렉시컬 스코핑을 단계별로 정리하며 알아보도록 하자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> name = ‘codeAmeba’;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">displayName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">  &#125;</span><br><span class="line">  displayName();</span><br><span class="line">&#125;</span><br><span class="line">init(); <span class="comment">// codeAmeba</span></span><br></pre></td></tr></table></figure><ol><li>글로벌 실행 컨텍스트 생성 -&gt; 렉시컬 환경에 <code>init()</code> 등록</li><li>글로벌 실행 컨텍스트 위에 <code>init()</code> 실행 컨텍스트, 렉시컬 스코프 생성 </li><li><code>init()</code> 렉시컬 환경에 변수와 함수 등록, 외부 환경 참조에 글로벌 렉시컬 환경 등록</li><li><code>init()</code> 실행 컨텍스트 위에 <code>displayName()</code> 실행 컨텍스트, 렉시컬 스코프 생성 </li><li><code>displayName()</code> 외부 환경 참조에 등록된  변수 <code>name</code>을 찾아 로그 실행</li><li><code>displayName()</code> 실행 컨텍스트, 렉시컬 스코프 종료</li><li><code>init()</code> 실행 컨텍스트, 렉시컬 스코프 종료</li></ol><h2 id="클로저-Closure"><a href="#클로저-Closure" class="headerlink" title="클로저(Closure)"></a>클로저(Closure)</h2><p>앞서 살펴본 내용이 일반적인 중첩함수라면, 클로저는 어떤 부분이 다른지 아래의 코드를 살펴보자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> name = ‘codeAmeba’;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">displayName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> displayName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myFunc = makeFunc();</span><br><span class="line">myFunc(); <span class="comment">// codeAmeba</span></span><br></pre></td></tr></table></figure><p><code>displayName()</code>을 리턴한다는 것 외에 큰 차이를 발견하기 어려우나 내부적으로는 클로저만의 차이점이 있다.</p><p><strong>클로저의 컨셉은 실행 컨텍스트 종료 후에도 렉시컬 환경을 유지하는 것에 있다.</strong></p><p>위의 경우에서는,  <code>displayName()</code>이 리턴되어 <code>myFunc</code>에 저장되고, <code>displayName()</code>은 외부 환경 참조를 통해  <code>makeFunc()</code>의 지역변수 <code>name</code>을 참조하고 있다고 볼 수 있다.</p><p><strong>참고:</strong><br>    - <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Closures" target="_blank" rel="external nofollow noopener noreferrer">클로저 - JavaScript | MDN</a><br>    - <a href="https://ko.javascript.info/closure" target="_blank" rel="external nofollow noopener noreferrer">변수의 스코프</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;렉시컬-스코핑-Lexical-Scoping&quot;&gt;&lt;a href=&quot;#렉시컬-스코핑-Lexical-Scoping&quot; class=&quot;headerlink&quot; title=&quot;렉시컬 스코핑(Lexical Scoping)&quot;&gt;&lt;/a&gt;렉시컬 스코핑(Lexical 
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://codeameba.github.io/categories/JavaScript/"/>
    
    
      <category term="til" scheme="http://codeameba.github.io/tags/til/"/>
    
      <category term="TIL" scheme="http://codeameba.github.io/tags/TIL/"/>
    
      <category term="Today I Learned" scheme="http://codeameba.github.io/tags/Today-I-Learned/"/>
    
      <category term="오늘배운것들" scheme="http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"/>
    
      <category term="자바스크립트" scheme="http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"/>
    
      <category term="Javascript" scheme="http://codeameba.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>[TIL] 메서드(method)의 약식 표현과 한계</title>
    <link href="http://codeameba.github.io/2020/04/30/programming/es6-method-expression/"/>
    <id>http://codeameba.github.io/2020/04/30/programming/es6-method-expression/</id>
    <published>2020-04-30T09:45:42.000Z</published>
    <updated>2020-05-13T18:04:19.094Z</updated>
    
    <content type="html"><![CDATA[<p>ES6의 등장으로 말미암아 다양한 문법적 편의성을 누릴 수 있게 되었다. 그 중 하나가 아래와 같은 메서드(method)의 약식 표현이다.</p><ol><li><strong>메서드 약식 표현(ES6에서 추가)</strong><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> robot = &#123;</span><br><span class="line">  name: ‘Coderoid’,</span><br><span class="line">  sayHello() &#123; <span class="built_in">console</span>.log(‘Hello! ‘ + <span class="keyword">this</span>.name); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><p>ES6 이전의 메서드의 표현은 아래와 같았다.</p><ol start="2"><li><strong>ES6 이전의 메서드 표현</strong><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> robot = &#123;</span><br><span class="line">  name: ‘Coderoid’,</span><br><span class="line">  sayHello: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(‘Hello! ‘ + <span class="keyword">this</span>.name); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><p>단순히 <code>key : value</code>  형태의 유무 정도의 차이로 보이지만, 생각보다 중요한 차이가 있다.</p><p>약식표현의 경우 <code>prototype</code>을 지니지 않기 때문에 생성자로 사용할 수 없으며 이말은 곧, <code>new</code> 연산자를 통한 인스턴스의 생성이 불가하다는 말이기도 하다. 또한, 약식표현은 <code>super</code> 키워드를 사용할 수 없다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ES6의 등장으로 말미암아 다양한 문법적 편의성을 누릴 수 있게 되었다. 그 중 하나가 아래와 같은 메서드(method)의 약식 표현이다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;메서드 약식 표현(ES6에서 추가)&lt;/strong&gt;&lt;figure cl
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://codeameba.github.io/categories/JavaScript/"/>
    
    
      <category term="til" scheme="http://codeameba.github.io/tags/til/"/>
    
      <category term="TIL" scheme="http://codeameba.github.io/tags/TIL/"/>
    
      <category term="Today I Learned" scheme="http://codeameba.github.io/tags/Today-I-Learned/"/>
    
      <category term="오늘배운것들" scheme="http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"/>
    
      <category term="자바스크립트" scheme="http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"/>
    
      <category term="Javascript" scheme="http://codeameba.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>[TIL] 프로토타입을 임의로 수정하면 안 되는 이유</title>
    <link href="http://codeameba.github.io/2020/04/22/programming/do-not-modify-prototype/"/>
    <id>http://codeameba.github.io/2020/04/22/programming/do-not-modify-prototype/</id>
    <published>2020-04-22T09:05:42.000Z</published>
    <updated>2020-05-13T18:04:14.940Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.__proto__ === <span class="built_in">Array</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.__proto__.__proto__ === <span class="built_in">Object</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.__proto__.__proto__.__proto__ === <span class="literal">null</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(myFunc.__proto__ === <span class="built_in">Function</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(myFunc.__proto__.__proto__ === <span class="built_in">Object</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(myFunc.__proto__.__proto__.__proto__ === <span class="literal">null</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> num = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num.__proto__ === <span class="built_in">Number</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(num.__proto__.__proto__ === <span class="built_in">Object</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(num.__proto__.__proto__.__proto__ === <span class="literal">null</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myFunc.__proto__.__proto__ === arr.__proto__.__proto__); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(num.__proto__.__proto__ === myFunc.__proto__.__proto__); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>위와 같이 모든 내장 프로토타입은 <code>Object.prototype</code>에서 만나게 되며, 그 끝에는 <code>null</code>이 있다.</p><p>그 말은 곧, 프로토타입 체인을 통해 다른 객체의 메서드를 가져올 수 있다는 것이며, 자주 사용하는 사용자 정의 메서드를 프로토타입에 아예 탑재해버리고 내장 메서드를 쓰듯이 쓸 수도 있다는 것이다.</p><p><strong>하지만, 프로토타입은 전역에 영향을 미치며, 프로토타입에 사용자 정의 메서드를 넣는다는 것은 전역 객체를 만든다는 것이므로 오류와 혼란을 야기한다.</strong></p><p><strong>참고:</strong></p><ul><li><a href="https://ko.javascript.info/native-prototypes" target="_blank" rel="external nofollow noopener noreferrer">네이티브 프로토타입</a></li><li><a href="https://ko.javascript.info/function-prototype" target="_blank" rel="external nofollow noopener noreferrer">함수의 prototype 프로퍼티</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span 
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://codeameba.github.io/categories/JavaScript/"/>
    
    
      <category term="til" scheme="http://codeameba.github.io/tags/til/"/>
    
      <category term="TIL" scheme="http://codeameba.github.io/tags/TIL/"/>
    
      <category term="Today I Learned" scheme="http://codeameba.github.io/tags/Today-I-Learned/"/>
    
      <category term="오늘배운것들" scheme="http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"/>
    
      <category term="자바스크립트" scheme="http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"/>
    
      <category term="Javascript" scheme="http://codeameba.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>[TIL] 구조 분해 할당(destructured assignment)</title>
    <link href="http://codeameba.github.io/2020/04/16/programming/destructured-assignment/"/>
    <id>http://codeameba.github.io/2020/04/16/programming/destructured-assignment/</id>
    <published>2020-04-16T09:05:42.000Z</published>
    <updated>2020-05-13T18:02:49.502Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> member = &#123;</span><br><span class="line">  name: ‘codeAmeba’,</span><br><span class="line">  position: <span class="string">'Front-end'</span>,</span><br><span class="line">  skills: [<span class="string">'HTML'</span>, <span class="string">'CSS'</span>, <span class="string">'JavaScript'</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같은 객체가 있을 때, 객체의 일부만 변수에 할당하여 사용하고 싶은 경우가 종종 있을 것이다. 그리고, 보통은 아래와 같이 할당을 할 것이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = member.name;</span><br><span class="line"><span class="keyword">const</span> position = member.position;</span><br><span class="line"><span class="keyword">const</span> skills = member.skills;</span><br></pre></td></tr></table></figure><p>물론 이렇게 한다고 큰 일이 일어나지는 않지만, <strong>구조 분해 할당(destructured assignment)</strong> 를 활용하면 단 한 줄로 동일한 결과를 낼 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; name, position, skills &#125; = member;</span><br></pre></td></tr></table></figure><p>이와 같은 구조 분해 할당은 객체의 일부를 저장하는 상황에 국한되지 않는다. <strong>배열의 요소를 저장할 때</strong>나 <strong>매개변수에 기본값이 필요한 경우</strong> 등에도 유용하게 쓰인다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> users = [‘codeAmeba’, ‘codeMonkey’];</span><br><span class="line"><span class="keyword">let</span> [firstUser, secondUser] = users;</span><br><span class="line"><span class="built_in">console</span>.log(firstUser); <span class="comment">// codeAmeba</span></span><br></pre></td></tr></table></figure><p>특히, 구조 분해 할당의 몇 가지 포인트만 알면 다양한 상황에 응용이 가능한데, 포인트는 다음과 같다.<br>    1. 할당 연산자 우측에는 모든 이터러블(iterable)이 올 수 있다.<br>    2. 할당 연산자 좌측에는 할당 가능한 모든 것이 올 수 있다.<br>    3. 기본값 설정이 가능하다.</p><ul><li><strong>참고:</strong><ul><li><a href="https://ko.javascript.info/destructuring-assignment" target="_blank" rel="external nofollow noopener noreferrer">구조 분해 할당</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span 
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://codeameba.github.io/categories/JavaScript/"/>
    
    
      <category term="til" scheme="http://codeameba.github.io/tags/til/"/>
    
      <category term="TIL" scheme="http://codeameba.github.io/tags/TIL/"/>
    
      <category term="Today I Learned" scheme="http://codeameba.github.io/tags/Today-I-Learned/"/>
    
      <category term="오늘배운것들" scheme="http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"/>
    
      <category term="자바스크립트" scheme="http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"/>
    
      <category term="Javascript" scheme="http://codeameba.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>[TIL] Factory Function를 쓰는 이유</title>
    <link href="http://codeameba.github.io/2020/04/14/programming/why-use-factory-function/"/>
    <id>http://codeameba.github.io/2020/04/14/programming/why-use-factory-function/</id>
    <published>2020-04-14T10:12:42.000Z</published>
    <updated>2020-05-13T18:09:52.671Z</updated>
    
    <content type="html"><![CDATA[<h2 id="객체-공장"><a href="#객체-공장" class="headerlink" title="객체 공장"></a>객체 공장</h2><p>Factory Function은 이름 그대로 <strong>공장 함수</strong> 인데, 무엇을 생산하는 공장이냐 하면, <strong>객체를 생산하는 공장</strong> 이라고 할 수 있다.<br>물론, ‘객체 리터럴로 만들어도 되는 객체를 굳이 함수까지 써 가면서 만들 필요가 있을까’ 라고 생각할 수도 있겠지만, 그건 어디까지 한 두 개 정도 소량의 객체일 때 이야기다. 예를 들어 SNS를 서비스한다고 했을 때 유저의 가입 정보를 받아 객체에 저장하는 경우라면 일일이 객체를 만들기 보다는 Factory Function에 유저 정보에 해당하는 parameter를 할당하여 유저가 가입할 때마다 자동으로 객체를 생산하도록 하는 편이 훨씬 효율적일 것이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userInfo = <span class="function">(<span class="params">id, name, image</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    id,</span><br><span class="line">    name,</span><br><span class="line">    image,</span><br><span class="line">    friends: [],</span><br><span class="line">    posts: [],</span><br><span class="line">    addFriend(friend) &#123;</span><br><span class="line">      <span class="keyword">this</span>.friends.push(friend);</span><br><span class="line">    &#125;,</span><br><span class="line">    createPost(post) &#123;</span><br><span class="line">      <span class="keyword">this</span>.posts.push(post);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newUser = userInfo(‘codeAmeba’, ‘Sooyoung Jeong’, ‘codeameba.jpg’);</span><br><span class="line"><span class="built_in">console</span>.log(newUser.id); <span class="comment">// codeAmeba</span></span><br><span class="line"></span><br><span class="line">newUser.addFriend(‘codeMonkey’);</span><br><span class="line"><span class="built_in">console</span>.log(newUser.friends); <span class="comment">// ["codeMonkey"]</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;객체-공장&quot;&gt;&lt;a href=&quot;#객체-공장&quot; class=&quot;headerlink&quot; title=&quot;객체 공장&quot;&gt;&lt;/a&gt;객체 공장&lt;/h2&gt;&lt;p&gt;Factory Function은 이름 그대로 &lt;strong&gt;공장 함수&lt;/strong&gt; 인데, 무엇을 생산
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://codeameba.github.io/categories/JavaScript/"/>
    
    
      <category term="til" scheme="http://codeameba.github.io/tags/til/"/>
    
      <category term="TIL" scheme="http://codeameba.github.io/tags/TIL/"/>
    
      <category term="Today I Learned" scheme="http://codeameba.github.io/tags/Today-I-Learned/"/>
    
      <category term="오늘배운것들" scheme="http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"/>
    
      <category term="자바스크립트" scheme="http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"/>
    
      <category term="Javascript" scheme="http://codeameba.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>[TIL] 화살표 함수는 편리하지만 메서드에는 자제할 것!</title>
    <link href="http://codeameba.github.io/2020/04/12/programming/arrow-function-dont-using-method/"/>
    <id>http://codeameba.github.io/2020/04/12/programming/arrow-function-dont-using-method/</id>
    <published>2020-04-12T11:12:42.000Z</published>
    <updated>2020-05-13T18:03:21.836Z</updated>
    
    <content type="html"><![CDATA[<h2 id="일급객체-자바스크립트-함수"><a href="#일급객체-자바스크립트-함수" class="headerlink" title="일급객체 자바스크립트 함수"></a>일급객체 자바스크립트 함수</h2><p>자바스크립트에서 함수는 일급객체이기에 어디든 들어갈 수 있다. 값으로도 들어가고, 파라미터로도 들어가고, 배열에도 들어가며, 객체에도 들어갈 수 있다.</p><ul><li><a href="https://codeameba.github.io/2019/05/17/programming/first-class-object/">JavaScript Preview 함수는 퍼스트 클래스? | AmebaLab</a></li></ul><h2 id="편리한-화살표-함수"><a href="#편리한-화살표-함수" class="headerlink" title="편리한 화살표 함수"></a>편리한 화살표 함수</h2><p>ES6에서 등장한 여러 문법들이 있지만, 여러모로 인상적이고 사랑 받는 문법은 단연 <strong>화살표 함수(Arrow Function)</strong> 이 아닐까 싶다. 조금만 익숙해지면, 배열 메서드 등에 편리하게 쓸 수 있으니 말이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nums = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">15</span>, <span class="number">37</span>, <span class="number">42</span>, <span class="number">68</span>, <span class="number">73</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> underOfFifty = nums.filter(<span class="function"><span class="params">num</span> =&gt;</span> num &lt; <span class="number">50</span>);</span><br><span class="line"><span class="keyword">const</span> multiplyTen = nums.map(<span class="function"><span class="params">num</span> =&gt;</span> num * <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Under Of 50: <span class="subst">$&#123;underOfFifty&#125;</span>, Multiply 10: <span class="subst">$&#123;multiplyTen&#125;</span>`</span>);</span><br><span class="line"><span class="comment">// Under Of 50: 3,5,7,15,37,42, Multiply 10: 30,50,70,150,370,420,680,730</span></span><br></pre></td></tr></table></figure><h2 id="메서드와-생성자에는-참아주세요"><a href="#메서드와-생성자에는-참아주세요" class="headerlink" title="메서드와 생성자에는 참아주세요!"></a>메서드와 생성자에는 참아주세요!</h2><p>이토록 편리한 화살표 함수지만 사용을 자제해야 하는 경우가 더러 있다.</p><h3 id="1-메서드에는-화살표-함수-금지"><a href="#1-메서드에는-화살표-함수-금지" class="headerlink" title="1. 메서드에는 화살표 함수 금지"></a>1. 메서드에는 화살표 함수 금지</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> robot = &#123;</span><br><span class="line">  name: ‘Coderoid’,</span><br><span class="line">  sayHi: <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">`Hi, <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>) &#125;,</span><br><span class="line">  sayBye: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Bye, <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">robot.sayHi(); <span class="comment">// Hi,</span></span><br><span class="line">robot.sayBye(); <span class="comment">// Bye, Coderoid</span></span><br></pre></td></tr></table></figure><p>위와 같이 <code>function</code>키워드를 사용한 메서드는 일반적으로 알려진대로 <code>this</code>가 점(.) 앞의 객체에 제대로 바인딩 되어 있지만, 화살표 함수로 만들어진 메서드는 그렇지 않다.</p><p>그렇다면, 화살표 함수의 <code>this</code>는 어디에 바인딩 되어있는 것일까? 아래의 코드를 통해 알아보자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(robot, ‘sayHi’, &#123;</span><br><span class="line">  <span class="keyword">get</span>: () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">robot[‘sayHi’];</span><br><span class="line"><span class="comment">// Window &#123;parent: Window, opener: null, top: Window, length: 0, frames: Window, …&#125;</span></span><br></pre></td></tr></table></figure><p>그렇다, 호출한 객체가 아닌 <code>window</code> 전역객체를 가리키고 있다.</p><h3 id="2-생성자에는-화살표-함수-금지"><a href="#2-생성자에는-화살표-함수-금지" class="headerlink" title="2. 생성자에는 화살표 함수 금지"></a>2. 생성자에는 화살표 함수 금지</h3><p>생성자에서 화살표 함수를 쓰게 되면 아래와 같은 오류가 발생한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Robot = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> robot = <span class="keyword">new</span> Robot();</span><br><span class="line"><span class="comment">// Uncaught TypeError: Robot is not a constructor</span></span><br></pre></td></tr></table></figure><h3 id="3-화살표-함수에는-프로토타입-prototype-이-없다"><a href="#3-화살표-함수에는-프로토타입-prototype-이-없다" class="headerlink" title="3. 화살표 함수에는 프로토타입(prototype)이 없다"></a>3. 화살표 함수에는 프로토타입(prototype)이 없다</h3><p>또한, 프로토타입 체인을 통한 프로퍼티의 위임 등을 할 수 있는 프로토타입이 화살표 함수에는 없다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Robot = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(Robot.prototype); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Rocket = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(Rocket.prototype); <span class="comment">// &#123;constructor: ƒ&#125;</span></span><br></pre></td></tr></table></figure><p>위와 같이 화살표 함수의 프로토타입은 <code>undefined</code>가 출력되고, 일반 함수의 프로토타입은 존재하는 것을 확인할 수 있다.</p><h3 id="4-yield-키워드를-쓸-수-없다"><a href="#4-yield-키워드를-쓸-수-없다" class="headerlink" title="4. yield 키워드를 쓸 수 없다"></a>4. yield 키워드를 쓸 수 없다</h3><p><code>yield</code> 키워드는 제너레이터(generator) 함수 내부의 여러 값을 필요에 따라 하나씩 반환할 수 있게 해주는데, 이러한 <code>yield</code> 키워드를 화살표 함수에서는 사용할 수가 없다. 그 말은 곧 <strong>화살표 함수는 제너레이터로 쓸 수 없다는 말</strong> 이기도 하다.</p><ul><li><strong>참고:</strong><ul><li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Functions/%EC%95%A0%EB%A1%9C%EC%9A%B0_%ED%8E%91%EC%85%98" target="_blank" rel="external nofollow noopener noreferrer">화살표 함수 - JavaScript | MDN</a></li><li><a href="https://ko.javascript.info/generators" target="_blank" rel="external nofollow noopener noreferrer">제너레이터</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;일급객체-자바스크립트-함수&quot;&gt;&lt;a href=&quot;#일급객체-자바스크립트-함수&quot; class=&quot;headerlink&quot; title=&quot;일급객체 자바스크립트 함수&quot;&gt;&lt;/a&gt;일급객체 자바스크립트 함수&lt;/h2&gt;&lt;p&gt;자바스크립트에서 함수는 일급객체이기에 어
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://codeameba.github.io/categories/JavaScript/"/>
    
    
      <category term="til" scheme="http://codeameba.github.io/tags/til/"/>
    
      <category term="TIL" scheme="http://codeameba.github.io/tags/TIL/"/>
    
      <category term="Today I Learned" scheme="http://codeameba.github.io/tags/Today-I-Learned/"/>
    
      <category term="오늘배운것들" scheme="http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"/>
    
      <category term="자바스크립트" scheme="http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"/>
    
      <category term="Javascript" scheme="http://codeameba.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>[TIL] 자주 쓰지 않지만 알면 유용한 배열 메서드</title>
    <link href="http://codeameba.github.io/2020/04/12/programming/til-some-every/"/>
    <id>http://codeameba.github.io/2020/04/12/programming/til-some-every/</id>
    <published>2020-04-11T15:41:42.000Z</published>
    <updated>2020-05-13T18:08:58.718Z</updated>
    
    <content type="html"><![CDATA[<h2 id="every"><a href="#every" class="headerlink" title=".every()"></a>.every()</h2><ul><li><code>every()</code> 메서드는 배열 안의 모든 요소가 주어진 판별 함수를 통과하는지 테스트합니다. (MDN)</li><li>간단히 말하자면, 요소 하나라도 조건식을 통과하지 못하면  <code>false</code>를 반환하고, 모든 요소가 조건식을 만족하면 <code>true</code>를 반환한다.</li><li>빈 배열일 경우에는 무조건 <code>true</code>를 반환한다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> animals = [<span class="string">'bears'</span>, <span class="string">'cats'</span>, <span class="string">'dogs'</span>, <span class="string">'elephants'</span>, <span class="string">'giraffes'</span>];</span><br><span class="line">animals.every(<span class="function"><span class="params">animal</span> =&gt;</span> animal.length &lt; <span class="number">5</span>); <span class="comment">// false</span></span><br><span class="line">animals.every(<span class="function"><span class="params">animal</span> =&gt;</span> animal.length &lt; <span class="number">10</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> beers = [];</span><br><span class="line">beers.every(<span class="function"><span class="params">beer</span> =&gt;</span> beer === ‘beer’); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><strong>참고:</strong><ul><li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/every" target="_blank" rel="external nofollow noopener noreferrer">Array.prototype.every() - JavaScript | MDN</a></li></ul></li></ul><h2 id="some"><a href="#some" class="headerlink" title=".some()"></a>.some()</h2><ul><li><code>every()</code> 메서드와 비슷하면서 다르다.</li><li>배열의 요소 중 <strong>단 하나라도</strong> 조건식을 통과하면 <code>true</code> 를 반환한다.</li><li>빈 배열의 경우는 무조건 <code>false</code>를 반환한다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nums = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">23</span>, <span class="number">37</span>, <span class="number">55</span>];</span><br><span class="line">nums.some(<span class="function"><span class="params">num</span> =&gt;</span> num &gt; <span class="number">50</span>); <span class="comment">// true</span></span><br><span class="line">nums.some(<span class="function"><span class="params">num</span> =&gt;</span> num &gt; <span class="number">60</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> beers = [];</span><br><span class="line">beers.some(<span class="function"><span class="params">beer</span> =&gt;</span> beer === <span class="string">'beer'</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li><strong>참고:</strong><ul><li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/some" target="_blank" rel="external nofollow noopener noreferrer">Array.prototype.some() - JavaScript | MDN</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;every&quot;&gt;&lt;a href=&quot;#every&quot; class=&quot;headerlink&quot; title=&quot;.every()&quot;&gt;&lt;/a&gt;.every()&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;every()&lt;/code&gt; 메서드는 배열 안의 모든 요소가 주어진 판별 
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://codeameba.github.io/categories/JavaScript/"/>
    
    
      <category term="til" scheme="http://codeameba.github.io/tags/til/"/>
    
      <category term="TIL" scheme="http://codeameba.github.io/tags/TIL/"/>
    
      <category term="Today I Learned" scheme="http://codeameba.github.io/tags/Today-I-Learned/"/>
    
      <category term="오늘배운것들" scheme="http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"/>
    
      <category term="자바스크립트" scheme="http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"/>
    
      <category term="Javascript" scheme="http://codeameba.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript Fundamental 04(마지막 업데이트: 20.04.18)</title>
    <link href="http://codeameba.github.io/2020/04/07/programming/js-fundamental-04/"/>
    <id>http://codeameba.github.io/2020/04/07/programming/js-fundamental-04/</id>
    <published>2020-04-07T09:30:42.000Z</published>
    <updated>2020-05-13T18:05:56.006Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS-Study"><a href="#JS-Study" class="headerlink" title="JS Study"></a>JS Study</h1><ul><li>자바스크립트를 다시 공부하며 놓쳤던 개념들을 정리함.</li><li>교재: 모던 자바스크립트 입문(이소 히로시 지음)</li></ul><hr><h2 id="프로토타입-체인-prototype-chain"><a href="#프로토타입-체인-prototype-chain" class="headerlink" title="프로토타입 체인(prototype chain)"></a>프로토타입 체인(prototype chain)</h2><ul><li>자바스크립트의 모든 객체는 <code>[[Prototype]]</code>이라고 하는 <strong>내부 슬롯(internal slot)</strong>을 지닌다.</li><li>하위 객체는 상위 객체의 <code>prototype</code>을 상속받으며, 상속받은 데이터는 <code>__proto__</code>에 저장된다.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myCat = &#123;</span><br><span class="line">  name: <span class="string">'Lucy'</span>,</span><br><span class="line">  sayHello: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'Hello! '</span> + <span class="keyword">this</span>.name); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> yourCat = &#123;</span><br><span class="line">  name: <span class="string">'Tom'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">yourCat.__proto__ = myCat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> whoseCat = &#123;&#125;;</span><br><span class="line">whoseCat.__proto__ = yourCat;</span><br><span class="line"></span><br><span class="line">whoseCat.sayHello(); <span class="comment">// Hello! Tom</span></span><br></pre></td></tr></table></figure><ul><li>위와 같이 <code>__proto__</code>를 통해 하위 객체와 상위 객체가 이어져 있으며, 이를 <strong>프로토타입 체인</strong> 이라고 한다. 그리고, 자신과 가까운 객체의 프로퍼티부터 위로 거슬러 올라가며 검색하게 된다.</li></ul><h3 id="Object-getPrototypeOF"><a href="#Object-getPrototypeOF" class="headerlink" title="Object.getPrototypeOF()"></a>Object.getPrototypeOF()</h3><ul><li><p>ES 명세에서나 브라우저에서나 <code>__proto__</code>를 통한 접근은 권장하지 않는다.</p></li><li><p>따라서 프로토타입 메서드에 접근해야 할 때에는 <code>Object.getPrototypeOf()</code> 또는 <code>Object.creat()</code>를 활용하도록 하자.</p></li><li><p><strong>참고:</strong></p><ul><li><a href="https://poiemaweb.com/js-prototype" target="_blank" rel="external nofollow noopener noreferrer">poiemaweb - 프로토타입</a></li><li><a href="https://poiemaweb.com/es6-class" target="_blank" rel="external nofollow noopener noreferrer">poiemaweb - 클래스</a></li><li><a href="https://ko.javascript.info/prototype-inheritance" target="_blank" rel="external nofollow noopener noreferrer">코어자바스크립트 - 프로토타입 상속</a></li></ul></li></ul><h2 id="접근자-프로퍼티"><a href="#접근자-프로퍼티" class="headerlink" title="접근자 프로퍼티"></a>접근자 프로퍼티</h2><ul><li>일반적으로 값 을 가져올 때 쓰는 접근자 프로퍼티를 <code>getter</code>, 값을 수정할 때 쓰는 접근자 프로퍼티를 <code>setter</code>라고 부른다.</li><li><strong>접근자 프로퍼티를 사용하는 이유</strong><ul><li>객체 밖에서 객체의 프로퍼티를 직접적으로 읽거나 쓰는 행위는 데이터의 유지 보수성을 해친다.</li><li>따라서, 객체가 가진 프로퍼티 값을 읽고 쓸 수 있는 특정 프로퍼티가 <code>getter</code>와 <code>setter</code>이다.</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  _name: <span class="string">'Tom'</span>,</span><br><span class="line">  <span class="keyword">get</span> name() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._name;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span> name(value) &#123;</span><br><span class="line">    <span class="keyword">const</span> str = value.charAt(<span class="number">0</span>).toUpperCase() + value.substring(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">this</span>._name = str;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// Tom</span></span><br><span class="line">person.name = <span class="string">'jane'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// Jane</span></span><br></pre></td></tr></table></figure><ul><li>접근자 프로퍼티가 없는 객체에 접근자 프로퍼티를 추가하거나 정의할 때에는 <code>Object.defineProperty</code>나 <code>Object.defineProperties</code> 메서드를 사용한다.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(user, <span class="string">'name'</span>, &#123;</span><br><span class="line">  <span class="keyword">get</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._name;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>(value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value.length &lt; <span class="number">4</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Too short! more than 4 characters'</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>._name = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">user.name = <span class="string">'Peter'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(user.name); <span class="comment">// Peter</span></span><br><span class="line"></span><br><span class="line">user.name = <span class="string">'Li'</span>; <span class="comment">// Too short! more than 4 characters</span></span><br></pre></td></tr></table></figure><ul><li><strong>참고:</strong><ul><li><a href="https://ko.javascript.info/property-accessors#ref-614" target="_blank" rel="external nofollow noopener noreferrer">프로퍼티 getter와 setter</a></li></ul></li></ul><h2 id="프로퍼티의-내부-속성"><a href="#프로퍼티의-내부-속성" class="headerlink" title="프로퍼티의 내부 속성"></a>프로퍼티의 내부 속성</h2><p>프로퍼티는 다음과 같은 세 가지 내부 속성을 논리값으로 갖는다.</p><ul><li>writable(쓰기 가능 여부)</li><li>enumerable(열거 가능 여부)</li><li>configurable(재정의 가능 여부)</li></ul><p><strong>별도의 설정 없이 프로퍼티를 추가하면 위의 세 가지 내부 속성이 모두 <code>true</code>인 상태로 생성된다.</strong></p><h3 id="Object-getOwnPropertyDescriptor"><a href="#Object-getOwnPropertyDescriptor" class="headerlink" title="Object.getOwnPropertyDescriptor"></a>Object.getOwnPropertyDescriptor</h3><p>또한, 값을 지닌 <strong>데이터 프로퍼티</strong> 와 <code>get</code>과 <code>set</code>을 지닌 <strong>접근자 프로퍼티</strong> 는 <code>Object.getOwnPropertyDescriptor</code>를 통해 확인했을 때 아래와 같은 차이가 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> robot = &#123;</span><br><span class="line">  _name: <span class="string">'coderoid'</span>,</span><br><span class="line">  serialNumber: <span class="number">1543</span>,</span><br><span class="line">  <span class="keyword">get</span> name() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>._name);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span> name(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>._name = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 데이터 프로퍼티의 프로퍼티 디스크립터</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(robot, <span class="string">'serialNumber'</span>));</span><br><span class="line"><span class="comment">// &#123;value: 1543, writable: true, enumerable: true, configurable: true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 접근자 프로퍼티의 프로퍼티 디스크립터</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(robot, <span class="string">'name'</span>));</span><br><span class="line"><span class="comment">// &#123;enumerable: true, configurable: true, get: ƒ, set: ƒ&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h3><p>이와 같은 <strong>세 가지 속성은 임의로 설정이 가능</strong> 한데, <code>Object.defineProperty</code>를 사용하면 된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> spaceShip = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(spaceShip, <span class="string">'name'</span>, &#123;</span><br><span class="line">  value: <span class="string">'codeship'</span>,</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  enumerable: <span class="literal">false</span>,</span><br><span class="line">  configurable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(spaceShip, <span class="string">'name'</span>));</span><br><span class="line"><span class="comment">// &#123;value: "codeship", writable: true, enumerable: false, configurable: false&#125;</span></span><br></pre></td></tr></table></figure><p><code>Object.defineProperty</code>를 사용할 때 생략된 속성은 <code>false</code> 혹은 <code>undefined</code>로 설정된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> spaceShip = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(spaceShip, <span class="string">'name'</span>, &#123;</span><br><span class="line">  value: <span class="string">'codeship'</span>,</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(spaceShip, <span class="string">'name'</span>));</span><br><span class="line"><span class="comment">// &#123;value: "codeship", writable: true, enumerable: false, configurable: true&#125;</span></span><br></pre></td></tr></table></figure><p>그리고, <code>configurable</code> 속성이 <code>true</code>일 때에만 생략된 속성을 추가하거나 변경할 수 있다. <code>configurable</code>이 생략된 경우에는 자동으로 <code>false</code>가 설정되므로 생략된 속성의 추가 및 변경이 불가하다.<br><code>configurable</code>이 <code>false</code>인데 속성을 추가 및 변경하려고 할 경우 <code>Uncaught TypeError: Cannot redefine property</code>가 뜬다.</p><p>단, <code>configurable</code>이 <code>false</code>더라도, <strong>단 한 번 <code>writable</code>의 값을 <code>true</code>에서 <code>false</code>로 수정 가능하며, <code>false</code>에서 <code>true</code>로 수정은 불가하다.</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> spaceShip = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(spaceShip, <span class="string">'name'</span>, &#123;</span><br><span class="line">  value: <span class="string">'codeship'</span>,</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  enumerable: <span class="literal">false</span>,</span><br><span class="line">  configurable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(spaceShip, <span class="string">'name'</span>));</span><br><span class="line"><span class="comment">// &#123;value: "codeship", writable: true, enumerable: false, configurable: true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(spaceShip, <span class="string">'name'</span>, &#123;</span><br><span class="line">  enumerable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(spaceShip, <span class="string">'name'</span>));</span><br><span class="line"><span class="comment">// &#123;value: "codeship", writable: true, enumerable: true, configurable: true&#125;</span></span><br></pre></td></tr></table></figure><ul><li><strong>참고:</strong><ul><li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor" target="_blank" rel="external nofollow noopener noreferrer">Object.getOwnPropertyDescriptor() - JavaScript | MDN</a></li><li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="external nofollow noopener noreferrer">Object.defineProperty() - JavaScript | MDN</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JS-Study&quot;&gt;&lt;a href=&quot;#JS-Study&quot; class=&quot;headerlink&quot; title=&quot;JS Study&quot;&gt;&lt;/a&gt;JS Study&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;자바스크립트를 다시 공부하며 놓쳤던 개념들을 정리함.&lt;/li&gt;
&lt;li&gt;교
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://codeameba.github.io/categories/JavaScript/"/>
    
    
      <category term="til" scheme="http://codeameba.github.io/tags/til/"/>
    
      <category term="TIL" scheme="http://codeameba.github.io/tags/TIL/"/>
    
      <category term="Today I Learned" scheme="http://codeameba.github.io/tags/Today-I-Learned/"/>
    
      <category term="오늘배운것들" scheme="http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"/>
    
      <category term="자바스크립트" scheme="http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"/>
    
      <category term="Javascript" scheme="http://codeameba.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript Fundamental 03(마지막 업데이트: 20.03.24)</title>
    <link href="http://codeameba.github.io/2020/03/24/programming/js-fundamental-03/"/>
    <id>http://codeameba.github.io/2020/03/24/programming/js-fundamental-03/</id>
    <published>2020-03-24T09:30:42.000Z</published>
    <updated>2020-05-13T18:05:51.863Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS-Study"><a href="#JS-Study" class="headerlink" title="JS Study"></a>JS Study</h1><ul><li>자바스크립트를 다시 공부하며 놓쳤던 개념들을 정리함.</li><li>교재: 모던 자바스크립트 입문(이소 히로시 지음)</li></ul><hr><h2 id="실행-컨텍스트-Execution-Centext"><a href="#실행-컨텍스트-Execution-Centext" class="headerlink" title="실행 컨텍스트(Execution Centext)"></a>실행 컨텍스트(Execution Centext)</h2><ul><li>자바스크립트 엔진은 실행 가능한 코드(Executable Code)를 만나면 그 코드를 평가(Evaluation)하여 실행 컨텍스트(Execution Context)를 만든다.</li><li>실행 컨텍스트는, 실행 가능한 코드가 실제로 실행되고 관리되는 영역이다.</li><li>실행에 필요한 모든 정보를 여러 컴포넌트에 나누어서 관리함.<ul><li>렉시컬 환경(Lexical Environment)<ul><li>환경 레코드(Environment Record)<ul><li>선언적 환경 레코드(Declarative Environment Record)</li><li>객체 환경 레코드(Object Environment Record)</li></ul></li><li>외부 렉시컬 환경 참조(Outer Lexical Environment Reference)</li></ul></li><li>변수 환경(Variable Environment)</li><li>디스 바인딩(This Binding)</li></ul></li></ul><p><strong>실행 컨텍스트의 구조를 의사 코드로 표현하면 아래와 같다.</strong></p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 실행 컨텍스트의 구조를 보여주는 pseudo code</span></span><br><span class="line">ExecutionContext = &#123;</span><br><span class="line">  LexicalEnvironment: &#123;</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      DeclarativeEnvironmentRecord: &#123;&#125;,</span><br><span class="line">      ObjectEnvironmentRecord: &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    OuterLexicalEnvironmentReference: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  VariableEnvironment: &#123;&#125;,</span><br><span class="line">  ThisBinding: <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>참고:</strong><ul><li><a href="https://www.zerocho.com/category/Javascript/post/5740531574288ebc5f2ba97e" target="_blank" rel="external nofollow noopener noreferrer">(JavaScript) 함수의 범위(scope) - lexical scoping - ZeroCho Blog</a></li><li><a href="https://www.zerocho.com/category/Javascript/post/5741d96d094da4986bc950a0" target="_blank" rel="external nofollow noopener noreferrer">(JavaScript) 실행 컨텍스트 - 클로저와 호이스팅 - ZeroCho Blog</a></li><li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Closures" target="_blank" rel="external nofollow noopener noreferrer">클로저 - JavaScript | MDN</a></li><li><a href="https://medium.com/free-code-camp/execution-context-and-the-call-stack-visually-illustrated-by-a-slice-of-tasty-cake-14f9a64dc460" target="_blank" rel="external nofollow noopener noreferrer">Execution context and the call stack — visually illustrated by a slice of tasty cake</a></li><li><a href="https://blog.bitsrc.io/understanding-execution-context-and-execution-stack-in-javascript-1c9ea8642dd0" target="_blank" rel="external nofollow noopener noreferrer">Understanding Execution Context and Execution Stack in Javascript</a></li></ul></li></ul><h2 id="렉시컬-환경-Lexical-Environment"><a href="#렉시컬-환경-Lexical-Environment" class="headerlink" title="렉시컬 환경(Lexical Environment)"></a>렉시컬 환경(Lexical Environment)</h2><ul><li>자바스크립트 엔진이 코드를 실행하기 위해 자원을 모아 둔 곳</li><li>해당 유효 범위(Scope) 안에 있는 식별자와 식별자가 가리키는 값을 <code>key : value</code>의 형태로 바인드하여 렉시컬 환경 컴포넌트에 기록한다.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LexicalEnvironment: &#123;</span><br><span class="line">  EnvironmentRecord: &#123;&#125;,</span><br><span class="line">  OuterLexicalEnvironmentReference: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>렉시컬 환경 컴포넌트에는 위와 같이 <strong>환경 레코드(Environment Record)</strong> 와 <strong>외부 렉시컬 환경 참조(Outer Lexical Environment Reference)</strong> 가 있다.<ul><li>환경 레코드: 유효 범위 내의 식별자와 값이 기록되어 있으며, 함수가 호출되면 1차적으로 이곳에서 식별자를 탐색한다.</li><li>외부 렉시컬 환경 참조: 유효 범위 너머의 식별자와 값이 기록되어 있는 곳으로, 환경 레코드에서 해당 식별자를 찾을 수 없을 때 외부 렉시컬 환경 참조를 탐색하게 된다.</li></ul></li><li>최상위의 렉시컬 환경은 <strong>전역 환경(Global Environment)</strong> 과 바인딩되어 있으며, 이곳에서의 외부 렉시컬 환경 참조는 <code>null</code>이다.</li><li><strong>결국 호이스팅(Hoisting)은, 자바스크립트의 식별자들이 해당 스코프의 렉시컬 환경에 등록된 결과라고 볼 수 있다.</strong></li></ul><h2 id="콜-스택-Call-Stack"><a href="#콜-스택-Call-Stack" class="headerlink" title="콜 스택(Call Stack)"></a>콜 스택(Call Stack)</h2><blockquote><p>후입선출(LIFO, Last In First Out) 방식으로 아래부터 데이터를 쌓아 올려 가장 마지막에 추가된 데이터부터 내보내는 자료구조를 <strong>스택(Stack)</strong> 이라고 한다.<br>이때, 데이터를 쌓는 행위를 <strong>push</strong> 라고 하고, 스택의 가장 윗부분에서 데이터를 꺼내는 행위를 <strong>pop</strong> 이라고 한다.</p></blockquote><ul><li><p>실행 컨텍스트(Execution Context)는 프로그램 실행 중 스택에 push되어 실행이 된다. 이때, 전역 코드(Global Execution Context)는 브라우저의 시작과 동시에 실행되어 브라우저를 종료할 때까지 스택의 가장 아래에 위치한다.</p></li><li><p>함수가 호출되면, 해당 실행 컨텍스트가 스택에 push 되어 실행되며, 해당 함수의 작업이 끝나면 호출했던 부분으로 제어권이 돌아오면서 스택에서 pop 된다. 이처럼 함수가 호출(Call)될 때마다 스택에 쌓인다 하여 <strong>콜 스택(Call Stack)</strong> 이라고 부른다.</p></li><li><p><strong>참고:</strong></p><ul><li><a href="https://joshua1988.github.io/web-development/translation/javascript/how-js-works-inside-engine/" target="_blank" rel="external nofollow noopener noreferrer">자바스크립트의 동작원리: 엔진, 런타임, 호출 스택 • Captain Pangyo</a></li></ul></li></ul><h2 id="스코프-체인-Scope-Chain"><a href="#스코프-체인-Scope-Chain" class="headerlink" title="스코프 체인(Scope Chain)"></a>스코프 체인(Scope Chain)</h2><ul><li>내부 스코프의 렉시컬 환경에서 필요한 식별자를 찾을 수 없을 때 외부 스코프의 렉시컬 환경을 점진적으로 탐색하게 되는데, 이처럼 렉시컬 환경을 매개로 내부와 외부의 스코프가 이어진 것을 <strong>스코프 체인(Scope Chain)</strong> 이라고 부른다.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">'A'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="string">'B'</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> c = <span class="string">'C'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a + b + c);</span><br><span class="line">  &#125;</span><br><span class="line">  g();</span><br><span class="line">&#125;</span><br><span class="line">f(); <span class="comment">// ABC</span></span><br></pre></td></tr></table></figure><p><strong>위와 같은 중첩 함수가 있을 때, 식별자 탐색 과정을 단계별로 알아보자면 다음과 같다.</strong></p><ol><li><code>g()</code>의 렉시컬 환경의 선언적 환경 레코드(Declarative Environment Record)에서 식별자 <code>c</code>를 찾는다.</li><li><code>g()</code>의 선언적 환경 레코드에서 식별자 <code>b</code>를 찾지만 못 찾고, <code>g()</code>의 외부 렉시컬 환경 참조(Outer Lexical Environment Reference)에 기록된 상위 함수 <code>f()</code>로 이동하여 탐색한다.</li><li><code>f()</code>의 렉시컬 환경의 선언적 환경 레코드에서 식별자 <code>b</code>를 찾는다.</li><li><code>f()</code>의 선언적 환경 레코드에서 식별자 <code>a</code>를 찾지만 못 찾고, <code>f()</code>의 외부 렉시컬 환경 참조에 기록된 전역 렉시컬 환경(Global Lexical Environment)로 이동하여 탐색한다.</li><li>전역 렉시컬 환경의 객체 환경 레코드(Object Environment Record)에서 식별자 <code>a</code>를 발견한다. 이때의 외부 렉시컬 환경 참조는 <code>null</code>이다.</li></ol><ul><li><strong>참고:</strong><ul><li><a href="https://poiemaweb.com/js-scope" target="_blank" rel="external nofollow noopener noreferrer">Scope | PoiemaWeb</a></li></ul></li></ul><h2 id="스코프-scope-와-실행-컨텍스트-execution-context-의-차이"><a href="#스코프-scope-와-실행-컨텍스트-execution-context-의-차이" class="headerlink" title="스코프(scope)와 실행 컨텍스트(execution context)의 차이"></a>스코프(scope)와 실행 컨텍스트(execution context)의 차이</h2><ul><li>스코프는 변수의 <strong>유효 범위</strong> 이며, 실행 컨텍스트는 실행되는 코드 덩어리라는 추삭적 개념.</li><li>스코프는 함수가 <strong>정의될 때</strong> 결정되며, 실행 컨텍스트는 함수가 <strong>실행될 때</strong> 생성된다.</li></ul><h2 id="함수의-실행-절차"><a href="#함수의-실행-절차" class="headerlink" title="함수의 실행 절차"></a>함수의 실행 절차</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  inner();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">outer();</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p><strong>위와 같은 코드가 있을 때 내부적인 실행 절차는 다음과 같다.</strong></p><ol><li>전역 실행 컨텍스트 생성</li><li>전역 변수 <code>a</code> 선언(호이스팅)</li><li>외부 함수 <code>outer</code> 선언(호이스팅)</li><li>변수 <code>a</code>에 1 할당</li><li><code>outer</code> 함수 호출 및 <code>outer</code> 실행 컨텍스트 생성</li><li>함수 <code>inner</code> 선언(<code>outer</code> 스코프에서 호이스팅)</li><li><code>outer</code> 스코프에서 <code>a</code> 탐색하지만 찾을 수 없으므로 전역 스코프에서 재탐색 후 1 출력</li><li>중첩 함수 <code>inner</code> 호출 및 <code>inner</code> 실행 컨텍스트 생성</li><li>지역 변수 <code>a</code> 선언(<code>inner</code> 스코프에서 호이스팅)</li><li><code>inner</code> 스코프에서 <code>a</code> 탐색 후 출력하지만 호이스팅만 된 단계이므로 <code>undefined</code> 출력</li><li>지역 변수 <code>a</code>에 3 할당</li><li><code>inner</code> 실행 컨텍스트 종료</li><li>제어권이 <code>outer</code> 실행 컨텍스트로 돌아오며 전역 스코프에서 변수 <code>a</code> 탐색 후 1 출력</li><li><code>outer</code> 실행 컨텍스트 종료</li><li>전역 스코프에서 변수 <code>a</code> 탐색 후 1 출력</li></ol><h2 id="가비지-컬렉션-garbage-collection"><a href="#가비지-컬렉션-garbage-collection" class="headerlink" title="가비지 컬렉션(garbage collection)"></a>가비지 컬렉션(garbage collection)</h2><ul><li><p>자바스크립트 엔진 내부에는 <strong>가비지 컬렉터(garbage collector)</strong> 가 쉬지 않고 동작하며, <strong>참조가 없는 객체를 메모리에서 해제한다.</strong> 그리고, 이러한 매커니즘을 가비지 컬렉션이라고 한다.</p></li><li><p>가비지 컬렉터 덕분에 메모리의 공간 확보를 직접 하지 않아도 되는 만큼 메모리에는 크게 신경 쓰지 않아도 되지만, 메모리 누수로 인해 퍼포먼스가 저하될 가능성이 없지 않기 때문에 전혀 고려하지 않아도 되는 것은 아니다.</p></li><li><p><strong>참고:</strong></p><ul><li><a href="https://ko.javascript.info/garbage-collection" target="_blank" rel="external nofollow noopener noreferrer">가비지 컬렉션</a></li></ul></li></ul><h2 id="클로저-closure"><a href="#클로저-closure" class="headerlink" title="클로저(closure)"></a>클로저(closure)</h2><ul><li>클로저의 주 사용 목적은 외부로부터 내부의 상태를 숨기는 <strong>캡슐화(encapsulation)</strong> 에 있다.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 보통은 익명함수를 사용하지만, 편의를 위해 이름을 붙임</span></span><br><span class="line">    <span class="keyword">return</span> count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> counter = makeCounter();</span><br><span class="line"><span class="built_in">console</span>.log(counter()); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(counter()); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(counter()); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p><strong>위와 같은 클로저가 있을 때 다음과 같은 특징을 알 수 있다.</strong></p><ol><li>외부 함수 <code>makeCounter</code>는 중첩 함수 <code>f</code>의 참조를 반환한다.</li><li>중첩 함수 <code>f</code>는 외부 함수 <code>makeCounter</code>의 지역 변수 <code>count</code>를 참조한다.</li><li>전역 변수 <code>counter</code>에 함수 <code>makeCounter</code>를 할당하였으므로, 전역 변수 <code>counter</code>는 중첩 함수 <code>f</code>의 함수 객체를 참조한다.</li><li><code>f</code>의 함수 객체는 함수 <code>makeCounter</code>의 렉시컬 환경 컴포넌트를 참조한다.</li><li>결과적으로, 전역 변수 <code>counter</code>는 중첩 함수 <code>f</code>의 함수 객체를 통해 간접적으로 외부 함수 <code>makeCounter</code>의 렉시컬 환경 컴포넌트를 참조한다.</li></ol><p><strong>클로저의 핵심:</strong></p><ul><li>외부 함수를 호출하면 해당 함수의 렉시컬 환경 컴포넌트가 생성되며, 중첩 함수의 함수 객체를 생성 및 반환한다.</li><li>외부 함수는 클로저를 생성하는 팩토리 함수이며, 클로저의 주 기능은 중첩 함수에 담겨있다.</li><li>외부 함수가 속한 렉시컬 환경 컴포넌트는 클로저 내부 상태 자체이며, 외부 함수가 호출될 때마다 새로 생성된다.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = makeCounter();</span><br><span class="line"><span class="built_in">console</span>.log(counter()); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(counter()); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(counter()); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> counter2 = makeCounter();</span><br><span class="line"><span class="built_in">console</span>.log(counter2()); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(counter2()); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(counter2()); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><ul><li>중첩 함수의 함수 객체가 있는 한 외부 함수가 속한 렉시컬 환경 컴포넌트는 지워지지 않으며, 외부 함수의 함수 객체가 사라져도 지워지지 않는다.</li><li>클로저 내부 상태(외부 함수의 지역 변수, 선언적 환경 레코드)는 외부로부터 은폐되어 있으며 중첩 함수 안에서만 읽거나 쓸 수 있다.</li></ul><p><strong>참고:</strong></p><ul><li><a href="https://opentutorials.org/course/743/6544" target="_blank" rel="external nofollow noopener noreferrer">클로저 - 생활코딩</a></li><li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Closures" target="_blank" rel="external nofollow noopener noreferrer">클로저 - JavaScript | MDN</a></li><li><a href="https://poiemaweb.com/js-closure" target="_blank" rel="external nofollow noopener noreferrer">Closure | PoiemaWeb</a></li></ul><h2 id="네임-스페이스-Name-space-오염을-줄이는-방법"><a href="#네임-스페이스-Name-space-오염을-줄이는-방법" class="headerlink" title="네임 스페이스(Name space) 오염을 줄이는 방법"></a>네임 스페이스(Name space) 오염을 줄이는 방법</h2><p>전역 변수와 전역 함수 등을 남발하게 되면 라이브러리를 쓴다거나 협업을 할 때 식별자가 충돌할 수가 있다. 따라서 전역 변수의 사용이 불가피할 경우에는 소스 코드 상단에 모아서 한눈에 파악할 수 있게 하는 것이 좋다.</p><p>그리고, 네임 스페이스의 오염을 최소화 하기 위한 방법으로는 다음과 같은 것들이 있다.</p><ol><li><p><strong>객체를 네임 스페이스로 활용하기</strong></p><ul><li>프로그램을 대표할만한 이름의 전역 변수를 하나 생성하여 객체를 값으로 할당하고, 프로그램에서 필요한 모든 변수와 함수를 프로퍼티로 정의한다.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myApp = myApp || &#123;&#125;;</span><br><span class="line"></span><br><span class="line">myApp.name = <span class="string">'Tom'</span>;</span><br><span class="line">myApp.showName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// something</span></span><br><span class="line">&#125;;</span><br><span class="line">myApp.view = &#123;&#125;; <span class="comment">// 내부에 또 다른 네임 스페이스를 만들 수도 있다.</span></span><br><span class="line">myApp.view.draw = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// something</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>즉시 실행 함수로 감싸기</strong></p><ul><li>일시적인 처리를 수행하는 내용들을 즉시 실행 함수로 감싸면 중복된 이름이 있더라도 전역 네임 스페이스를 오염시키지 않고 실행이 가능하다.</li></ul></li><li><p><strong>모듈 패턴</strong></p><ul><li>모듈(module)은 여러 기능을 하나로 묶은 것으로, 클로저(closure)를 즉시 실행 함수(IIFE)로 감싼 형태다.</li><li>이를 통하여 내부의 변수나 함수는 은폐하고, 원하는 함수만 공개할 수 있다.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Module = Module || &#123;&#125;;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">_Module</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">'NoName'</span>; <span class="comment">// 프라이빗 변수</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 프라이빗 함수</span></span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">  _Module.showName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 퍼블릭 함수</span></span><br><span class="line">    <span class="built_in">console</span>.log(getName());</span><br><span class="line">  &#125;;</span><br><span class="line">  _Module.setName = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; <span class="comment">// 퍼블릭 함수</span></span><br><span class="line">    name = x;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)(Module)</span><br><span class="line"></span><br><span class="line">Module.setName(<span class="string">'Tom'</span>);</span><br><span class="line">Module.showName(); <span class="comment">// Tom</span></span><br></pre></td></tr></table></figure></li></ol><ul><li><strong>참고:</strong><ul><li><a href="https://webcoding.tistory.com/entry/JavaScript-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EB%AA%A8%EB%93%88-%ED%8C%A8%ED%84%B4%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%BA%A1%EC%8A%90%ED%99%94" target="_blank" rel="external nofollow noopener noreferrer">JavaScript 자바스크립트 모듈 패턴을 이용한 캡슐화 :: 심플한 코딩 백과사전</a></li><li><a href="https://poiemaweb.com/js-object-oriented-programming" target="_blank" rel="external nofollow noopener noreferrer">Object-Oriented Programming | PoiemaWeb</a></li><li><a href="https://www.zerocho.com/category/Javascript/post/57541bef7dfff917002c4e86" target="_blank" rel="external nofollow noopener noreferrer">(JavaScript) 디자인 패턴(싱글턴, 모듈, 생성자) - ZeroCho Blog</a></li></ul></li></ul><h2 id="apply-call-bind"><a href="#apply-call-bind" class="headerlink" title="apply, call, bind"></a>apply, call, bind</h2><ul><li>Function 객체의 메서드에는 apply와 call이 있으며, this 값과 함수의 인수를 사용하여 함수를 실행하는 메서드다.</li><li>apply와 call은 동일하게 동작하며, 유일한 차이점은 인수를 넘기는 방식이다. apply는 배열로 인수를 넘기고, call은 쉼표로 구분한 값의 목록으로 인수를 넘긴다.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params">greetings, honorifics</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(greetings + <span class="string">''</span> + honorifics + <span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tom = &#123; <span class="attr">name</span>: <span class="string">'Tom Sawyer'</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> becky = &#123; <span class="attr">name</span>: <span class="string">'Becky Thatcher'</span> &#125;;</span><br><span class="line">say.apply(tom, [<span class="string">'Hello! '</span>, <span class="string">'Mr.'</span>]); <span class="comment">// Hello! Mr.Tom Sawyer</span></span><br><span class="line">say.call(becky, <span class="string">'Hi '</span>, <span class="string">'Ms.'</span>); <span class="comment">// Hi Ms.Becky Thatcher</span></span><br></pre></td></tr></table></figure><ul><li>bind 역시 Function 객체의 메서드이며, 객체에 함수를 바인드하는 역할을 한다.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params">greetings, honorifics</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(greetings + <span class="string">''</span> + honorifics + <span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tom = &#123; <span class="attr">name</span>: <span class="string">'Tom Sawyer'</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> sayToTom = say.bind(tom);</span><br><span class="line">sayToTom(<span class="string">'hello~ '</span>, <span class="string">'Mr.'</span>); <span class="comment">// hello~ Mr.Tom Sawyer</span></span><br></pre></td></tr></table></figure><h2 id="화살표-함수-arrow-function"><a href="#화살표-함수-arrow-function" class="headerlink" title="화살표 함수(arrow function)"></a>화살표 함수(arrow function)</h2><p>ES6에서는 익명함수의 단축 표현인 <strong>화살표 함수 표현식</strong>이 추가되었다. 화살표 함수 표현식은 아래와 같이 다양한 방법으로 작성이 가능하다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> square = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;<span class="keyword">return</span> x*x&#125;; <span class="comment">// 함수 표현식</span></span><br><span class="line"><span class="keyword">const</span> f = <span class="function">(<span class="params">x, y, z</span>) =&gt;</span> &#123;...&#125;; <span class="comment">// 인수가 여럿이라면 쉼표로 구분</span></span><br><span class="line"><span class="keyword">const</span> square = <span class="function"><span class="params">x</span> =&gt;</span> &#123;<span class="keyword">return</span> x*x&#125;; <span class="comment">// 인수가 하나라면 괄호 생략 가능</span></span><br><span class="line"><span class="keyword">const</span> f = <span class="function"><span class="params">()</span> =&gt;</span> &#123;...&#125;; <span class="comment">// 인수가 없을 때에는 빈 괄호 필수</span></span><br><span class="line"><span class="keyword">const</span> square = <span class="function"><span class="params">x</span> =&gt;</span> x*x; <span class="comment">// 함수 바디에 return문만 있으면 return 생략 가능</span></span><br><span class="line"><span class="keyword">const</span> f = <span class="function">(<span class="params">a, b</span>) =&gt;</span> (&#123;<span class="attr">x</span>:a, <span class="attr">y</span>:b&#125;); <span class="comment">// 반환값이 객체 리터럴이라면 괄호 필수</span></span><br><span class="line">(<span class="function"><span class="params">x</span> =&gt;</span> x*x)(<span class="number">3</span>); <span class="comment">// 즉시실행함수(IIFE)로 화살표 함수 사용 가능</span></span><br></pre></td></tr></table></figure><h3 id="일반-함수와-화살표-함수의-차이"><a href="#일반-함수와-화살표-함수의-차이" class="headerlink" title="일반 함수와 화살표 함수의 차이."></a>일반 함수와 화살표 함수의 차이.</h3><ol><li><p><strong>this</strong></p><ul><li>함수 리터럴로 정의한 함수는 <code>this</code>의 값이 함수를 호출할 때 결정되지만, 화살표 함수의 <code>this</code>값은 함수를 정의할 때 결정된다.</li></ul></li><li><p><strong>arguments 변수가 없음</strong></p><ul><li>화살표 함수 안에는 arguments 변수가 정의되어 있지 않아 사용할 수 없다.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> f  = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">f(); <span class="comment">// Uncaught ReferenceError: arguments is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="built_in">arguments</span>);&#125;;</span><br><span class="line">s(); <span class="comment">// Arguments [callee: ƒ, Symbol(Symbol.iterator): ƒ]</span></span><br></pre></td></tr></table></figure></li><li><p><strong>생성자로 사용 불가</strong></p><ul><li>화살표 함수 앞에는 <code>new</code> 연산자를 붙여 호출할 수 없다.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Person = <span class="function">(<span class="params">name, age</span>) =&gt;</span> &#123;<span class="keyword">this</span>.name = name; <span class="keyword">this</span>.age = age;&#125;;</span><br><span class="line"><span class="keyword">const</span> Tom = <span class="keyword">new</span> Person(<span class="string">'Tom'</span>, <span class="number">25</span>); <span class="comment">// Uncaught TypeError: Person is not a constructor</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Coffee = <span class="function"><span class="keyword">function</span>(<span class="params">name, price</span>) </span>&#123;<span class="keyword">this</span>.name = name; <span class="keyword">this</span>.price = price;&#125;;</span><br><span class="line"><span class="keyword">const</span> americano = <span class="keyword">new</span> Coffee(<span class="string">'Americano'</span>, <span class="number">4100</span>);</span><br><span class="line"><span class="built_in">console</span>.log(americano); <span class="comment">// Coffee &#123;name: "Americano", price: 4100&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(americano.price); <span class="comment">// 4100</span></span><br></pre></td></tr></table></figure></li><li><p><strong>yield 키워드를 쓸 수 없다</strong></p><ul><li>화살표 함수 안에서는 <code>yield</code> 키워드를 쓸 수 없으며, 따라서 화살표 함수는 제너레이터의 기능을 수행할 수 없다.</li></ul></li></ol><ul><li><strong>참고:</strong><ul><li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Functions/%EC%95%A0%EB%A1%9C%EC%9A%B0_%ED%8E%91%EC%85%98" target="_blank" rel="external nofollow noopener noreferrer">화살표 함수 - JavaScript | MDN</a></li><li><a href="https://poiemaweb.com/es6-arrow-function" target="_blank" rel="external nofollow noopener noreferrer">Arrow function | PoiemaWeb</a></li><li><a href="https://ko.javascript.info/arrow-functions-basics" target="_blank" rel="external nofollow noopener noreferrer">화살표 함수 기초</a></li><li><a href="https://ko.javascript.info/arrow-functions" target="_blank" rel="external nofollow noopener noreferrer">화살표 함수에 대한 재고</a></li><li><a href="https://ko.javascript.info/object-methods" target="_blank" rel="external nofollow noopener noreferrer">메서드와 ‘this’</a></li><li><a href="https://ko.javascript.info/generators" target="_blank" rel="external nofollow noopener noreferrer">제너레이터</a></li></ul></li></ul><h2 id="이터레이터-iterator"><a href="#이터레이터-iterator" class="headerlink" title="이터레이터(iterator)"></a>이터레이터(iterator)</h2><ul><li><p>이터레이터는 <strong>반복 처리(iteration)가 가능한 객체</strong> 를 말한다.</p></li><li><p><code>[Symbol.iterator]</code> 메서드를 갖고 있는 객체를 <strong>반복 가능(iterable) 한 객체</strong> 라고 한다.</p></li><li><p>주의해야 할 것은 <strong>이터레이터 객체 != 이터러블 객체</strong> 라는 점이다.</p></li><li><p>또한 <strong>이터러블 != 유사 배열</strong> 역시 다르다.</p><ul><li>유사 배열에는 <code>index</code>와 <code>length</code> 프로퍼티가 있다.</li><li>이터러블이라고 해서 꼭 유사 배열인 것은 아니며, 유사 배열이라고 해서 꼭 이터러블인 것도 아니다. 그러나 이터러블과 유사 배열의 특성을 동시에 갖는 객체도 있다. 대표적으로 문자열(String)이 그렇다.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">'string'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 아래와 같이 이터러블의 [Symbol.iterator] 메서드와</span></span><br><span class="line"><span class="comment">// 유사 배열의 index, length 프로퍼티를 동시에 지닌다.</span></span><br><span class="line">str[<span class="built_in">Symbol</span>.iterator](); <span class="comment">// StringIterator &#123;&#125;</span></span><br><span class="line">str.length; <span class="comment">// 6</span></span><br><span class="line">str[<span class="number">0</span>]; <span class="comment">// "s"</span></span><br></pre></td></tr></table></figure></li><li><p><strong>참고:</strong></p><ul><li><a href="https://ko.javascript.info/iterable" target="_blank" rel="external nofollow noopener noreferrer">iterable 객체</a></li></ul></li></ul><h2 id="제너레이터-generator"><a href="#제너레이터-generator" class="headerlink" title="제너레이터(generator)"></a>제너레이터(generator)</h2><ul><li>반복 가능한 이터레이터를 값으로 반환</li><li>작업의 일시 정지와 재시작이 가능하며 자신의 상태를 관리</li><li>제너레이터는 아래와 같이 <code>function*</code> 문으로 정의하며, 하나 이상의 <code>yield</code> 표현식을 포함한다.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> iter = <span class="keyword">get</span>();</span><br><span class="line">console.log(iter.next()); // &#123;value: <span class="number">1</span>, <span class="attr">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line"><span class="built_in">console</span>.log(iter.next()); <span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iter.next()); <span class="comment">// &#123;value: 3, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iter.next()); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><ul><li>위와 같이 제너레이터 함수의 <code>yield</code>는 프로그램이 일시적으로 정지하는 위치라고 할 수 있다.</li><li><code>yield</code> 표현식은 지정된 표현식을 값으로 갖고, 이를 변수에 대입할 수 있다.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="keyword">yield</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure><ul><li><p>제너레이터로 생성한 이터레이터는 이터러블이므로 <code>for..of</code>문을 쓸 수 있다.</p></li><li><p><strong>참고:</strong></p><ul><li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/yield" target="_blank" rel="external nofollow noopener noreferrer">yield - JavaScript | MDN</a></li><li><a href="https://meetup.toast.com/posts/73" target="_blank" rel="external nofollow noopener noreferrer">ES6의 제너레이터를 사용한 비동기 프로그래밍 : TOAST Meetup</a></li><li><a href="https://ko.javascript.info/generators" target="_blank" rel="external nofollow noopener noreferrer">제너레이터</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JS-Study&quot;&gt;&lt;a href=&quot;#JS-Study&quot; class=&quot;headerlink&quot; title=&quot;JS Study&quot;&gt;&lt;/a&gt;JS Study&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;자바스크립트를 다시 공부하며 놓쳤던 개념들을 정리함.&lt;/li&gt;
&lt;li&gt;교
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://codeameba.github.io/categories/JavaScript/"/>
    
    
      <category term="til" scheme="http://codeameba.github.io/tags/til/"/>
    
      <category term="TIL" scheme="http://codeameba.github.io/tags/TIL/"/>
    
      <category term="Today I Learned" scheme="http://codeameba.github.io/tags/Today-I-Learned/"/>
    
      <category term="오늘배운것들" scheme="http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"/>
    
      <category term="자바스크립트" scheme="http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"/>
    
      <category term="Javascript" scheme="http://codeameba.github.io/tags/Javascript/"/>
    
  </entry>
  
</feed>
