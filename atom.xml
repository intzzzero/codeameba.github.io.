<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AmebaLab</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://codeameba.github.io/"/>
  <updated>2020-05-13T18:03:13.501Z</updated>
  <id>http://codeameba.github.io/</id>
  
  <author>
    <name>Sooyoung Jeong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[TIL] 모든 요소에 특정 작업을 수행하는 반복 메서드</title>
    <link href="http://codeameba.github.io/2020/05/11/programming/array-method-iteration/"/>
    <id>http://codeameba.github.io/2020/05/11/programming/array-method-iteration/</id>
    <published>2020-05-11T09:40:42.000Z</published>
    <updated>2020-05-13T18:03:13.501Z</updated>
    
    <content type="html"><![CDATA[<h2 id="반복-메서드"><a href="#반복-메서드" class="headerlink" title="반복 메서드"></a>반복 메서드</h2><p>배열 메서드는 크게 세 종류로 나눈다.</p><ul><li><strong>수정 메서드</strong> : 원본 배열을 수정함</li><li><strong>접근자 메서드</strong> : 배열에 접근하여 새로운 배열을 반환</li><li><strong>반복 메서드</strong> : 배열의 요소들을 순회하며 작업을 수행</li></ul><p>이번 시간에는 주요 <strong>반복 메서드</strong> 들을 살펴본다.</p><h2 id="반복-메서드의-공통-성질"><a href="#반복-메서드의-공통-성질" class="headerlink" title="반복 메서드의 공통 성질"></a>반복 메서드의 공통 성질</h2><ol><li>반복 메서드의 인수로 전달한 함수는 배열의 모든 요소들에 호출되어 적용되며, 희소 배열의 경우 비어있는 요소는 건너뜀</li><li>반복 메서드 대부분은 첫 번째 인수로 함수를 받으며, 이 함수에는 <strong>최대 세 개의 인수</strong> 를 전달할 수 있다. 첫 번째 인수만 전달하는 경우가 많으며, 각각의 인수는 다음과 같다.<ul><li>첫 번째 인수(value): 현재 처리하는 요소의 값</li><li>두 번째 인수(index): 현재 처리하는 요소의 인덱스</li><li>세 번째 인수(array): 메서드가 적용되는 배열의 참조</li></ul></li><li><code>reduce</code>와 <code>reduceRight</code>를 제외한 반복 메서드에는 두 번째 인수를 지정할 수 있다. 두 번째 인수는 첫 번째 인수로 받은 함수 안의 <code>this</code>값이며 생략 가능하다.</li></ol><h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h2><p><code>forEach()</code>는 인수로 받은 함수를 요소 하나 하나마다 실행한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fruits = [‘apple’, ‘banana’, ‘melon’, ‘peach’, ‘blueberry’];</span><br><span class="line"></span><br><span class="line">fruits.forEach(<span class="function">(<span class="params">fruit</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`I Love <span class="subst">$&#123;fruit&#125;</span>`</span>));</span><br><span class="line"><span class="comment">// I Love apple</span></span><br><span class="line"><span class="comment">// I Love banana</span></span><br><span class="line"><span class="comment">// I Love melon</span></span><br><span class="line"><span class="comment">// I Love peach</span></span><br><span class="line"><span class="comment">// I Love blueberry</span></span><br><span class="line"></span><br><span class="line">fruits.forEach(<span class="function">(<span class="params">fruit, index</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;fruit&#125;</span> is <span class="subst">$&#123;index + <span class="number">1</span>&#125;</span>th fruit.`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// apple is 1th fruit.</span></span><br><span class="line"><span class="comment">// banana is 2th fruit.</span></span><br><span class="line"><span class="comment">// melon is 3th fruit.</span></span><br><span class="line"><span class="comment">// peach is 4th fruit.</span></span><br><span class="line"><span class="comment">// blueberry is 5th fruit.</span></span><br></pre></td></tr></table></figure><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p><code>map()</code>은 인수로 받은 함수를 요소별로 한 번씩 실행하며, 함수가 반환한 값으로 새로운 배열을 생성한다. <code>map()</code>의 인수로 넘기는 함수는 반드시 값을 반환해야 한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fruits = [‘apple’, ‘banana’, ‘melon’, ‘peach’, ‘blueberry’];</span><br><span class="line"><span class="keyword">const</span> myFruits = fruits.map(<span class="function">(<span class="params">fruit</span>) =&gt;</span> fruit.toUpperCase());</span><br><span class="line"><span class="built_in">console</span>.log(myFruits); </span><br><span class="line"><span class="comment">// [“APPLE”, “BANANA”, “MELON”, “PEACH”, “BLUEBERRY”]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>];</span><br><span class="line"><span class="keyword">const</span> sqrt = numbers.map(<span class="built_in">Math</span>.sqrt);</span><br><span class="line"><span class="built_in">console</span>.log(sqrt); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> persons = [</span><br><span class="line">  &#123;<span class="attr">name</span>: ‘Tom’, <span class="attr">age</span>: <span class="number">17</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>: ‘James’, <span class="attr">age</span>: <span class="number">19</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>: ‘Sam’, <span class="attr">age</span>: <span class="number">15</span>&#125;</span><br><span class="line">];</span><br><span class="line"><span class="keyword">const</span> names = persons.map(<span class="function"><span class="params">person</span> =&gt;</span> person.name);</span><br><span class="line"><span class="keyword">const</span> ages = persons.map(<span class="function"><span class="params">person</span> =&gt;</span> person.age);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`names: <span class="subst">$&#123;names&#125;</span> / ages: <span class="subst">$&#123;ages&#125;</span>`</span>);</span><br><span class="line"><span class="comment">// names: Tom,James,Sam / ages: 17,19,15</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(persons.map(<span class="function"><span class="params">person</span> =&gt;</span> person.name).map(<span class="function"><span class="params">name</span> =&gt;</span> name.length));</span><br><span class="line"><span class="comment">// [3, 5, 3]</span></span><br></pre></td></tr></table></figure><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p><code>filter()</code>는 조건에 충족하는 요소만 걸러 새로운 배열로 반환한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fruits = [‘apple’, ‘banana’, ‘melon’, ‘peach’, ‘blueberry’];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> includeM = fruits.filter(<span class="function">(<span class="params">fruit</span>) =&gt;</span> fruit.includes(‘m’));</span><br><span class="line"><span class="built_in">console</span>.log(includeM); <span class="comment">// [“melon”]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> longerThan5Length = fruits.filter(<span class="function"><span class="params">fruit</span> =&gt;</span> fruit.length &gt; <span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(longerThan5Length); <span class="comment">// [“banana”, “blueberry”]</span></span><br></pre></td></tr></table></figure><h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h2><p><code>reduce()</code>는 배열을 기반으로 하나의 값을 도출할 때 사용한다. reduce의 인수로 넘기는 함수의 첫 번째 인수는 <strong>accumulator(누산기)</strong> 라고 할 수 있으며, 함수의 결과가 누적되어 저장되고 마지막 함수까지 호출되면 이 값이 <code>reduce()</code>의 반환값이 된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myNums = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> result = myNums.reduce(<span class="function">(<span class="params">sum, current</span>) =&gt;</span> sum + current, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 27</span></span><br></pre></td></tr></table></figure><p><code>reduce()</code>에 전달된 함수는 위와 같이 두 개의 인수를 받는 게 일반적이다.<br>위 코드의 실행 절차에 따른 <code>sum</code>과 <code>current</code>의 상태 변화는 다음과 같다.</p><ol><li><code>sum = 0</code> / <code>current = 1</code></li><li><code>sum = 0 + 1</code> / <code>current = 5</code></li><li><code>sum = 0 + 1 + 5</code> / <code>current = 3</code></li><li><code>sum = 0 + 1 + 5 + 3</code> / <code>current = 7</code></li><li><code>sum = 0 + 1 + 5 + 3 + 7</code> / <code>current = 9</code></li><li><code>sum = 0 + 1 + 5 + 3 + 7 + 9</code> / <code>current = 2</code></li><li><code>return sum = 0 + 1 + 5 + 3 + 7 + 9 + 2</code></li></ol><p>끝의 <code>0</code>은 <code>reduce()</code>의 마지막 인수로 초깃값을 뜻하며 <code>sum</code>에 할당된다. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">9</span>];</span><br><span class="line"><span class="keyword">let</span> newResult = arr.reduce(<span class="function">(<span class="params">sum, current</span>) =&gt;</span> sum + current);</span><br><span class="line"><span class="built_in">console</span>.log(newResult); <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> emptyArr = [];</span><br><span class="line"><span class="keyword">let</span> newResult = emptyArr.reduce(<span class="function">(<span class="params">sum, current</span>) =&gt;</span> sum + current);</span><br><span class="line"><span class="built_in">console</span>.log(newResult); <span class="comment">// TypeError: Reduce of empty array with no initial value</span></span><br></pre></td></tr></table></figure><p>초깃값을 생략할 경우 배열의 첫 번째 요소를 초깃값으로 사용한다. 다만, 배열이 비었을 경우 초깃값으로 사용할 요소가 없기 때문에 <code>error</code>가 발생한다.</p><p>이러한 <code>reduce()</code>의 특성을 활용하면 꼭 요소들의 합 뿐만 아니라 다양한 방법으로 사용할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 모든 배열 요소의 곱</span></span><br><span class="line"><span class="built_in">console</span>.log(a.reduce(<span class="function">(<span class="params">pre, val</span>) =&gt;</span> pre * val)); <span class="comment">// 252</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 배열 요소 중 가장 큰 값</span></span><br><span class="line"><span class="built_in">console</span>.log(a.reduce(<span class="function">(<span class="params">pre, val</span>) =&gt;</span> pre &gt; val ? pre : val)); <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> names = [<span class="string">'Tom'</span>, <span class="string">'Jane'</span>, <span class="string">'Sam'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 문자열 연결</span></span><br><span class="line"><span class="built_in">console</span>.log(names.reduce(<span class="function">(<span class="params">pre, val</span>) =&gt;</span> pre + <span class="string">' '</span> + val)); <span class="comment">// Tom Jane Sam</span></span><br></pre></td></tr></table></figure><h3 id="reduceRight"><a href="#reduceRight" class="headerlink" title="reduceRight"></a>reduceRight</h3><p><code>reduce()</code>와 유사한 메서드로 <code>reduceRight()</code>가 있다. 원리와 사용법은 동일하며 배열의 오른쪽 요소부터 작업을 수행한다는 점이 다르다.</p><p><strong>참고:</strong></p><ul><li><a href="https://ko.javascript.info/array-methods" target="_blank" rel="external nofollow noopener noreferrer">배열과 메서드</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;반복-메서드&quot;&gt;&lt;a href=&quot;#반복-메서드&quot; class=&quot;headerlink&quot; title=&quot;반복 메서드&quot;&gt;&lt;/a&gt;반복 메서드&lt;/h2&gt;&lt;p&gt;배열 메서드는 크게 세 종류로 나눈다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;수정 메서드&lt;/str
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://codeameba.github.io/categories/JavaScript/"/>
    
    
      <category term="til" scheme="http://codeameba.github.io/tags/til/"/>
    
      <category term="TIL" scheme="http://codeameba.github.io/tags/TIL/"/>
    
      <category term="Today I Learned" scheme="http://codeameba.github.io/tags/Today-I-Learned/"/>
    
      <category term="오늘배운것들" scheme="http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"/>
    
      <category term="자바스크립트" scheme="http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"/>
    
      <category term="Javascript" scheme="http://codeameba.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>[TIL] 새로운 배열을 반환하는 배열 메서드</title>
    <link href="http://codeameba.github.io/2020/05/09/programming/array-method-return-new-array/"/>
    <id>http://codeameba.github.io/2020/05/09/programming/array-method-return-new-array/</id>
    <published>2020-05-09T11:20:42.000Z</published>
    <updated>2020-05-13T18:03:17.448Z</updated>
    
    <content type="html"><![CDATA[<h2 id="접근자-메서드"><a href="#접근자-메서드" class="headerlink" title="접근자 메서드"></a>접근자 메서드</h2><p>배열 메서드는 크게 세 종류로 나눈다.</p><ul><li><strong>수정 메서드</strong> : 원본 배열을 수정함</li><li><strong>접근자 메서드</strong> : 배열에 접근하여 새로운 배열을 반환</li><li><strong>반복 메서드</strong> : 배열의 요소들을 순회하며 작업을 수행</li></ul><p>이번 시간에는 주요 <strong>접근자 메서드</strong> 들을 살펴본다.</p><h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><p><code>join()</code>은 모든 요소를 문자열로 변환 후 인수로 받은 문자와 연결하여 반환한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fruits = [‘apple’, ‘banana’, ‘melon’, ‘peach’, ‘blueberry’];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fruits.join(‘-‘));</span><br><span class="line"><span class="comment">// apple-banana-melon-peach-blueberry</span></span><br></pre></td></tr></table></figure><h2 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h2><p><code>concat()</code>은 인수로 받은 값을 배열에 추가하여 새로운 배열을 생성한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fruits = [‘apple’, ‘banana’, ‘melon’, ‘peach’, ‘blueberry’];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fruits.concat(‘cherry’, ‘grape’));</span><br><span class="line"><span class="comment">// ["apple", "banana", "melon", "peach", "blueberry", "cherry", "grape"]</span></span><br></pre></td></tr></table></figure><p>인수를 배열로 전달할 경우에는 자동으로 배열을 해체한 후 합친다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(fruits.concat([‘cherry’, ‘grape’]));</span><br><span class="line"><span class="comment">// ["apple", "banana", "melon", "peach", "blueberry", "cherry", "grape"]</span></span><br></pre></td></tr></table></figure><p>그러나, 가장 바깥의 배열만 자동으로 해체하기 때문에 중복된 배열은 배열 그대로 추가된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(fruits.concat([‘lemon’, [‘strawberry’, ‘watermelon’]]));</span><br><span class="line"><span class="comment">// ["apple", "banana", "melon", "peach", "blueberry", "lemon", [“strawberry”, “watermelon”]]</span></span><br></pre></td></tr></table></figure><h2 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h2><p><code>slice()</code>는 선택된 만큼의 요소를 새로운 배열로 반환한다. 두 개의 인수를 받으며, 첫 번째 인수는 <strong>시작 인덱스</strong> , 두 번째 인수는 <strong>끝 인덱스</strong> 다.</p><p><code>slice(시작, 끝)</code> : 시작 인덱스의 요소부터 끝 인덱스 바로 앞까지 새로운 배열로 반환한다. 두 번째 인수를 생략 가능하며 그럴 경우 시작 인덱스부터 모든 요소를 배열로 반환한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fruits = [‘apple’, ‘banana’, ‘melon’, ‘peach’, ‘blueberry’];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fruits.slice(<span class="number">1</span>, <span class="number">4</span>));</span><br><span class="line"><span class="comment">// ["banana", "melon", "peach"]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fruits.slice(<span class="number">3</span>));</span><br><span class="line"><span class="comment">// ["peach", "blueberry"]</span></span><br></pre></td></tr></table></figure><h2 id="indexOf-lastIndexOf"><a href="#indexOf-lastIndexOf" class="headerlink" title="indexOf, lastIndexOf"></a>indexOf, lastIndexOf</h2><p><code>indexOf()</code>와 <code>lastIndexOf()</code>는 인수로 전달한 요소의 인덱스를 반환한다.<br><code>indexOf()</code>는 배열 왼쪽부터 검색하고, <code>lastIndexOf()</code>는 배열 오른쪽부터 검색하여 반환한다. 만약, 찾는 요소가 배열에 없을 때에는 <code>-1</code>을 반환한다.<br>두 번째 인수는 검색을 시작할 인덱스이며 생략 가능하다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">9</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(numbers.indexOf(<span class="number">5</span>)); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(numbers.lastIndexOf(<span class="number">5</span>)); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><h2 id="toString-toLocaleString"><a href="#toString-toLocaleString" class="headerlink" title="toString, toLocaleString"></a>toString, toLocaleString</h2><p><code>toString()</code>과 <code>toLocaleString()</code>은 배열의 요소를 문자열로 반환 후 쉼표로 연결하여 반환한다. 둘의 차이는 <code>toLocaleString()</code>의 경우 해당 지역에 맞는 문자열로 번역하여 반환한다는 점이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log([‘Seoul’, ‘Republic <span class="keyword">of</span> Korea’, date].toString());</span><br><span class="line"><span class="comment">// Seoul,Republic of Korea,Sat May 09 2020 20:00:19</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log([‘Seoul’, ‘Republic <span class="keyword">of</span> Korea’, date].toLocaleString());</span><br><span class="line"><span class="comment">// Seoul,Republic of Korea,2020. 5. 9. 오후 8:00:19</span></span><br></pre></td></tr></table></figure><p><code>Object.prototype</code>에 동일한 이름을 가진 메서드가 존재하지만, <code>Array</code>에 새롭게 정의한 메서드이므로 다른 메서드로 볼 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString === <span class="built_in">Array</span>.prototype.toString <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString === <span class="built_in">Array</span>.prototype.__proto__.toString <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>참고:</strong></p><ul><li><a href="https://ko.javascript.info/array-methods" target="_blank" rel="external nofollow noopener noreferrer">배열과 메서드</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;접근자-메서드&quot;&gt;&lt;a href=&quot;#접근자-메서드&quot; class=&quot;headerlink&quot; title=&quot;접근자 메서드&quot;&gt;&lt;/a&gt;접근자 메서드&lt;/h2&gt;&lt;p&gt;배열 메서드는 크게 세 종류로 나눈다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;수정 메서드&lt;
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://codeameba.github.io/categories/JavaScript/"/>
    
    
      <category term="til" scheme="http://codeameba.github.io/tags/til/"/>
    
      <category term="TIL" scheme="http://codeameba.github.io/tags/TIL/"/>
    
      <category term="Today I Learned" scheme="http://codeameba.github.io/tags/Today-I-Learned/"/>
    
      <category term="오늘배운것들" scheme="http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"/>
    
      <category term="자바스크립트" scheme="http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"/>
    
      <category term="Javascript" scheme="http://codeameba.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>[TIL] 원본 배열을 수정하는 배열 메서드</title>
    <link href="http://codeameba.github.io/2020/05/08/programming/array-method-changed-original/"/>
    <id>http://codeameba.github.io/2020/05/08/programming/array-method-changed-original/</id>
    <published>2020-05-08T09:12:42.000Z</published>
    <updated>2020-05-13T18:03:08.377Z</updated>
    
    <content type="html"><![CDATA[<h2 id="수정-메서드"><a href="#수정-메서드" class="headerlink" title="수정 메서드"></a>수정 메서드</h2><p>배열 메서드는 크게 세 종류로 나눈다.</p><ul><li><strong>수정 메서드</strong> : 원본 배열을 수정함</li><li><strong>접근자 메서드</strong> : 배열에 접근하여 새로운 배열을 반환</li><li><strong>반복 메서드</strong> : 배열의 요소들을 순회하며 작업을 수행</li></ul><p>이번 시간에는 주요 수정 메서드들을 살펴본다.</p><h2 id="push"><a href="#push" class="headerlink" title="push"></a>push</h2><p><code>push()</code>는 배열 마지막에 새로운 요소를 추가한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fruits = [‘apple’, ‘banana’, ‘melon’, ‘peach’, ‘blueberry’];</span><br><span class="line"></span><br><span class="line">fruits.push(‘pineapple’);</span><br><span class="line"><span class="built_in">console</span>.log(fruits);</span><br><span class="line"><span class="comment">// ["apple", "banana", "melon", "peach", "blueberry", "pineapple"]</span></span><br></pre></td></tr></table></figure><h2 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h2><p><code>pop()</code>은 배열 마지막 요소를 제거한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fruits = [‘apple’, ‘banana’, ‘melon’, ‘peach’, ‘blueberry’];</span><br><span class="line"></span><br><span class="line">fruits.pop();</span><br><span class="line"><span class="built_in">console</span>.log(fruits);</span><br><span class="line"><span class="comment">// ["apple", "banana", "melon", "peach"]</span></span><br></pre></td></tr></table></figure><h2 id="shift"><a href="#shift" class="headerlink" title="shift"></a>shift</h2><p><code>shift()</code>는 배열 맨 앞의 요소를 제거한 후 모든 요소를 왼쪽으로 이동 시킨다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fruits = [‘apple’, ‘banana’, ‘melon’, ‘peach’, ‘blueberry’];</span><br><span class="line"></span><br><span class="line">fruits.shift();</span><br><span class="line"><span class="built_in">console</span>.log(fruits);</span><br><span class="line"><span class="comment">// [‘banana’, ‘melon’, ‘peach’, ‘blueberry’]</span></span><br></pre></td></tr></table></figure><h2 id="unshift"><a href="#unshift" class="headerlink" title="unshift"></a>unshift</h2><p><code>unshift()</code>는 배열 맨 앞에 새로운 요소를 추가하며 기존의 요소들을 오른쪽으로 이동 시킨다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fruits = [‘apple’, ‘banana’, ‘melon’, ‘peach’, ‘blueberry’];</span><br><span class="line"></span><br><span class="line">fruits.unshift(‘pineapple’);</span><br><span class="line"><span class="built_in">console</span>.log(fruits);</span><br><span class="line"><span class="comment">// [‘pineapple’, ‘apple’, ‘banana’, ‘melon’, ‘peach’, ‘blueberry’]</span></span><br></pre></td></tr></table></figure><h2 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h2><p><code>splice</code>는 전달하는 인자 개수에 따라 특정 위치에 요소를 추가, 삭제, 교체할 수 있다.<br><strong><code>splice(시작 인덱스, 시작 인덱스부터 요소의 개수, 추가할 요소)</code></strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fruits = [‘apple’, ‘banana’, ‘melon’, ‘peach’, ‘blueberry’];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 인덱스 1부터 2개의 요소를 제거하고, ‘lemon’과 ‘grape’를 추가</span></span><br><span class="line">fruits.splice(<span class="number">1</span>, <span class="number">2</span>, ‘lemon’, ‘grape’);</span><br><span class="line"><span class="built_in">console</span>.log(fruits);</span><br><span class="line"><span class="comment">// ["apple", "lemon", "grape", "peach", "blueberry"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 첫 번째 인수만 넘기면 해당 인덱스 이후의 요소 모두 제거</span></span><br><span class="line">fruits.splice(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(fruits);</span><br><span class="line"><span class="comment">// ["apple", "lemon"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 두 번째 인수에 0을 넘기면 제거 없이 새로운 요소만 추가</span></span><br><span class="line">fruits.splice(<span class="number">1</span>, <span class="number">0</span>, ‘cherry’);</span><br><span class="line"><span class="built_in">console</span>.log(fruits);</span><br><span class="line"><span class="comment">// [“apple", "cherry", "lemon"]</span></span><br></pre></td></tr></table></figure><h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><p><code>sort()</code>는 배열 요소를 정렬할 때 사용한다. 비교함수를 넣어야 인접한 두 개 의 요소를 비교하여 정렬을 하며, 정렬 방식은 다음과 같다.</p><ul><li>f(a, b) &lt; 0 이면 a를 b보다 작은 인덱스로 정렬</li><li>f(a, b) == 0 이면 a와 b의 순서 그대로 둠</li><li>f(a, b) &gt; 0 이면 b를 a보다 작은 인덱스로 정렬</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">15</span>, <span class="number">3</span>, <span class="number">36</span>, <span class="number">2</span>, <span class="number">51</span>, <span class="number">7</span>, <span class="number">19</span>, <span class="number">24</span>];</span><br><span class="line"></span><br><span class="line">numbers.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123; <span class="keyword">return</span> a - b; &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(numbers); </span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 6, 7, 8, 15, 19, 24, 36, 51]</span></span><br></pre></td></tr></table></figure><p>비교함수를 지정하지 않으면 요소를 문자열로 변환하여 사전순(abc)으로 정렬한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fruits = [‘apple’, ‘banana’, ‘melon’, ‘peach’, ‘blueberry’];</span><br><span class="line"></span><br><span class="line">fruits.sort();</span><br><span class="line"><span class="built_in">console</span>.log(fruits); </span><br><span class="line"><span class="comment">// ["apple", "banana", "blueberry", "melon", "peach"]</span></span><br></pre></td></tr></table></figure><p><strong>참고:</strong></p><ul><li><a href="https://ko.javascript.info/array-methods" target="_blank" rel="external nofollow noopener noreferrer">배열과 메서드</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;수정-메서드&quot;&gt;&lt;a href=&quot;#수정-메서드&quot; class=&quot;headerlink&quot; title=&quot;수정 메서드&quot;&gt;&lt;/a&gt;수정 메서드&lt;/h2&gt;&lt;p&gt;배열 메서드는 크게 세 종류로 나눈다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;수정 메서드&lt;/str
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://codeameba.github.io/categories/JavaScript/"/>
    
    
      <category term="til" scheme="http://codeameba.github.io/tags/til/"/>
    
      <category term="TIL" scheme="http://codeameba.github.io/tags/TIL/"/>
    
      <category term="Today I Learned" scheme="http://codeameba.github.io/tags/Today-I-Learned/"/>
    
      <category term="오늘배운것들" scheme="http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"/>
    
      <category term="자바스크립트" scheme="http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"/>
    
      <category term="Javascript" scheme="http://codeameba.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>[TIL] 클로저(Closure) 복습</title>
    <link href="http://codeameba.github.io/2020/05/04/programming/closure-is-very-important/"/>
    <id>http://codeameba.github.io/2020/05/04/programming/closure-is-very-important/</id>
    <published>2020-05-04T10:45:42.000Z</published>
    <updated>2020-05-13T18:03:26.710Z</updated>
    
    <content type="html"><![CDATA[<h2 id="렉시컬-스코핑-Lexical-Scoping"><a href="#렉시컬-스코핑-Lexical-Scoping" class="headerlink" title="렉시컬 스코핑(Lexical Scoping)"></a>렉시컬 스코핑(Lexical Scoping)</h2><p>클로저의 개념을 이해하기 위해서는 우선 렉시컬 스코핑을 이해해야 하며, 렉시컬 스코핑을 이해하기 위해서는 실행 컨텍스트(Execution Context)를 이해할 필요가 있다.</p><p>아래와 같은 코드가 있을 때, 실행 컨텍스트와 렉시컬 스코핑을 단계별로 정리하며 알아보도록 하자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> name = ‘codeAmeba’;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">displayName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">  &#125;</span><br><span class="line">  displayName();</span><br><span class="line">&#125;</span><br><span class="line">init(); <span class="comment">// codeAmeba</span></span><br></pre></td></tr></table></figure><ol><li>글로벌 실행 컨텍스트 생성 -&gt; 렉시컬 환경에 <code>init()</code> 등록</li><li>글로벌 실행 컨텍스트 위에 <code>init()</code> 실행 컨텍스트, 렉시컬 스코프 생성 </li><li><code>init()</code> 렉시컬 환경에 변수와 함수 등록, 외부 환경 참조에 글로벌 렉시컬 환경 등록</li><li><code>init()</code> 실행 컨텍스트 위에 <code>displayName()</code> 실행 컨텍스트, 렉시컬 스코프 생성 </li><li><code>displayName()</code> 외부 환경 참조에 등록된  변수 <code>name</code>을 찾아 로그 실행</li><li><code>displayName()</code> 실행 컨텍스트, 렉시컬 스코프 종료</li><li><code>init()</code> 실행 컨텍스트, 렉시컬 스코프 종료</li></ol><h2 id="클로저-Closure"><a href="#클로저-Closure" class="headerlink" title="클로저(Closure)"></a>클로저(Closure)</h2><p>앞서 살펴본 내용이 일반적인 중첩함수라면, 클로저는 어떤 부분이 다른지 아래의 코드를 살펴보자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> name = ‘codeAmeba’;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">displayName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> displayName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myFunc = makeFunc();</span><br><span class="line">myFunc(); <span class="comment">// codeAmeba</span></span><br></pre></td></tr></table></figure><p><code>displayName()</code>을 리턴한다는 것 외에 큰 차이를 발견하기 어려우나 내부적으로는 클로저만의 차이점이 있다.</p><p><strong>클로저의 컨셉은 실행 컨텍스트 종료 후에도 렉시컬 환경을 유지하는 것에 있다.</strong></p><p>위의 경우에서는,  <code>displayName()</code>이 리턴되어 <code>myFunc</code>에 저장되고, <code>displayName()</code>은 외부 환경 참조를 통해  <code>makeFunc()</code>의 지역변수 <code>name</code>을 참조하고 있다고 볼 수 있다.</p><p><strong>참고:</strong><br>    - <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Closures" target="_blank" rel="external nofollow noopener noreferrer">클로저 - JavaScript | MDN</a><br>    - <a href="https://ko.javascript.info/closure" target="_blank" rel="external nofollow noopener noreferrer">변수의 스코프</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;렉시컬-스코핑-Lexical-Scoping&quot;&gt;&lt;a href=&quot;#렉시컬-스코핑-Lexical-Scoping&quot; class=&quot;headerlink&quot; title=&quot;렉시컬 스코핑(Lexical Scoping)&quot;&gt;&lt;/a&gt;렉시컬 스코핑(Lexical 
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://codeameba.github.io/categories/JavaScript/"/>
    
    
      <category term="til" scheme="http://codeameba.github.io/tags/til/"/>
    
      <category term="TIL" scheme="http://codeameba.github.io/tags/TIL/"/>
    
      <category term="Today I Learned" scheme="http://codeameba.github.io/tags/Today-I-Learned/"/>
    
      <category term="오늘배운것들" scheme="http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"/>
    
      <category term="자바스크립트" scheme="http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"/>
    
      <category term="Javascript" scheme="http://codeameba.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>[TIL] 메서드(method)의 약식 표현과 한계</title>
    <link href="http://codeameba.github.io/2020/04/30/programming/es6-method-expression/"/>
    <id>http://codeameba.github.io/2020/04/30/programming/es6-method-expression/</id>
    <published>2020-04-30T09:45:42.000Z</published>
    <updated>2020-05-13T18:04:19.094Z</updated>
    
    <content type="html"><![CDATA[<p>ES6의 등장으로 말미암아 다양한 문법적 편의성을 누릴 수 있게 되었다. 그 중 하나가 아래와 같은 메서드(method)의 약식 표현이다.</p><ol><li><strong>메서드 약식 표현(ES6에서 추가)</strong><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> robot = &#123;</span><br><span class="line">  name: ‘Coderoid’,</span><br><span class="line">  sayHello() &#123; <span class="built_in">console</span>.log(‘Hello! ‘ + <span class="keyword">this</span>.name); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><p>ES6 이전의 메서드의 표현은 아래와 같았다.</p><ol start="2"><li><strong>ES6 이전의 메서드 표현</strong><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> robot = &#123;</span><br><span class="line">  name: ‘Coderoid’,</span><br><span class="line">  sayHello: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(‘Hello! ‘ + <span class="keyword">this</span>.name); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><p>단순히 <code>key : value</code>  형태의 유무 정도의 차이로 보이지만, 생각보다 중요한 차이가 있다.</p><p>약식표현의 경우 <code>prototype</code>을 지니지 않기 때문에 생성자로 사용할 수 없으며 이말은 곧, <code>new</code> 연산자를 통한 인스턴스의 생성이 불가하다는 말이기도 하다. 또한, 약식표현은 <code>super</code> 키워드를 사용할 수 없다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ES6의 등장으로 말미암아 다양한 문법적 편의성을 누릴 수 있게 되었다. 그 중 하나가 아래와 같은 메서드(method)의 약식 표현이다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;메서드 약식 표현(ES6에서 추가)&lt;/strong&gt;&lt;figure cl
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://codeameba.github.io/categories/JavaScript/"/>
    
    
      <category term="til" scheme="http://codeameba.github.io/tags/til/"/>
    
      <category term="TIL" scheme="http://codeameba.github.io/tags/TIL/"/>
    
      <category term="Today I Learned" scheme="http://codeameba.github.io/tags/Today-I-Learned/"/>
    
      <category term="오늘배운것들" scheme="http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"/>
    
      <category term="자바스크립트" scheme="http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"/>
    
      <category term="Javascript" scheme="http://codeameba.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>[TIL] 프로토타입을 임의로 수정하면 안 되는 이유</title>
    <link href="http://codeameba.github.io/2020/04/22/programming/do-not-modify-prototype/"/>
    <id>http://codeameba.github.io/2020/04/22/programming/do-not-modify-prototype/</id>
    <published>2020-04-22T09:05:42.000Z</published>
    <updated>2020-05-13T18:04:14.940Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.__proto__ === <span class="built_in">Array</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.__proto__.__proto__ === <span class="built_in">Object</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.__proto__.__proto__.__proto__ === <span class="literal">null</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(myFunc.__proto__ === <span class="built_in">Function</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(myFunc.__proto__.__proto__ === <span class="built_in">Object</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(myFunc.__proto__.__proto__.__proto__ === <span class="literal">null</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> num = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num.__proto__ === <span class="built_in">Number</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(num.__proto__.__proto__ === <span class="built_in">Object</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(num.__proto__.__proto__.__proto__ === <span class="literal">null</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myFunc.__proto__.__proto__ === arr.__proto__.__proto__); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(num.__proto__.__proto__ === myFunc.__proto__.__proto__); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>위와 같이 모든 내장 프로토타입은 <code>Object.prototype</code>에서 만나게 되며, 그 끝에는 <code>null</code>이 있다.</p><p>그 말은 곧, 프로토타입 체인을 통해 다른 객체의 메서드를 가져올 수 있다는 것이며, 자주 사용하는 사용자 정의 메서드를 프로토타입에 아예 탑재해버리고 내장 메서드를 쓰듯이 쓸 수도 있다는 것이다.</p><p><strong>하지만, 프로토타입은 전역에 영향을 미치며, 프로토타입에 사용자 정의 메서드를 넣는다는 것은 전역 객체를 만든다는 것이므로 오류와 혼란을 야기한다.</strong></p><p><strong>참고:</strong></p><ul><li><a href="https://ko.javascript.info/native-prototypes" target="_blank" rel="external nofollow noopener noreferrer">네이티브 프로토타입</a></li><li><a href="https://ko.javascript.info/function-prototype" target="_blank" rel="external nofollow noopener noreferrer">함수의 prototype 프로퍼티</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span 
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://codeameba.github.io/categories/JavaScript/"/>
    
    
      <category term="til" scheme="http://codeameba.github.io/tags/til/"/>
    
      <category term="TIL" scheme="http://codeameba.github.io/tags/TIL/"/>
    
      <category term="Today I Learned" scheme="http://codeameba.github.io/tags/Today-I-Learned/"/>
    
      <category term="오늘배운것들" scheme="http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"/>
    
      <category term="자바스크립트" scheme="http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"/>
    
      <category term="Javascript" scheme="http://codeameba.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>[TIL] 구조 분해 할당(destructured assignment)</title>
    <link href="http://codeameba.github.io/2020/04/16/programming/destructured-assignment/"/>
    <id>http://codeameba.github.io/2020/04/16/programming/destructured-assignment/</id>
    <published>2020-04-16T09:05:42.000Z</published>
    <updated>2020-05-13T18:02:49.502Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> member = &#123;</span><br><span class="line">  name: ‘codeAmeba’,</span><br><span class="line">  position: <span class="string">'Front-end'</span>,</span><br><span class="line">  skills: [<span class="string">'HTML'</span>, <span class="string">'CSS'</span>, <span class="string">'JavaScript'</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같은 객체가 있을 때, 객체의 일부만 변수에 할당하여 사용하고 싶은 경우가 종종 있을 것이다. 그리고, 보통은 아래와 같이 할당을 할 것이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = member.name;</span><br><span class="line"><span class="keyword">const</span> position = member.position;</span><br><span class="line"><span class="keyword">const</span> skills = member.skills;</span><br></pre></td></tr></table></figure><p>물론 이렇게 한다고 큰 일이 일어나지는 않지만, <strong>구조 분해 할당(destructured assignment)</strong> 를 활용하면 단 한 줄로 동일한 결과를 낼 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; name, position, skills &#125; = member;</span><br></pre></td></tr></table></figure><p>이와 같은 구조 분해 할당은 객체의 일부를 저장하는 상황에 국한되지 않는다. <strong>배열의 요소를 저장할 때</strong>나 <strong>매개변수에 기본값이 필요한 경우</strong> 등에도 유용하게 쓰인다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> users = [‘codeAmeba’, ‘codeMonkey’];</span><br><span class="line"><span class="keyword">let</span> [firstUser, secondUser] = users;</span><br><span class="line"><span class="built_in">console</span>.log(firstUser); <span class="comment">// codeAmeba</span></span><br></pre></td></tr></table></figure><p>특히, 구조 분해 할당의 몇 가지 포인트만 알면 다양한 상황에 응용이 가능한데, 포인트는 다음과 같다.<br>    1. 할당 연산자 우측에는 모든 이터러블(iterable)이 올 수 있다.<br>    2. 할당 연산자 좌측에는 할당 가능한 모든 것이 올 수 있다.<br>    3. 기본값 설정이 가능하다.</p><ul><li><strong>참고:</strong><ul><li><a href="https://ko.javascript.info/destructuring-assignment" target="_blank" rel="external nofollow noopener noreferrer">구조 분해 할당</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span 
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://codeameba.github.io/categories/JavaScript/"/>
    
    
      <category term="til" scheme="http://codeameba.github.io/tags/til/"/>
    
      <category term="TIL" scheme="http://codeameba.github.io/tags/TIL/"/>
    
      <category term="Today I Learned" scheme="http://codeameba.github.io/tags/Today-I-Learned/"/>
    
      <category term="오늘배운것들" scheme="http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"/>
    
      <category term="자바스크립트" scheme="http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"/>
    
      <category term="Javascript" scheme="http://codeameba.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>[TIL] Factory Function를 쓰는 이유</title>
    <link href="http://codeameba.github.io/2020/04/14/programming/why-use-factory-function/"/>
    <id>http://codeameba.github.io/2020/04/14/programming/why-use-factory-function/</id>
    <published>2020-04-14T10:12:42.000Z</published>
    <updated>2020-05-13T18:09:52.671Z</updated>
    
    <content type="html"><![CDATA[<h2 id="객체-공장"><a href="#객체-공장" class="headerlink" title="객체 공장"></a>객체 공장</h2><p>Factory Function은 이름 그대로 <strong>공장 함수</strong> 인데, 무엇을 생산하는 공장이냐 하면, <strong>객체를 생산하는 공장</strong> 이라고 할 수 있다.<br>물론, ‘객체 리터럴로 만들어도 되는 객체를 굳이 함수까지 써 가면서 만들 필요가 있을까’ 라고 생각할 수도 있겠지만, 그건 어디까지 한 두 개 정도 소량의 객체일 때 이야기다. 예를 들어 SNS를 서비스한다고 했을 때 유저의 가입 정보를 받아 객체에 저장하는 경우라면 일일이 객체를 만들기 보다는 Factory Function에 유저 정보에 해당하는 parameter를 할당하여 유저가 가입할 때마다 자동으로 객체를 생산하도록 하는 편이 훨씬 효율적일 것이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userInfo = <span class="function">(<span class="params">id, name, image</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    id,</span><br><span class="line">    name,</span><br><span class="line">    image,</span><br><span class="line">    friends: [],</span><br><span class="line">    posts: [],</span><br><span class="line">    addFriend(friend) &#123;</span><br><span class="line">      <span class="keyword">this</span>.friends.push(friend);</span><br><span class="line">    &#125;,</span><br><span class="line">    createPost(post) &#123;</span><br><span class="line">      <span class="keyword">this</span>.posts.push(post);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newUser = userInfo(‘codeAmeba’, ‘Sooyoung Jeong’, ‘codeameba.jpg’);</span><br><span class="line"><span class="built_in">console</span>.log(newUser.id); <span class="comment">// codeAmeba</span></span><br><span class="line"></span><br><span class="line">newUser.addFriend(‘codeMonkey’);</span><br><span class="line"><span class="built_in">console</span>.log(newUser.friends); <span class="comment">// ["codeMonkey"]</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;객체-공장&quot;&gt;&lt;a href=&quot;#객체-공장&quot; class=&quot;headerlink&quot; title=&quot;객체 공장&quot;&gt;&lt;/a&gt;객체 공장&lt;/h2&gt;&lt;p&gt;Factory Function은 이름 그대로 &lt;strong&gt;공장 함수&lt;/strong&gt; 인데, 무엇을 생산
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://codeameba.github.io/categories/JavaScript/"/>
    
    
      <category term="til" scheme="http://codeameba.github.io/tags/til/"/>
    
      <category term="TIL" scheme="http://codeameba.github.io/tags/TIL/"/>
    
      <category term="Today I Learned" scheme="http://codeameba.github.io/tags/Today-I-Learned/"/>
    
      <category term="오늘배운것들" scheme="http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"/>
    
      <category term="자바스크립트" scheme="http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"/>
    
      <category term="Javascript" scheme="http://codeameba.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>[TIL] 화살표 함수는 편리하지만 메서드에는 자제할 것!</title>
    <link href="http://codeameba.github.io/2020/04/12/programming/arrow-function-dont-using-method/"/>
    <id>http://codeameba.github.io/2020/04/12/programming/arrow-function-dont-using-method/</id>
    <published>2020-04-12T11:12:42.000Z</published>
    <updated>2020-05-13T18:03:21.836Z</updated>
    
    <content type="html"><![CDATA[<h2 id="일급객체-자바스크립트-함수"><a href="#일급객체-자바스크립트-함수" class="headerlink" title="일급객체 자바스크립트 함수"></a>일급객체 자바스크립트 함수</h2><p>자바스크립트에서 함수는 일급객체이기에 어디든 들어갈 수 있다. 값으로도 들어가고, 파라미터로도 들어가고, 배열에도 들어가며, 객체에도 들어갈 수 있다.</p><ul><li><a href="https://codeameba.github.io/2019/05/17/programming/first-class-object/">JavaScript Preview 함수는 퍼스트 클래스? | AmebaLab</a></li></ul><h2 id="편리한-화살표-함수"><a href="#편리한-화살표-함수" class="headerlink" title="편리한 화살표 함수"></a>편리한 화살표 함수</h2><p>ES6에서 등장한 여러 문법들이 있지만, 여러모로 인상적이고 사랑 받는 문법은 단연 <strong>화살표 함수(Arrow Function)</strong> 이 아닐까 싶다. 조금만 익숙해지면, 배열 메서드 등에 편리하게 쓸 수 있으니 말이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nums = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">15</span>, <span class="number">37</span>, <span class="number">42</span>, <span class="number">68</span>, <span class="number">73</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> underOfFifty = nums.filter(<span class="function"><span class="params">num</span> =&gt;</span> num &lt; <span class="number">50</span>);</span><br><span class="line"><span class="keyword">const</span> multiplyTen = nums.map(<span class="function"><span class="params">num</span> =&gt;</span> num * <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Under Of 50: <span class="subst">$&#123;underOfFifty&#125;</span>, Multiply 10: <span class="subst">$&#123;multiplyTen&#125;</span>`</span>);</span><br><span class="line"><span class="comment">// Under Of 50: 3,5,7,15,37,42, Multiply 10: 30,50,70,150,370,420,680,730</span></span><br></pre></td></tr></table></figure><h2 id="메서드와-생성자에는-참아주세요"><a href="#메서드와-생성자에는-참아주세요" class="headerlink" title="메서드와 생성자에는 참아주세요!"></a>메서드와 생성자에는 참아주세요!</h2><p>이토록 편리한 화살표 함수지만 사용을 자제해야 하는 경우가 더러 있다.</p><h3 id="1-메서드에는-화살표-함수-금지"><a href="#1-메서드에는-화살표-함수-금지" class="headerlink" title="1. 메서드에는 화살표 함수 금지"></a>1. 메서드에는 화살표 함수 금지</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> robot = &#123;</span><br><span class="line">  name: ‘Coderoid’,</span><br><span class="line">  sayHi: <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">`Hi, <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>) &#125;,</span><br><span class="line">  sayBye: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Bye, <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">robot.sayHi(); <span class="comment">// Hi,</span></span><br><span class="line">robot.sayBye(); <span class="comment">// Bye, Coderoid</span></span><br></pre></td></tr></table></figure><p>위와 같이 <code>function</code>키워드를 사용한 메서드는 일반적으로 알려진대로 <code>this</code>가 점(.) 앞의 객체에 제대로 바인딩 되어 있지만, 화살표 함수로 만들어진 메서드는 그렇지 않다.</p><p>그렇다면, 화살표 함수의 <code>this</code>는 어디에 바인딩 되어있는 것일까? 아래의 코드를 통해 알아보자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(robot, ‘sayHi’, &#123;</span><br><span class="line">  <span class="keyword">get</span>: () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">robot[‘sayHi’];</span><br><span class="line"><span class="comment">// Window &#123;parent: Window, opener: null, top: Window, length: 0, frames: Window, …&#125;</span></span><br></pre></td></tr></table></figure><p>그렇다, 호출한 객체가 아닌 <code>window</code> 전역객체를 가리키고 있다.</p><h3 id="2-생성자에는-화살표-함수-금지"><a href="#2-생성자에는-화살표-함수-금지" class="headerlink" title="2. 생성자에는 화살표 함수 금지"></a>2. 생성자에는 화살표 함수 금지</h3><p>생성자에서 화살표 함수를 쓰게 되면 아래와 같은 오류가 발생한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Robot = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> robot = <span class="keyword">new</span> Robot();</span><br><span class="line"><span class="comment">// Uncaught TypeError: Robot is not a constructor</span></span><br></pre></td></tr></table></figure><h3 id="3-화살표-함수에는-프로토타입-prototype-이-없다"><a href="#3-화살표-함수에는-프로토타입-prototype-이-없다" class="headerlink" title="3. 화살표 함수에는 프로토타입(prototype)이 없다"></a>3. 화살표 함수에는 프로토타입(prototype)이 없다</h3><p>또한, 프로토타입 체인을 통한 프로퍼티의 위임 등을 할 수 있는 프로토타입이 화살표 함수에는 없다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Robot = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(Robot.prototype); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Rocket = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(Rocket.prototype); <span class="comment">// &#123;constructor: ƒ&#125;</span></span><br></pre></td></tr></table></figure><p>위와 같이 화살표 함수의 프로토타입은 <code>undefined</code>가 출력되고, 일반 함수의 프로토타입은 존재하는 것을 확인할 수 있다.</p><h3 id="4-yield-키워드를-쓸-수-없다"><a href="#4-yield-키워드를-쓸-수-없다" class="headerlink" title="4. yield 키워드를 쓸 수 없다"></a>4. yield 키워드를 쓸 수 없다</h3><p><code>yield</code> 키워드는 제너레이터(generator) 함수 내부의 여러 값을 필요에 따라 하나씩 반환할 수 있게 해주는데, 이러한 <code>yield</code> 키워드를 화살표 함수에서는 사용할 수가 없다. 그 말은 곧 <strong>화살표 함수는 제너레이터로 쓸 수 없다는 말</strong> 이기도 하다.</p><ul><li><strong>참고:</strong><ul><li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Functions/%EC%95%A0%EB%A1%9C%EC%9A%B0_%ED%8E%91%EC%85%98" target="_blank" rel="external nofollow noopener noreferrer">화살표 함수 - JavaScript | MDN</a></li><li><a href="https://ko.javascript.info/generators" target="_blank" rel="external nofollow noopener noreferrer">제너레이터</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;일급객체-자바스크립트-함수&quot;&gt;&lt;a href=&quot;#일급객체-자바스크립트-함수&quot; class=&quot;headerlink&quot; title=&quot;일급객체 자바스크립트 함수&quot;&gt;&lt;/a&gt;일급객체 자바스크립트 함수&lt;/h2&gt;&lt;p&gt;자바스크립트에서 함수는 일급객체이기에 어
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://codeameba.github.io/categories/JavaScript/"/>
    
    
      <category term="til" scheme="http://codeameba.github.io/tags/til/"/>
    
      <category term="TIL" scheme="http://codeameba.github.io/tags/TIL/"/>
    
      <category term="Today I Learned" scheme="http://codeameba.github.io/tags/Today-I-Learned/"/>
    
      <category term="오늘배운것들" scheme="http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"/>
    
      <category term="자바스크립트" scheme="http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"/>
    
      <category term="Javascript" scheme="http://codeameba.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>[TIL] 자주 쓰지 않지만 알면 유용한 배열 메서드</title>
    <link href="http://codeameba.github.io/2020/04/12/programming/til-some-every/"/>
    <id>http://codeameba.github.io/2020/04/12/programming/til-some-every/</id>
    <published>2020-04-11T15:41:42.000Z</published>
    <updated>2020-05-13T18:08:58.718Z</updated>
    
    <content type="html"><![CDATA[<h2 id="every"><a href="#every" class="headerlink" title=".every()"></a>.every()</h2><ul><li><code>every()</code> 메서드는 배열 안의 모든 요소가 주어진 판별 함수를 통과하는지 테스트합니다. (MDN)</li><li>간단히 말하자면, 요소 하나라도 조건식을 통과하지 못하면  <code>false</code>를 반환하고, 모든 요소가 조건식을 만족하면 <code>true</code>를 반환한다.</li><li>빈 배열일 경우에는 무조건 <code>true</code>를 반환한다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> animals = [<span class="string">'bears'</span>, <span class="string">'cats'</span>, <span class="string">'dogs'</span>, <span class="string">'elephants'</span>, <span class="string">'giraffes'</span>];</span><br><span class="line">animals.every(<span class="function"><span class="params">animal</span> =&gt;</span> animal.length &lt; <span class="number">5</span>); <span class="comment">// false</span></span><br><span class="line">animals.every(<span class="function"><span class="params">animal</span> =&gt;</span> animal.length &lt; <span class="number">10</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> beers = [];</span><br><span class="line">beers.every(<span class="function"><span class="params">beer</span> =&gt;</span> beer === ‘beer’); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><strong>참고:</strong><ul><li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/every" target="_blank" rel="external nofollow noopener noreferrer">Array.prototype.every() - JavaScript | MDN</a></li></ul></li></ul><h2 id="some"><a href="#some" class="headerlink" title=".some()"></a>.some()</h2><ul><li><code>every()</code> 메서드와 비슷하면서 다르다.</li><li>배열의 요소 중 <strong>단 하나라도</strong> 조건식을 통과하면 <code>true</code> 를 반환한다.</li><li>빈 배열의 경우는 무조건 <code>false</code>를 반환한다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nums = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">23</span>, <span class="number">37</span>, <span class="number">55</span>];</span><br><span class="line">nums.some(<span class="function"><span class="params">num</span> =&gt;</span> num &gt; <span class="number">50</span>); <span class="comment">// true</span></span><br><span class="line">nums.some(<span class="function"><span class="params">num</span> =&gt;</span> num &gt; <span class="number">60</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> beers = [];</span><br><span class="line">beers.some(<span class="function"><span class="params">beer</span> =&gt;</span> beer === <span class="string">'beer'</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li><strong>참고:</strong><ul><li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/some" target="_blank" rel="external nofollow noopener noreferrer">Array.prototype.some() - JavaScript | MDN</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;every&quot;&gt;&lt;a href=&quot;#every&quot; class=&quot;headerlink&quot; title=&quot;.every()&quot;&gt;&lt;/a&gt;.every()&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;every()&lt;/code&gt; 메서드는 배열 안의 모든 요소가 주어진 판별 
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://codeameba.github.io/categories/JavaScript/"/>
    
    
      <category term="til" scheme="http://codeameba.github.io/tags/til/"/>
    
      <category term="TIL" scheme="http://codeameba.github.io/tags/TIL/"/>
    
      <category term="Today I Learned" scheme="http://codeameba.github.io/tags/Today-I-Learned/"/>
    
      <category term="오늘배운것들" scheme="http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"/>
    
      <category term="자바스크립트" scheme="http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"/>
    
      <category term="Javascript" scheme="http://codeameba.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript Fundamental 04(마지막 업데이트: 20.04.18)</title>
    <link href="http://codeameba.github.io/2020/04/07/programming/js-fundamental-04/"/>
    <id>http://codeameba.github.io/2020/04/07/programming/js-fundamental-04/</id>
    <published>2020-04-07T09:30:42.000Z</published>
    <updated>2020-05-13T18:05:56.006Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS-Study"><a href="#JS-Study" class="headerlink" title="JS Study"></a>JS Study</h1><ul><li>자바스크립트를 다시 공부하며 놓쳤던 개념들을 정리함.</li><li>교재: 모던 자바스크립트 입문(이소 히로시 지음)</li></ul><hr><h2 id="프로토타입-체인-prototype-chain"><a href="#프로토타입-체인-prototype-chain" class="headerlink" title="프로토타입 체인(prototype chain)"></a>프로토타입 체인(prototype chain)</h2><ul><li>자바스크립트의 모든 객체는 <code>[[Prototype]]</code>이라고 하는 <strong>내부 슬롯(internal slot)</strong>을 지닌다.</li><li>하위 객체는 상위 객체의 <code>prototype</code>을 상속받으며, 상속받은 데이터는 <code>__proto__</code>에 저장된다.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myCat = &#123;</span><br><span class="line">  name: <span class="string">'Lucy'</span>,</span><br><span class="line">  sayHello: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'Hello! '</span> + <span class="keyword">this</span>.name); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> yourCat = &#123;</span><br><span class="line">  name: <span class="string">'Tom'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">yourCat.__proto__ = myCat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> whoseCat = &#123;&#125;;</span><br><span class="line">whoseCat.__proto__ = yourCat;</span><br><span class="line"></span><br><span class="line">whoseCat.sayHello(); <span class="comment">// Hello! Tom</span></span><br></pre></td></tr></table></figure><ul><li>위와 같이 <code>__proto__</code>를 통해 하위 객체와 상위 객체가 이어져 있으며, 이를 <strong>프로토타입 체인</strong> 이라고 한다. 그리고, 자신과 가까운 객체의 프로퍼티부터 위로 거슬러 올라가며 검색하게 된다.</li></ul><h3 id="Object-getPrototypeOF"><a href="#Object-getPrototypeOF" class="headerlink" title="Object.getPrototypeOF()"></a>Object.getPrototypeOF()</h3><ul><li><p>ES 명세에서나 브라우저에서나 <code>__proto__</code>를 통한 접근은 권장하지 않는다.</p></li><li><p>따라서 프로토타입 메서드에 접근해야 할 때에는 <code>Object.getPrototypeOf()</code> 또는 <code>Object.creat()</code>를 활용하도록 하자.</p></li><li><p><strong>참고:</strong></p><ul><li><a href="https://poiemaweb.com/js-prototype" target="_blank" rel="external nofollow noopener noreferrer">poiemaweb - 프로토타입</a></li><li><a href="https://poiemaweb.com/es6-class" target="_blank" rel="external nofollow noopener noreferrer">poiemaweb - 클래스</a></li><li><a href="https://ko.javascript.info/prototype-inheritance" target="_blank" rel="external nofollow noopener noreferrer">코어자바스크립트 - 프로토타입 상속</a></li></ul></li></ul><h2 id="접근자-프로퍼티"><a href="#접근자-프로퍼티" class="headerlink" title="접근자 프로퍼티"></a>접근자 프로퍼티</h2><ul><li>일반적으로 값 을 가져올 때 쓰는 접근자 프로퍼티를 <code>getter</code>, 값을 수정할 때 쓰는 접근자 프로퍼티를 <code>setter</code>라고 부른다.</li><li><strong>접근자 프로퍼티를 사용하는 이유</strong><ul><li>객체 밖에서 객체의 프로퍼티를 직접적으로 읽거나 쓰는 행위는 데이터의 유지 보수성을 해친다.</li><li>따라서, 객체가 가진 프로퍼티 값을 읽고 쓸 수 있는 특정 프로퍼티가 <code>getter</code>와 <code>setter</code>이다.</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  _name: <span class="string">'Tom'</span>,</span><br><span class="line">  <span class="keyword">get</span> name() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._name;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span> name(value) &#123;</span><br><span class="line">    <span class="keyword">const</span> str = value.charAt(<span class="number">0</span>).toUpperCase() + value.substring(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">this</span>._name = str;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// Tom</span></span><br><span class="line">person.name = <span class="string">'jane'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// Jane</span></span><br></pre></td></tr></table></figure><ul><li>접근자 프로퍼티가 없는 객체에 접근자 프로퍼티를 추가하거나 정의할 때에는 <code>Object.defineProperty</code>나 <code>Object.defineProperties</code> 메서드를 사용한다.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(user, <span class="string">'name'</span>, &#123;</span><br><span class="line">  <span class="keyword">get</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._name;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>(value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value.length &lt; <span class="number">4</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Too short! more than 4 characters'</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>._name = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">user.name = <span class="string">'Peter'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(user.name); <span class="comment">// Peter</span></span><br><span class="line"></span><br><span class="line">user.name = <span class="string">'Li'</span>; <span class="comment">// Too short! more than 4 characters</span></span><br></pre></td></tr></table></figure><ul><li><strong>참고:</strong><ul><li><a href="https://ko.javascript.info/property-accessors#ref-614" target="_blank" rel="external nofollow noopener noreferrer">프로퍼티 getter와 setter</a></li></ul></li></ul><h2 id="프로퍼티의-내부-속성"><a href="#프로퍼티의-내부-속성" class="headerlink" title="프로퍼티의 내부 속성"></a>프로퍼티의 내부 속성</h2><p>프로퍼티는 다음과 같은 세 가지 내부 속성을 논리값으로 갖는다.</p><ul><li>writable(쓰기 가능 여부)</li><li>enumerable(열거 가능 여부)</li><li>configurable(재정의 가능 여부)</li></ul><p><strong>별도의 설정 없이 프로퍼티를 추가하면 위의 세 가지 내부 속성이 모두 <code>true</code>인 상태로 생성된다.</strong></p><h3 id="Object-getOwnPropertyDescriptor"><a href="#Object-getOwnPropertyDescriptor" class="headerlink" title="Object.getOwnPropertyDescriptor"></a>Object.getOwnPropertyDescriptor</h3><p>또한, 값을 지닌 <strong>데이터 프로퍼티</strong> 와 <code>get</code>과 <code>set</code>을 지닌 <strong>접근자 프로퍼티</strong> 는 <code>Object.getOwnPropertyDescriptor</code>를 통해 확인했을 때 아래와 같은 차이가 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> robot = &#123;</span><br><span class="line">  _name: <span class="string">'coderoid'</span>,</span><br><span class="line">  serialNumber: <span class="number">1543</span>,</span><br><span class="line">  <span class="keyword">get</span> name() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>._name);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span> name(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>._name = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 데이터 프로퍼티의 프로퍼티 디스크립터</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(robot, <span class="string">'serialNumber'</span>));</span><br><span class="line"><span class="comment">// &#123;value: 1543, writable: true, enumerable: true, configurable: true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 접근자 프로퍼티의 프로퍼티 디스크립터</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(robot, <span class="string">'name'</span>));</span><br><span class="line"><span class="comment">// &#123;enumerable: true, configurable: true, get: ƒ, set: ƒ&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h3><p>이와 같은 <strong>세 가지 속성은 임의로 설정이 가능</strong> 한데, <code>Object.defineProperty</code>를 사용하면 된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> spaceShip = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(spaceShip, <span class="string">'name'</span>, &#123;</span><br><span class="line">  value: <span class="string">'codeship'</span>,</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  enumerable: <span class="literal">false</span>,</span><br><span class="line">  configurable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(spaceShip, <span class="string">'name'</span>));</span><br><span class="line"><span class="comment">// &#123;value: "codeship", writable: true, enumerable: false, configurable: false&#125;</span></span><br></pre></td></tr></table></figure><p><code>Object.defineProperty</code>를 사용할 때 생략된 속성은 <code>false</code> 혹은 <code>undefined</code>로 설정된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> spaceShip = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(spaceShip, <span class="string">'name'</span>, &#123;</span><br><span class="line">  value: <span class="string">'codeship'</span>,</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(spaceShip, <span class="string">'name'</span>));</span><br><span class="line"><span class="comment">// &#123;value: "codeship", writable: true, enumerable: false, configurable: true&#125;</span></span><br></pre></td></tr></table></figure><p>그리고, <code>configurable</code> 속성이 <code>true</code>일 때에만 생략된 속성을 추가하거나 변경할 수 있다. <code>configurable</code>이 생략된 경우에는 자동으로 <code>false</code>가 설정되므로 생략된 속성의 추가 및 변경이 불가하다.<br><code>configurable</code>이 <code>false</code>인데 속성을 추가 및 변경하려고 할 경우 <code>Uncaught TypeError: Cannot redefine property</code>가 뜬다.</p><p>단, <code>configurable</code>이 <code>false</code>더라도, <strong>단 한 번 <code>writable</code>의 값을 <code>true</code>에서 <code>false</code>로 수정 가능하며, <code>false</code>에서 <code>true</code>로 수정은 불가하다.</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> spaceShip = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(spaceShip, <span class="string">'name'</span>, &#123;</span><br><span class="line">  value: <span class="string">'codeship'</span>,</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  enumerable: <span class="literal">false</span>,</span><br><span class="line">  configurable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(spaceShip, <span class="string">'name'</span>));</span><br><span class="line"><span class="comment">// &#123;value: "codeship", writable: true, enumerable: false, configurable: true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(spaceShip, <span class="string">'name'</span>, &#123;</span><br><span class="line">  enumerable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(spaceShip, <span class="string">'name'</span>));</span><br><span class="line"><span class="comment">// &#123;value: "codeship", writable: true, enumerable: true, configurable: true&#125;</span></span><br></pre></td></tr></table></figure><ul><li><strong>참고:</strong><ul><li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor" target="_blank" rel="external nofollow noopener noreferrer">Object.getOwnPropertyDescriptor() - JavaScript | MDN</a></li><li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="external nofollow noopener noreferrer">Object.defineProperty() - JavaScript | MDN</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JS-Study&quot;&gt;&lt;a href=&quot;#JS-Study&quot; class=&quot;headerlink&quot; title=&quot;JS Study&quot;&gt;&lt;/a&gt;JS Study&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;자바스크립트를 다시 공부하며 놓쳤던 개념들을 정리함.&lt;/li&gt;
&lt;li&gt;교
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://codeameba.github.io/categories/JavaScript/"/>
    
    
      <category term="til" scheme="http://codeameba.github.io/tags/til/"/>
    
      <category term="TIL" scheme="http://codeameba.github.io/tags/TIL/"/>
    
      <category term="Today I Learned" scheme="http://codeameba.github.io/tags/Today-I-Learned/"/>
    
      <category term="오늘배운것들" scheme="http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"/>
    
      <category term="자바스크립트" scheme="http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"/>
    
      <category term="Javascript" scheme="http://codeameba.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript Fundamental 03(마지막 업데이트: 20.03.24)</title>
    <link href="http://codeameba.github.io/2020/03/24/programming/js-fundamental-03/"/>
    <id>http://codeameba.github.io/2020/03/24/programming/js-fundamental-03/</id>
    <published>2020-03-24T09:30:42.000Z</published>
    <updated>2020-05-13T18:05:51.863Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS-Study"><a href="#JS-Study" class="headerlink" title="JS Study"></a>JS Study</h1><ul><li>자바스크립트를 다시 공부하며 놓쳤던 개념들을 정리함.</li><li>교재: 모던 자바스크립트 입문(이소 히로시 지음)</li></ul><hr><h2 id="실행-컨텍스트-Execution-Centext"><a href="#실행-컨텍스트-Execution-Centext" class="headerlink" title="실행 컨텍스트(Execution Centext)"></a>실행 컨텍스트(Execution Centext)</h2><ul><li>자바스크립트 엔진은 실행 가능한 코드(Executable Code)를 만나면 그 코드를 평가(Evaluation)하여 실행 컨텍스트(Execution Context)를 만든다.</li><li>실행 컨텍스트는, 실행 가능한 코드가 실제로 실행되고 관리되는 영역이다.</li><li>실행에 필요한 모든 정보를 여러 컴포넌트에 나누어서 관리함.<ul><li>렉시컬 환경(Lexical Environment)<ul><li>환경 레코드(Environment Record)<ul><li>선언적 환경 레코드(Declarative Environment Record)</li><li>객체 환경 레코드(Object Environment Record)</li></ul></li><li>외부 렉시컬 환경 참조(Outer Lexical Environment Reference)</li></ul></li><li>변수 환경(Variable Environment)</li><li>디스 바인딩(This Binding)</li></ul></li></ul><p><strong>실행 컨텍스트의 구조를 의사 코드로 표현하면 아래와 같다.</strong></p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 실행 컨텍스트의 구조를 보여주는 pseudo code</span></span><br><span class="line">ExecutionContext = &#123;</span><br><span class="line">  LexicalEnvironment: &#123;</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      DeclarativeEnvironmentRecord: &#123;&#125;,</span><br><span class="line">      ObjectEnvironmentRecord: &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    OuterLexicalEnvironmentReference: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  VariableEnvironment: &#123;&#125;,</span><br><span class="line">  ThisBinding: <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>참고:</strong><ul><li><a href="https://www.zerocho.com/category/Javascript/post/5740531574288ebc5f2ba97e" target="_blank" rel="external nofollow noopener noreferrer">(JavaScript) 함수의 범위(scope) - lexical scoping - ZeroCho Blog</a></li><li><a href="https://www.zerocho.com/category/Javascript/post/5741d96d094da4986bc950a0" target="_blank" rel="external nofollow noopener noreferrer">(JavaScript) 실행 컨텍스트 - 클로저와 호이스팅 - ZeroCho Blog</a></li><li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Closures" target="_blank" rel="external nofollow noopener noreferrer">클로저 - JavaScript | MDN</a></li><li><a href="https://medium.com/free-code-camp/execution-context-and-the-call-stack-visually-illustrated-by-a-slice-of-tasty-cake-14f9a64dc460" target="_blank" rel="external nofollow noopener noreferrer">Execution context and the call stack — visually illustrated by a slice of tasty cake</a></li><li><a href="https://blog.bitsrc.io/understanding-execution-context-and-execution-stack-in-javascript-1c9ea8642dd0" target="_blank" rel="external nofollow noopener noreferrer">Understanding Execution Context and Execution Stack in Javascript</a></li></ul></li></ul><h2 id="렉시컬-환경-Lexical-Environment"><a href="#렉시컬-환경-Lexical-Environment" class="headerlink" title="렉시컬 환경(Lexical Environment)"></a>렉시컬 환경(Lexical Environment)</h2><ul><li>자바스크립트 엔진이 코드를 실행하기 위해 자원을 모아 둔 곳</li><li>해당 유효 범위(Scope) 안에 있는 식별자와 식별자가 가리키는 값을 <code>key : value</code>의 형태로 바인드하여 렉시컬 환경 컴포넌트에 기록한다.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LexicalEnvironment: &#123;</span><br><span class="line">  EnvironmentRecord: &#123;&#125;,</span><br><span class="line">  OuterLexicalEnvironmentReference: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>렉시컬 환경 컴포넌트에는 위와 같이 <strong>환경 레코드(Environment Record)</strong> 와 <strong>외부 렉시컬 환경 참조(Outer Lexical Environment Reference)</strong> 가 있다.<ul><li>환경 레코드: 유효 범위 내의 식별자와 값이 기록되어 있으며, 함수가 호출되면 1차적으로 이곳에서 식별자를 탐색한다.</li><li>외부 렉시컬 환경 참조: 유효 범위 너머의 식별자와 값이 기록되어 있는 곳으로, 환경 레코드에서 해당 식별자를 찾을 수 없을 때 외부 렉시컬 환경 참조를 탐색하게 된다.</li></ul></li><li>최상위의 렉시컬 환경은 <strong>전역 환경(Global Environment)</strong> 과 바인딩되어 있으며, 이곳에서의 외부 렉시컬 환경 참조는 <code>null</code>이다.</li><li><strong>결국 호이스팅(Hoisting)은, 자바스크립트의 식별자들이 해당 스코프의 렉시컬 환경에 등록된 결과라고 볼 수 있다.</strong></li></ul><h2 id="콜-스택-Call-Stack"><a href="#콜-스택-Call-Stack" class="headerlink" title="콜 스택(Call Stack)"></a>콜 스택(Call Stack)</h2><blockquote><p>후입선출(LIFO, Last In First Out) 방식으로 아래부터 데이터를 쌓아 올려 가장 마지막에 추가된 데이터부터 내보내는 자료구조를 <strong>스택(Stack)</strong> 이라고 한다.<br>이때, 데이터를 쌓는 행위를 <strong>push</strong> 라고 하고, 스택의 가장 윗부분에서 데이터를 꺼내는 행위를 <strong>pop</strong> 이라고 한다.</p></blockquote><ul><li><p>실행 컨텍스트(Execution Context)는 프로그램 실행 중 스택에 push되어 실행이 된다. 이때, 전역 코드(Global Execution Context)는 브라우저의 시작과 동시에 실행되어 브라우저를 종료할 때까지 스택의 가장 아래에 위치한다.</p></li><li><p>함수가 호출되면, 해당 실행 컨텍스트가 스택에 push 되어 실행되며, 해당 함수의 작업이 끝나면 호출했던 부분으로 제어권이 돌아오면서 스택에서 pop 된다. 이처럼 함수가 호출(Call)될 때마다 스택에 쌓인다 하여 <strong>콜 스택(Call Stack)</strong> 이라고 부른다.</p></li><li><p><strong>참고:</strong></p><ul><li><a href="https://joshua1988.github.io/web-development/translation/javascript/how-js-works-inside-engine/" target="_blank" rel="external nofollow noopener noreferrer">자바스크립트의 동작원리: 엔진, 런타임, 호출 스택 • Captain Pangyo</a></li></ul></li></ul><h2 id="스코프-체인-Scope-Chain"><a href="#스코프-체인-Scope-Chain" class="headerlink" title="스코프 체인(Scope Chain)"></a>스코프 체인(Scope Chain)</h2><ul><li>내부 스코프의 렉시컬 환경에서 필요한 식별자를 찾을 수 없을 때 외부 스코프의 렉시컬 환경을 점진적으로 탐색하게 되는데, 이처럼 렉시컬 환경을 매개로 내부와 외부의 스코프가 이어진 것을 <strong>스코프 체인(Scope Chain)</strong> 이라고 부른다.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">'A'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="string">'B'</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> c = <span class="string">'C'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a + b + c);</span><br><span class="line">  &#125;</span><br><span class="line">  g();</span><br><span class="line">&#125;</span><br><span class="line">f(); <span class="comment">// ABC</span></span><br></pre></td></tr></table></figure><p><strong>위와 같은 중첩 함수가 있을 때, 식별자 탐색 과정을 단계별로 알아보자면 다음과 같다.</strong></p><ol><li><code>g()</code>의 렉시컬 환경의 선언적 환경 레코드(Declarative Environment Record)에서 식별자 <code>c</code>를 찾는다.</li><li><code>g()</code>의 선언적 환경 레코드에서 식별자 <code>b</code>를 찾지만 못 찾고, <code>g()</code>의 외부 렉시컬 환경 참조(Outer Lexical Environment Reference)에 기록된 상위 함수 <code>f()</code>로 이동하여 탐색한다.</li><li><code>f()</code>의 렉시컬 환경의 선언적 환경 레코드에서 식별자 <code>b</code>를 찾는다.</li><li><code>f()</code>의 선언적 환경 레코드에서 식별자 <code>a</code>를 찾지만 못 찾고, <code>f()</code>의 외부 렉시컬 환경 참조에 기록된 전역 렉시컬 환경(Global Lexical Environment)로 이동하여 탐색한다.</li><li>전역 렉시컬 환경의 객체 환경 레코드(Object Environment Record)에서 식별자 <code>a</code>를 발견한다. 이때의 외부 렉시컬 환경 참조는 <code>null</code>이다.</li></ol><ul><li><strong>참고:</strong><ul><li><a href="https://poiemaweb.com/js-scope" target="_blank" rel="external nofollow noopener noreferrer">Scope | PoiemaWeb</a></li></ul></li></ul><h2 id="스코프-scope-와-실행-컨텍스트-execution-context-의-차이"><a href="#스코프-scope-와-실행-컨텍스트-execution-context-의-차이" class="headerlink" title="스코프(scope)와 실행 컨텍스트(execution context)의 차이"></a>스코프(scope)와 실행 컨텍스트(execution context)의 차이</h2><ul><li>스코프는 변수의 <strong>유효 범위</strong> 이며, 실행 컨텍스트는 실행되는 코드 덩어리라는 추삭적 개념.</li><li>스코프는 함수가 <strong>정의될 때</strong> 결정되며, 실행 컨텍스트는 함수가 <strong>실행될 때</strong> 생성된다.</li></ul><h2 id="함수의-실행-절차"><a href="#함수의-실행-절차" class="headerlink" title="함수의 실행 절차"></a>함수의 실행 절차</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  inner();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">outer();</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p><strong>위와 같은 코드가 있을 때 내부적인 실행 절차는 다음과 같다.</strong></p><ol><li>전역 실행 컨텍스트 생성</li><li>전역 변수 <code>a</code> 선언(호이스팅)</li><li>외부 함수 <code>outer</code> 선언(호이스팅)</li><li>변수 <code>a</code>에 1 할당</li><li><code>outer</code> 함수 호출 및 <code>outer</code> 실행 컨텍스트 생성</li><li>함수 <code>inner</code> 선언(<code>outer</code> 스코프에서 호이스팅)</li><li><code>outer</code> 스코프에서 <code>a</code> 탐색하지만 찾을 수 없으므로 전역 스코프에서 재탐색 후 1 출력</li><li>중첩 함수 <code>inner</code> 호출 및 <code>inner</code> 실행 컨텍스트 생성</li><li>지역 변수 <code>a</code> 선언(<code>inner</code> 스코프에서 호이스팅)</li><li><code>inner</code> 스코프에서 <code>a</code> 탐색 후 출력하지만 호이스팅만 된 단계이므로 <code>undefined</code> 출력</li><li>지역 변수 <code>a</code>에 3 할당</li><li><code>inner</code> 실행 컨텍스트 종료</li><li>제어권이 <code>outer</code> 실행 컨텍스트로 돌아오며 전역 스코프에서 변수 <code>a</code> 탐색 후 1 출력</li><li><code>outer</code> 실행 컨텍스트 종료</li><li>전역 스코프에서 변수 <code>a</code> 탐색 후 1 출력</li></ol><h2 id="가비지-컬렉션-garbage-collection"><a href="#가비지-컬렉션-garbage-collection" class="headerlink" title="가비지 컬렉션(garbage collection)"></a>가비지 컬렉션(garbage collection)</h2><ul><li><p>자바스크립트 엔진 내부에는 <strong>가비지 컬렉터(garbage collector)</strong> 가 쉬지 않고 동작하며, <strong>참조가 없는 객체를 메모리에서 해제한다.</strong> 그리고, 이러한 매커니즘을 가비지 컬렉션이라고 한다.</p></li><li><p>가비지 컬렉터 덕분에 메모리의 공간 확보를 직접 하지 않아도 되는 만큼 메모리에는 크게 신경 쓰지 않아도 되지만, 메모리 누수로 인해 퍼포먼스가 저하될 가능성이 없지 않기 때문에 전혀 고려하지 않아도 되는 것은 아니다.</p></li><li><p><strong>참고:</strong></p><ul><li><a href="https://ko.javascript.info/garbage-collection" target="_blank" rel="external nofollow noopener noreferrer">가비지 컬렉션</a></li></ul></li></ul><h2 id="클로저-closure"><a href="#클로저-closure" class="headerlink" title="클로저(closure)"></a>클로저(closure)</h2><ul><li>클로저의 주 사용 목적은 외부로부터 내부의 상태를 숨기는 <strong>캡슐화(encapsulation)</strong> 에 있다.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 보통은 익명함수를 사용하지만, 편의를 위해 이름을 붙임</span></span><br><span class="line">    <span class="keyword">return</span> count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> counter = makeCounter();</span><br><span class="line"><span class="built_in">console</span>.log(counter()); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(counter()); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(counter()); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p><strong>위와 같은 클로저가 있을 때 다음과 같은 특징을 알 수 있다.</strong></p><ol><li>외부 함수 <code>makeCounter</code>는 중첩 함수 <code>f</code>의 참조를 반환한다.</li><li>중첩 함수 <code>f</code>는 외부 함수 <code>makeCounter</code>의 지역 변수 <code>count</code>를 참조한다.</li><li>전역 변수 <code>counter</code>에 함수 <code>makeCounter</code>를 할당하였으므로, 전역 변수 <code>counter</code>는 중첩 함수 <code>f</code>의 함수 객체를 참조한다.</li><li><code>f</code>의 함수 객체는 함수 <code>makeCounter</code>의 렉시컬 환경 컴포넌트를 참조한다.</li><li>결과적으로, 전역 변수 <code>counter</code>는 중첩 함수 <code>f</code>의 함수 객체를 통해 간접적으로 외부 함수 <code>makeCounter</code>의 렉시컬 환경 컴포넌트를 참조한다.</li></ol><p><strong>클로저의 핵심:</strong></p><ul><li>외부 함수를 호출하면 해당 함수의 렉시컬 환경 컴포넌트가 생성되며, 중첩 함수의 함수 객체를 생성 및 반환한다.</li><li>외부 함수는 클로저를 생성하는 팩토리 함수이며, 클로저의 주 기능은 중첩 함수에 담겨있다.</li><li>외부 함수가 속한 렉시컬 환경 컴포넌트는 클로저 내부 상태 자체이며, 외부 함수가 호출될 때마다 새로 생성된다.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = makeCounter();</span><br><span class="line"><span class="built_in">console</span>.log(counter()); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(counter()); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(counter()); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> counter2 = makeCounter();</span><br><span class="line"><span class="built_in">console</span>.log(counter2()); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(counter2()); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(counter2()); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><ul><li>중첩 함수의 함수 객체가 있는 한 외부 함수가 속한 렉시컬 환경 컴포넌트는 지워지지 않으며, 외부 함수의 함수 객체가 사라져도 지워지지 않는다.</li><li>클로저 내부 상태(외부 함수의 지역 변수, 선언적 환경 레코드)는 외부로부터 은폐되어 있으며 중첩 함수 안에서만 읽거나 쓸 수 있다.</li></ul><p><strong>참고:</strong></p><ul><li><a href="https://opentutorials.org/course/743/6544" target="_blank" rel="external nofollow noopener noreferrer">클로저 - 생활코딩</a></li><li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Closures" target="_blank" rel="external nofollow noopener noreferrer">클로저 - JavaScript | MDN</a></li><li><a href="https://poiemaweb.com/js-closure" target="_blank" rel="external nofollow noopener noreferrer">Closure | PoiemaWeb</a></li></ul><h2 id="네임-스페이스-Name-space-오염을-줄이는-방법"><a href="#네임-스페이스-Name-space-오염을-줄이는-방법" class="headerlink" title="네임 스페이스(Name space) 오염을 줄이는 방법"></a>네임 스페이스(Name space) 오염을 줄이는 방법</h2><p>전역 변수와 전역 함수 등을 남발하게 되면 라이브러리를 쓴다거나 협업을 할 때 식별자가 충돌할 수가 있다. 따라서 전역 변수의 사용이 불가피할 경우에는 소스 코드 상단에 모아서 한눈에 파악할 수 있게 하는 것이 좋다.</p><p>그리고, 네임 스페이스의 오염을 최소화 하기 위한 방법으로는 다음과 같은 것들이 있다.</p><ol><li><p><strong>객체를 네임 스페이스로 활용하기</strong></p><ul><li>프로그램을 대표할만한 이름의 전역 변수를 하나 생성하여 객체를 값으로 할당하고, 프로그램에서 필요한 모든 변수와 함수를 프로퍼티로 정의한다.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myApp = myApp || &#123;&#125;;</span><br><span class="line"></span><br><span class="line">myApp.name = <span class="string">'Tom'</span>;</span><br><span class="line">myApp.showName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// something</span></span><br><span class="line">&#125;;</span><br><span class="line">myApp.view = &#123;&#125;; <span class="comment">// 내부에 또 다른 네임 스페이스를 만들 수도 있다.</span></span><br><span class="line">myApp.view.draw = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// something</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>즉시 실행 함수로 감싸기</strong></p><ul><li>일시적인 처리를 수행하는 내용들을 즉시 실행 함수로 감싸면 중복된 이름이 있더라도 전역 네임 스페이스를 오염시키지 않고 실행이 가능하다.</li></ul></li><li><p><strong>모듈 패턴</strong></p><ul><li>모듈(module)은 여러 기능을 하나로 묶은 것으로, 클로저(closure)를 즉시 실행 함수(IIFE)로 감싼 형태다.</li><li>이를 통하여 내부의 변수나 함수는 은폐하고, 원하는 함수만 공개할 수 있다.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Module = Module || &#123;&#125;;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">_Module</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">'NoName'</span>; <span class="comment">// 프라이빗 변수</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 프라이빗 함수</span></span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">  _Module.showName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 퍼블릭 함수</span></span><br><span class="line">    <span class="built_in">console</span>.log(getName());</span><br><span class="line">  &#125;;</span><br><span class="line">  _Module.setName = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; <span class="comment">// 퍼블릭 함수</span></span><br><span class="line">    name = x;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)(Module)</span><br><span class="line"></span><br><span class="line">Module.setName(<span class="string">'Tom'</span>);</span><br><span class="line">Module.showName(); <span class="comment">// Tom</span></span><br></pre></td></tr></table></figure></li></ol><ul><li><strong>참고:</strong><ul><li><a href="https://webcoding.tistory.com/entry/JavaScript-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EB%AA%A8%EB%93%88-%ED%8C%A8%ED%84%B4%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%BA%A1%EC%8A%90%ED%99%94" target="_blank" rel="external nofollow noopener noreferrer">JavaScript 자바스크립트 모듈 패턴을 이용한 캡슐화 :: 심플한 코딩 백과사전</a></li><li><a href="https://poiemaweb.com/js-object-oriented-programming" target="_blank" rel="external nofollow noopener noreferrer">Object-Oriented Programming | PoiemaWeb</a></li><li><a href="https://www.zerocho.com/category/Javascript/post/57541bef7dfff917002c4e86" target="_blank" rel="external nofollow noopener noreferrer">(JavaScript) 디자인 패턴(싱글턴, 모듈, 생성자) - ZeroCho Blog</a></li></ul></li></ul><h2 id="apply-call-bind"><a href="#apply-call-bind" class="headerlink" title="apply, call, bind"></a>apply, call, bind</h2><ul><li>Function 객체의 메서드에는 apply와 call이 있으며, this 값과 함수의 인수를 사용하여 함수를 실행하는 메서드다.</li><li>apply와 call은 동일하게 동작하며, 유일한 차이점은 인수를 넘기는 방식이다. apply는 배열로 인수를 넘기고, call은 쉼표로 구분한 값의 목록으로 인수를 넘긴다.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params">greetings, honorifics</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(greetings + <span class="string">''</span> + honorifics + <span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tom = &#123; <span class="attr">name</span>: <span class="string">'Tom Sawyer'</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> becky = &#123; <span class="attr">name</span>: <span class="string">'Becky Thatcher'</span> &#125;;</span><br><span class="line">say.apply(tom, [<span class="string">'Hello! '</span>, <span class="string">'Mr.'</span>]); <span class="comment">// Hello! Mr.Tom Sawyer</span></span><br><span class="line">say.call(becky, <span class="string">'Hi '</span>, <span class="string">'Ms.'</span>); <span class="comment">// Hi Ms.Becky Thatcher</span></span><br></pre></td></tr></table></figure><ul><li>bind 역시 Function 객체의 메서드이며, 객체에 함수를 바인드하는 역할을 한다.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params">greetings, honorifics</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(greetings + <span class="string">''</span> + honorifics + <span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tom = &#123; <span class="attr">name</span>: <span class="string">'Tom Sawyer'</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> sayToTom = say.bind(tom);</span><br><span class="line">sayToTom(<span class="string">'hello~ '</span>, <span class="string">'Mr.'</span>); <span class="comment">// hello~ Mr.Tom Sawyer</span></span><br></pre></td></tr></table></figure><h2 id="화살표-함수-arrow-function"><a href="#화살표-함수-arrow-function" class="headerlink" title="화살표 함수(arrow function)"></a>화살표 함수(arrow function)</h2><p>ES6에서는 익명함수의 단축 표현인 <strong>화살표 함수 표현식</strong>이 추가되었다. 화살표 함수 표현식은 아래와 같이 다양한 방법으로 작성이 가능하다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> square = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;<span class="keyword">return</span> x*x&#125;; <span class="comment">// 함수 표현식</span></span><br><span class="line"><span class="keyword">const</span> f = <span class="function">(<span class="params">x, y, z</span>) =&gt;</span> &#123;...&#125;; <span class="comment">// 인수가 여럿이라면 쉼표로 구분</span></span><br><span class="line"><span class="keyword">const</span> square = <span class="function"><span class="params">x</span> =&gt;</span> &#123;<span class="keyword">return</span> x*x&#125;; <span class="comment">// 인수가 하나라면 괄호 생략 가능</span></span><br><span class="line"><span class="keyword">const</span> f = <span class="function"><span class="params">()</span> =&gt;</span> &#123;...&#125;; <span class="comment">// 인수가 없을 때에는 빈 괄호 필수</span></span><br><span class="line"><span class="keyword">const</span> square = <span class="function"><span class="params">x</span> =&gt;</span> x*x; <span class="comment">// 함수 바디에 return문만 있으면 return 생략 가능</span></span><br><span class="line"><span class="keyword">const</span> f = <span class="function">(<span class="params">a, b</span>) =&gt;</span> (&#123;<span class="attr">x</span>:a, <span class="attr">y</span>:b&#125;); <span class="comment">// 반환값이 객체 리터럴이라면 괄호 필수</span></span><br><span class="line">(<span class="function"><span class="params">x</span> =&gt;</span> x*x)(<span class="number">3</span>); <span class="comment">// 즉시실행함수(IIFE)로 화살표 함수 사용 가능</span></span><br></pre></td></tr></table></figure><h3 id="일반-함수와-화살표-함수의-차이"><a href="#일반-함수와-화살표-함수의-차이" class="headerlink" title="일반 함수와 화살표 함수의 차이."></a>일반 함수와 화살표 함수의 차이.</h3><ol><li><p><strong>this</strong></p><ul><li>함수 리터럴로 정의한 함수는 <code>this</code>의 값이 함수를 호출할 때 결정되지만, 화살표 함수의 <code>this</code>값은 함수를 정의할 때 결정된다.</li></ul></li><li><p><strong>arguments 변수가 없음</strong></p><ul><li>화살표 함수 안에는 arguments 변수가 정의되어 있지 않아 사용할 수 없다.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> f  = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">f(); <span class="comment">// Uncaught ReferenceError: arguments is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="built_in">arguments</span>);&#125;;</span><br><span class="line">s(); <span class="comment">// Arguments [callee: ƒ, Symbol(Symbol.iterator): ƒ]</span></span><br></pre></td></tr></table></figure></li><li><p><strong>생성자로 사용 불가</strong></p><ul><li>화살표 함수 앞에는 <code>new</code> 연산자를 붙여 호출할 수 없다.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Person = <span class="function">(<span class="params">name, age</span>) =&gt;</span> &#123;<span class="keyword">this</span>.name = name; <span class="keyword">this</span>.age = age;&#125;;</span><br><span class="line"><span class="keyword">const</span> Tom = <span class="keyword">new</span> Person(<span class="string">'Tom'</span>, <span class="number">25</span>); <span class="comment">// Uncaught TypeError: Person is not a constructor</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Coffee = <span class="function"><span class="keyword">function</span>(<span class="params">name, price</span>) </span>&#123;<span class="keyword">this</span>.name = name; <span class="keyword">this</span>.price = price;&#125;;</span><br><span class="line"><span class="keyword">const</span> americano = <span class="keyword">new</span> Coffee(<span class="string">'Americano'</span>, <span class="number">4100</span>);</span><br><span class="line"><span class="built_in">console</span>.log(americano); <span class="comment">// Coffee &#123;name: "Americano", price: 4100&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(americano.price); <span class="comment">// 4100</span></span><br></pre></td></tr></table></figure></li><li><p><strong>yield 키워드를 쓸 수 없다</strong></p><ul><li>화살표 함수 안에서는 <code>yield</code> 키워드를 쓸 수 없으며, 따라서 화살표 함수는 제너레이터의 기능을 수행할 수 없다.</li></ul></li></ol><ul><li><strong>참고:</strong><ul><li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Functions/%EC%95%A0%EB%A1%9C%EC%9A%B0_%ED%8E%91%EC%85%98" target="_blank" rel="external nofollow noopener noreferrer">화살표 함수 - JavaScript | MDN</a></li><li><a href="https://poiemaweb.com/es6-arrow-function" target="_blank" rel="external nofollow noopener noreferrer">Arrow function | PoiemaWeb</a></li><li><a href="https://ko.javascript.info/arrow-functions-basics" target="_blank" rel="external nofollow noopener noreferrer">화살표 함수 기초</a></li><li><a href="https://ko.javascript.info/arrow-functions" target="_blank" rel="external nofollow noopener noreferrer">화살표 함수에 대한 재고</a></li><li><a href="https://ko.javascript.info/object-methods" target="_blank" rel="external nofollow noopener noreferrer">메서드와 ‘this’</a></li><li><a href="https://ko.javascript.info/generators" target="_blank" rel="external nofollow noopener noreferrer">제너레이터</a></li></ul></li></ul><h2 id="이터레이터-iterator"><a href="#이터레이터-iterator" class="headerlink" title="이터레이터(iterator)"></a>이터레이터(iterator)</h2><ul><li><p>이터레이터는 <strong>반복 처리(iteration)가 가능한 객체</strong> 를 말한다.</p></li><li><p><code>[Symbol.iterator]</code> 메서드를 갖고 있는 객체를 <strong>반복 가능(iterable) 한 객체</strong> 라고 한다.</p></li><li><p>주의해야 할 것은 <strong>이터레이터 객체 != 이터러블 객체</strong> 라는 점이다.</p></li><li><p>또한 <strong>이터러블 != 유사 배열</strong> 역시 다르다.</p><ul><li>유사 배열에는 <code>index</code>와 <code>length</code> 프로퍼티가 있다.</li><li>이터러블이라고 해서 꼭 유사 배열인 것은 아니며, 유사 배열이라고 해서 꼭 이터러블인 것도 아니다. 그러나 이터러블과 유사 배열의 특성을 동시에 갖는 객체도 있다. 대표적으로 문자열(String)이 그렇다.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">'string'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 아래와 같이 이터러블의 [Symbol.iterator] 메서드와</span></span><br><span class="line"><span class="comment">// 유사 배열의 index, length 프로퍼티를 동시에 지닌다.</span></span><br><span class="line">str[<span class="built_in">Symbol</span>.iterator](); <span class="comment">// StringIterator &#123;&#125;</span></span><br><span class="line">str.length; <span class="comment">// 6</span></span><br><span class="line">str[<span class="number">0</span>]; <span class="comment">// "s"</span></span><br></pre></td></tr></table></figure></li><li><p><strong>참고:</strong></p><ul><li><a href="https://ko.javascript.info/iterable" target="_blank" rel="external nofollow noopener noreferrer">iterable 객체</a></li></ul></li></ul><h2 id="제너레이터-generator"><a href="#제너레이터-generator" class="headerlink" title="제너레이터(generator)"></a>제너레이터(generator)</h2><ul><li>반복 가능한 이터레이터를 값으로 반환</li><li>작업의 일시 정지와 재시작이 가능하며 자신의 상태를 관리</li><li>제너레이터는 아래와 같이 <code>function*</code> 문으로 정의하며, 하나 이상의 <code>yield</code> 표현식을 포함한다.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> iter = <span class="keyword">get</span>();</span><br><span class="line">console.log(iter.next()); // &#123;value: <span class="number">1</span>, <span class="attr">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line"><span class="built_in">console</span>.log(iter.next()); <span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iter.next()); <span class="comment">// &#123;value: 3, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iter.next()); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><ul><li>위와 같이 제너레이터 함수의 <code>yield</code>는 프로그램이 일시적으로 정지하는 위치라고 할 수 있다.</li><li><code>yield</code> 표현식은 지정된 표현식을 값으로 갖고, 이를 변수에 대입할 수 있다.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="keyword">yield</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure><ul><li><p>제너레이터로 생성한 이터레이터는 이터러블이므로 <code>for..of</code>문을 쓸 수 있다.</p></li><li><p><strong>참고:</strong></p><ul><li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/yield" target="_blank" rel="external nofollow noopener noreferrer">yield - JavaScript | MDN</a></li><li><a href="https://meetup.toast.com/posts/73" target="_blank" rel="external nofollow noopener noreferrer">ES6의 제너레이터를 사용한 비동기 프로그래밍 : TOAST Meetup</a></li><li><a href="https://ko.javascript.info/generators" target="_blank" rel="external nofollow noopener noreferrer">제너레이터</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JS-Study&quot;&gt;&lt;a href=&quot;#JS-Study&quot; class=&quot;headerlink&quot; title=&quot;JS Study&quot;&gt;&lt;/a&gt;JS Study&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;자바스크립트를 다시 공부하며 놓쳤던 개념들을 정리함.&lt;/li&gt;
&lt;li&gt;교
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://codeameba.github.io/categories/JavaScript/"/>
    
    
      <category term="til" scheme="http://codeameba.github.io/tags/til/"/>
    
      <category term="TIL" scheme="http://codeameba.github.io/tags/TIL/"/>
    
      <category term="Today I Learned" scheme="http://codeameba.github.io/tags/Today-I-Learned/"/>
    
      <category term="오늘배운것들" scheme="http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"/>
    
      <category term="자바스크립트" scheme="http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"/>
    
      <category term="Javascript" scheme="http://codeameba.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript Fundamental 02(마지막 업데이트: 20.03.21)</title>
    <link href="http://codeameba.github.io/2020/03/21/programming/js-fundamental-02/"/>
    <id>http://codeameba.github.io/2020/03/21/programming/js-fundamental-02/</id>
    <published>2020-03-21T09:30:42.000Z</published>
    <updated>2020-05-13T18:05:47.487Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS-Study"><a href="#JS-Study" class="headerlink" title="JS Study"></a>JS Study</h1><ul><li>자바스크립트를 다시 공부하며 놓쳤던 개념들을 정리함.</li><li>교재: 모던 자바스크립트 입문(이소 히로시 지음)</li></ul><hr><h2 id="함수를-사용하는-이유"><a href="#함수를-사용하는-이유" class="headerlink" title="함수를 사용하는 이유"></a>함수를 사용하는 이유</h2><ol><li><p><strong>재사용이 가능하다.</strong></p><ul><li>동일한 작업이 반복될 경우 해당 작업을 하는 함수를 만들어 필요한 곳에서 호출만 하면 되기 때문에 코드가 간결해진다.</li></ul></li><li><p><strong>프로그램을 이해하기 쉽다.</strong></p><ul><li>함수의 이름을 알아보기 쉽게 지으면, 함수명만 보고도 프로그램의 흐름을 파악하기 쉽다.</li></ul></li><li><p><strong>프로그램의 수정이 간단해진다.</strong></p><ul><li>수정해야 할 일이 있을 때 해당되는 함수만 수정하면 된다.</li></ul></li></ol><h2 id="함수를-정의하는-방법"><a href="#함수를-정의하는-방법" class="headerlink" title="함수를 정의하는 방법"></a>함수를 정의하는 방법</h2><ol><li>함수 선언문</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>함수 리터럴</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> square = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="3"><li>Function 생성자</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> square = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'x'</span>, <span class="string">'return x * x);</span></span><br></pre></td></tr></table></figure><ol start="4"><li>화살표(arrow) 함수 표현식</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> square = <span class="function"><span class="params">x</span> =&gt;</span> x * x;</span><br></pre></td></tr></table></figure><ul><li>함수 선언문을 제외한 세 가지 방법은 호이스팅이 되지 않기 때문에 <strong>변수에 할당 후에 사용이 가능</strong> 하며, 따라서 호출하는 코드보다 상단에 위치해야 한다.</li></ul><h2 id="생성자-함수"><a href="#생성자-함수" class="headerlink" title="생성자 함수"></a>생성자 함수</h2><ul><li>Java나 C++ 등의 객체지향 언어에는 <strong>클래스(class)</strong> 라는 객체 생성 방법이 있다.</li><li>자바스크립트에는 클래스가 없지만, 대신 <strong>프로토타입(prototype)</strong> 이 있기 때문에 클래스와 유사한 방식으로 객체를 생성할 수 있다.</li><li>생성자 함수를 통해 <strong>동일한 이름에 프로퍼티 값이 다른 객체</strong> 를 효율적으로 생성할 수 있다.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Card</span>(<span class="params">suit, rank</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.suit = suit;</span><br><span class="line">  <span class="keyword">this</span>.rank = rank;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> card = <span class="keyword">new</span> Card(<span class="string">'Heart'</span>, <span class="string">'A'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(card); <span class="comment">// Card &#123; suit: 'Heart', rank: 'A' &#125;</span></span><br></pre></td></tr></table></figure><ul><li><p>이때, 통상적으로 생성자 함수라는 것을 알리기 위해 <strong>파스칼 케이스</strong>를 쓴다.</p></li><li><p>이와 같이 생성된 객체를 <strong>인스턴스</strong> 라고 부르는데, 본래 객체지향 언어에서의 인스턴스와는 차이가 있지만, 일반 객체와 구분하기 위해 편의상 인스턴스라고 부른다.</p></li><li><p><code>this</code> 는 생성자가 생성하는 객체를 가리킨다. 즉, 생성자 함수 내부의 <code>this</code> 는 인스턴스를 가리킨다고 볼 수 있다.</p></li><li><p><strong>참고:</strong></p><ul><li><a href="https://ko.javascript.info/constructor-new" target="_blank" rel="external nofollow noopener noreferrer">‘new’ 연산자와 생성자 함수</a></li><li><a href="https://ko.javascript.info/class" target="_blank" rel="external nofollow noopener noreferrer">클래스와 기본 문법</a></li><li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="external nofollow noopener noreferrer">Classes - JavaScript | MDN</a></li></ul></li></ul><h2 id="자바스크립트의-객체"><a href="#자바스크립트의-객체" class="headerlink" title="자바스크립트의 객체"></a>자바스크립트의 객체</h2><ul><li>자바스크립트의 객체는 크게 <strong>세 종류</strong> 로 구분할 수 있다.</li></ul><ol><li><p><strong>네이티브 객체</strong></p><ul><li>ECMAScript 스펙에 따라 정의된 객체를 네이티브 객체(native object)다. </li><li>Array, Function, Number 등의 내장 생성자로 생성된 객체와 JSON, Math, Reflect 등이 네이티브 객체에 포함된다.</li></ul></li><li><p><strong>호스트 객체</strong></p><ul><li>자바스크립트 실행 환경에 정의된 객체를 호스트 객체(host object)라고 한다.</li><li>Window, Navigator, History, Screen 등 브라우저 객체와 DOM 객체, Ajax를 위한 XMLHttpRequest 객체, HTML5의 여러 API에 이르기까지 클라이언트 측 자바스크립트에 정의된 객체들이 포함된다.</li></ul></li><li><p><strong>사용자 정의 객체</strong></p><ul><li>사용자가 직접 정의한 코드의 실행 결과로 생성된 객체를 말한다.</li></ul></li></ol><h2 id="희소-배열-sparse-array"><a href="#희소-배열-sparse-array" class="headerlink" title="희소 배열(sparse array)"></a>희소 배열(sparse array)</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</span><br><span class="line">a[<span class="number">4</span>] = <span class="string">'E'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// ["A", "B", "C", empty, "E"]</span></span><br><span class="line"><span class="built_in">console</span>.log(a[<span class="number">3</span>]); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(a.length); <span class="comment">// 5</span></span><br><span class="line">a.hasOwnProperty(<span class="string">"3"</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><ul><li>위와 같이 <code>length</code>가 요소의 개수보다 클 때 <strong>희소 배열</strong> 이라고 부른다.</li><li>이때 배열은 내부적으로 <strong>객체</strong> 의 형태로 저장되어 있으며, 리터럴로 표현하자면 아래와 같다.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">  <span class="string">'0'</span>:<span class="string">'A'</span>,</span><br><span class="line">  <span class="string">'1'</span>:<span class="string">'B'</span>,</span><br><span class="line">  <span class="string">'2'</span>:<span class="string">'C'</span>,</span><br><span class="line">  <span class="string">'4'</span>:<span class="string">'E'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="표현식-expression"><a href="#표현식-expression" class="headerlink" title="표현식(expression)"></a>표현식(expression)</h2><ul><li>표현식이란 결과적으로 어떤 값으로 평가(evaluation)되는 것</li><li>number, string, boolean 등의 원시 값(primitive value)은 그 자체로 가장 간단한 표현식이라고 할 수 있다.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.14</span></span><br><span class="line"><span class="string">"hello"</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">null</span></span><br></pre></td></tr></table></figure><ul><li>변수, 프로퍼티, 배열 요소, 함수 호출, 메서드 호출 등 또한 표현식이라고 할 수 있다.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sum</span><br><span class="line">circle.radius</span><br><span class="line">a[<span class="number">3</span>]</span><br><span class="line">square(<span class="number">5</span>)</span><br><span class="line">card.getSum()</span><br></pre></td></tr></table></figure><ul><li>연산자가 더해지더라도 결과적으로 값으로 평가된다면 역시 표현식이다.<ul><li>단항 연산자, 이항 연산자, 삼항 연산자 모두 그렇다.</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> c = a !== b ? <span class="string">'hello'</span> : <span class="string">'world'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">// hello</span></span><br></pre></td></tr></table></figure><h2 id="자바스크립트의-문자열은-불변-immutable"><a href="#자바스크립트의-문자열은-불변-immutable" class="headerlink" title="자바스크립트의 문자열은 불변(immutable)"></a>자바스크립트의 문자열은 불변(immutable)</h2><ul><li>자바스크립트는 원시 값을 처리할 때 원시 값을 래퍼(wrapper) 객체로 자동 변환한다.<ul><li>문자열은 String 객체, 숫자는 Number 객체, 논리값은 Boolean 객체</li><li>null과 undefined는 래퍼 객체가 없음.</li></ul></li><li>래핑은 일시적으로 진행되며 처리가 끝나면 곧바로 메모리에서 삭제된다.</li><li><strong>따라서 문자열을 직접 객체화 하지 않더라도 String 객체의 메서드를 사용할 수 있다.</strong></li><li>또한, <strong>자바스크립트의 문자열은 불변</strong> 이므로 메서드를 통해 반환되는 새로운 문자열은 원본 문자열과 별개의 값이다.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> randomString = <span class="string">'microsoft'</span>;</span><br><span class="line"><span class="keyword">const</span> newString = randomString.replace(<span class="string">'soft'</span>, <span class="string">'hard'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(randomString); <span class="comment">// microsoft</span></span><br><span class="line"><span class="built_in">console</span>.log(newString); <span class="comment">// microhard</span></span><br></pre></td></tr></table></figure><ul><li><strong>참고</strong><ul><li><a href="https://ko.javascript.info/string" target="_blank" rel="external nofollow noopener noreferrer">문자열</a></li></ul></li></ul><h2 id="truthy와-falsy"><a href="#truthy와-falsy" class="headerlink" title="truthy와 falsy"></a>truthy와 falsy</h2><ul><li>true나 false로 명시되어 있지 않더라도 논리값으로 평가되는 피연산자들이 있다.</li><li><strong>true로 평가되는 피연산자</strong><ul><li>0을 제외한 숫자, 빈 문자열을 제외한 문자열, 모든 객체, 심벌</li></ul></li><li><strong>false로 평가되는 피연산자</strong><ul><li>0, -0, 빈 문자열(“”), NaN, null, undefined</li></ul></li><li>truthy와 falsy에 각각 속한 피연산자들을 보면 나름대로의 일관성이 보이는 것을 알 수 있다. 대체적으로 <strong>없음</strong> 의 뉘앙스가 강한 쪽이 false로 평가된다.</li></ul><h2 id="암묵적-타입-변환"><a href="#암묵적-타입-변환" class="headerlink" title="암묵적 타입 변환"></a>암묵적 타입 변환</h2><ul><li>자바스크립트에서는 암묵적으로 타입을 변환하는 방법이 있다. 대표적으로 아래와 같은 방법으로 string을 number로 변환이 가능하다.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'2'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(s, <span class="keyword">typeof</span>(s)); <span class="comment">// 2 string</span></span><br><span class="line"><span class="built_in">console</span>.log(s<span class="number">-0</span>, <span class="keyword">typeof</span>(s<span class="number">-0</span>)); <span class="comment">// 2 number</span></span><br><span class="line"><span class="built_in">console</span>.log(+s, <span class="keyword">typeof</span>(+s)); <span class="comment">// 2 number</span></span><br></pre></td></tr></table></figure><ul><li>간단하고 편리한 방법이긴 하지만, 놓치고 지나칠 가능성이 농후하므로 되도록 <code>parseInt()</code>, <code>Number()</code>와 같은 명시적인 방법으로 타입을 변환하는 게 좋다고 생각한다.</li></ul><h2 id="대화상자의-종류"><a href="#대화상자의-종류" class="headerlink" title="대화상자의 종류"></a>대화상자의 종류</h2><ul><li>웹 브라우저의 전역 객체 window에는 <strong>대화상자</strong> 를 띄울 수 있는 방법이 세 가지가 있다.</li></ul><p><strong><code>window.alert()</code></strong></p><ul><li>경고 대화상자를 표시</li><li>확인을 누르면 undefiend 반환</li></ul><p><strong><code>window.prompt()</code></strong></p><ul><li>사용자의 문자열 입력을 받을 수 있는 대화상자를 표시</li><li>문자열 입력 후 확인을 누르면 해당 문자열 반환</li><li>문자열을 입력하지 않고 확인을 누르면 빈 문자열(“”) 반환</li><li>취소를 누르면 null 반환</li></ul><p><strong><code>window.confirm()</code></strong></p><ul><li>‘확인’ 버튼과 ‘취소’ 버튼이 있는 대화상자를 표시</li><li>‘확인’을 누르면 true를, ‘취소’를 누르면 false가 반환</li></ul><h2 id="for-문-실행순서"><a href="#for-문-실행순서" class="headerlink" title="for 문 실행순서"></a>for 문 실행순서</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>위와 같은 일반적인 for 문이 있을 때, 실행 순서는 다음과 같다.</strong></p><ol><li>변수 i를 선언 및 0으로 초기화 <code>let i = 0</code></li><li>i가 10 보다 작은지 확인 <code>i &lt; 10</code></li><li>블록문 실행 <code>console.log(i)</code></li><li>i의 값이 1 증가 <code>i++</code></li><li>i의 값이 10이 될 때까지 1번 내용을 제외하고 반복</li></ol><h2 id="객체-지향-프로그래밍의-의미"><a href="#객체-지향-프로그래밍의-의미" class="headerlink" title="객체 지향 프로그래밍의 의미"></a>객체 지향 프로그래밍의 의미</h2><p><strong>객체 지향 프로그래밍(OOP: Object Oriented Programming)</strong> 이란, 프로그램을 작성하는 방법 중 하나로 프로그램을 객체라고 부르는 부품 여러 개로 구성하여 만드는 방법이다. 이때, 객체란 데이터와 데이터를 처리하는 함수(메서드)를 한곳에 모아둔 덩어리를 말한다.</p><h2 id="즉시-실행-함수-Immediately-invoked-function"><a href="#즉시-실행-함수-Immediately-invoked-function" class="headerlink" title="즉시 실행 함수(Immediately-invoked function)"></a>즉시 실행 함수(Immediately-invoked function)</h2><ul><li>자바스크립트에는 익명 함수를 정의하는 동시에 실행되는 <strong>즉시 실행 함수</strong> 라는 것이 있다.</li><li>즉시 실행 함수는 전역 유효 범위(global scope)를 오염시키지 않는 이름 공간(name space)를 생성할 때 사용한다.</li><li>즉시 실행 함수는 아래와 같이 정의한다.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 첫 번째 방법</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// something</span></span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 두 번째 방법</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// something</span></span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 인수를 넣을 수도 있음</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">fact</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> n * fact(n - <span class="number">1</span>);</span><br><span class="line">&#125;)(<span class="number">5</span>); <span class="comment">// 120</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 변수에 할당 가능</span></span><br><span class="line"><span class="keyword">const</span> x = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// something</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h2 id="인수의-생략"><a href="#인수의-생략" class="headerlink" title="인수의 생략"></a>인수의 생략</h2><ul><li>함수 정의식에서 요구하는 인자의 개수보다 적은 인수를 전달할 경우 생략된 부분은 <code>undefined</code>가 된다.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`x = <span class="subst">$&#123;x&#125;</span>, y = <span class="subst">$&#123;y&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">2</span>); <span class="comment">// x = 2, y = undefined</span></span><br></pre></td></tr></table></figure><ul><li>만약 두 개 이상의 인자를 연산하여 반환해야 할 때에는 undefined가 나오는 것을 막기 위해 아래와 같이 or 연산자(||)를 활용할 수 있다.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  b = b || <span class="number">1</span>; <span class="comment">// b가 falsy값이면 1을 할당</span></span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line">multiply(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 6</span></span><br><span class="line">multiply(<span class="number">2</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h2 id="재귀함수"><a href="#재귀함수" class="headerlink" title="재귀함수"></a>재귀함수</h2><ul><li>함수가 자기 자신을 호출하는 행위를 재귀 호출(recursive call)이라고 한다.</li><li>재귀 호출을 수행하는 함수를 <strong>재귀 함수</strong> 라고 한다.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 팩토리얼 재귀함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fact</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> n * fact(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">fact(<span class="number">5</span>); <span class="comment">// 120</span></span><br></pre></td></tr></table></figure><p><strong>재귀 함수를 정의할 때 유의해야 하는 사항</strong></p><ol><li><strong>재귀 호출은 반드시 멈춰야 한다.</strong><ul><li>재귀 함수가 멈추는 조건이 반드시 있어야 하며, 그렇지 않으면 스택 오버플로우(stact overflow)를 일으키게 된다.</li></ul></li><li><strong>재귀 호출을 통해 문제를 간단히 해결할 수 있을 때만 사용한다.</strong><ul><li>재귀 함수는 메모리를 많이 차지하는 작업이다. 따라서 while문이나 for문으로 해결 가능하다면 재귀 함수를 지양하는 것이 좋다.</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JS-Study&quot;&gt;&lt;a href=&quot;#JS-Study&quot; class=&quot;headerlink&quot; title=&quot;JS Study&quot;&gt;&lt;/a&gt;JS Study&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;자바스크립트를 다시 공부하며 놓쳤던 개념들을 정리함.&lt;/li&gt;
&lt;li&gt;교
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://codeameba.github.io/categories/JavaScript/"/>
    
    
      <category term="til" scheme="http://codeameba.github.io/tags/til/"/>
    
      <category term="TIL" scheme="http://codeameba.github.io/tags/TIL/"/>
    
      <category term="Today I Learned" scheme="http://codeameba.github.io/tags/Today-I-Learned/"/>
    
      <category term="오늘배운것들" scheme="http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"/>
    
      <category term="자바스크립트" scheme="http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"/>
    
      <category term="Javascript" scheme="http://codeameba.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>유용한 웹사이트 모음(마지막 업데이트 2020.04.6)</title>
    <link href="http://codeameba.github.io/2020/03/20/programming/tip-useful-site/"/>
    <id>http://codeameba.github.io/2020/03/20/programming/tip-useful-site/</id>
    <published>2020-03-20T09:13:42.000Z</published>
    <updated>2020-04-06T09:16:46.091Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><ol><li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript" target="_blank" rel="external nofollow noopener noreferrer">JavaScript | MDN</a></li><li><a href="https://ko.javascript.info/js" target="_blank" rel="external nofollow noopener noreferrer">코어 자바스크립트</a></li><li><a href="https://poiemaweb.com/" target="_blank" rel="external nofollow noopener noreferrer">웹 프로그래밍 튜토리얼 | PoiemaWeb</a></li><li><a href="https://illustrated.dev/" target="_blank" rel="external nofollow noopener noreferrer">Illustrated.dev</a></li><li><a href="https://keycode.info/" target="_blank" rel="external nofollow noopener noreferrer">JavaScript Event KeyCodes</a></li><li><a href="https://www.30secondsofcode.org/" target="_blank" rel="external nofollow noopener noreferrer">https://www.30secondsofcode.org/</a></li><li><a href="https://codequs.com/p/r1fCkfhQU/here-are-10-projects-you-can-do-to-build-with-vanilla-javascript/?fbclid=IwAR2I9Qpv_27gtzGG-lEUH7QF4AYIE4IVjnrYw9lC8RBlMu79Bw12JH4suuo" target="_blank" rel="external nofollow noopener noreferrer">Learn Startup - Build a successful business and change the world</a></li><li><a href="https://developer.mozilla.org/ko/docs/A_re-introduction_to_JavaScript" target="_blank" rel="external nofollow noopener noreferrer">JavaScript 재입문하기 (JS ​튜토리얼) | MDN</a></li></ol><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><ol><li><a href="https://flexboxfroggy.com/#ko" target="_blank" rel="external nofollow noopener noreferrer">Flexbox Froggy - A game for learning CSS flexbox</a></li><li><a href="https://leaverou.github.io/css3patterns/" target="_blank" rel="external nofollow noopener noreferrer">CSS3 Patterns Gallery</a></li><li><a href="https://www.mydevice.io/" target="_blank" rel="external nofollow noopener noreferrer">mydevice.io : web devices capabilities</a></li><li><a href="https://www.colorzilla.com/gradient-editor/" target="_blank" rel="external nofollow noopener noreferrer">https://www.colorzilla.com/gradient-editor/</a></li><li><a href="http://nthmaster.com/" target="_blank" rel="external nofollow noopener noreferrer">Mastering the :nth-child | CSS3 pseudo classes and :nth-child ranges</a></li><li><a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/" target="_blank" rel="external nofollow noopener noreferrer">A Complete Guide to Flexbox | CSS-Tricks</a></li><li><a href="https://webgradients.com/" target="_blank" rel="external nofollow noopener noreferrer">Fresh Background Gradients | WebGradients.com 💎</a></li><li><a href="https://www.the-art-of-web.com/css/timing-function/" target="_blank" rel="external nofollow noopener noreferrer">Transition Timing Functions &lt; CSS | The Art of Web</a></li><li><a href="https://cubic-bezier.com/#.17,.67,.83,.67" target="_blank" rel="external nofollow noopener noreferrer">cubic-bezier.com</a></li><li><a href="https://daneden.github.io/animate.css/" target="_blank" rel="external nofollow noopener noreferrer">Animate.css</a></li><li><a href="https://cssbattle.dev/" target="_blank" rel="external nofollow noopener noreferrer">CSSBattle</a></li><li><a href="https://pattle.github.io/simpsons-in-css/" target="_blank" rel="external nofollow noopener noreferrer">The Simpsons in CSS</a></li><li><a href="https://griddy.io/" target="_blank" rel="external nofollow noopener noreferrer">Griddy</a></li><li><a href="https://autoprefixer.github.io/" target="_blank" rel="external nofollow noopener noreferrer">Autoprefixer CSS online</a></li><li><a href="http://gridcalculator.dk/" target="_blank" rel="external nofollow noopener noreferrer">http://gridcalculator.dk/</a></li><li><a href="http://www.colors.commutercreative.com/grid/" target="_blank" rel="external nofollow noopener noreferrer">http://www.colors.commutercreative.com/grid/</a></li><li><a href="https://uigradients.com/#Socialive" target="_blank" rel="external nofollow noopener noreferrer">uiGradients - Beautiful colored gradients</a></li><li><a href="https://www.toptal.com/designers/subtlepatterns/" target="_blank" rel="external nofollow noopener noreferrer">Subtle Patterns | Free textures for your next web project</a></li><li><a href="https://ko.learnlayout.com/" target="_blank" rel="external nofollow noopener noreferrer">CSS 레이아웃을 배웁시다</a></li><li><a href="https://csslayout.io/" target="_blank" rel="external nofollow noopener noreferrer">CSS 레이아웃 데모</a></li></ol><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><ol><li><a href="https://en.bem.info/" target="_blank" rel="external nofollow noopener noreferrer">BEM</a></li><li><a href="https://caniuse.com/" target="_blank" rel="external nofollow noopener noreferrer">Can I use… Support tables for HTML5, CSS3, etc</a></li></ol><h2 id="Tool"><a href="#Tool" class="headerlink" title="Tool"></a>Tool</h2><ol><li><a href="https://git-scm.com/book/ko/v2" target="_blank" rel="external nofollow noopener noreferrer">Git - Book</a></li><li><a href="https://ovenapp.io/" target="_blank" rel="external nofollow noopener noreferrer">Oven - HTML5-Powered Web/App Prototyping Tool</a></li><li><a href="https://www.conventionalcommits.org/ko/v1.0.0/" target="_blank" rel="external nofollow noopener noreferrer">Conventional Commits</a></li></ol><h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><ol><li><a href="https://velog.io/@velopert" target="_blank" rel="external nofollow noopener noreferrer">velopert (Minjun Kim) - velog</a></li></ol><h2 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h2><ol><li><a href="https://blog.gaerae.com/" target="_blank" rel="external nofollow noopener noreferrer">개발자스럽다</a></li><li><a href="https://www.44bits.io/ko" target="_blank" rel="external nofollow noopener noreferrer">44BITS 기술 블로그: 클라우드 컴퓨팅, 프로그래밍, 컨테이너, 리눅스</a></li><li><a href="https://d2.naver.com/home" target="_blank" rel="external nofollow noopener noreferrer">NAVER D2</a></li><li><a href="https://www.ridicorp.com/blog/" target="_blank" rel="external nofollow noopener noreferrer">Blog - 리디주식회사 RIDI Corporation</a></li><li><a href="https://meetup.toast.com/" target="_blank" rel="external nofollow noopener noreferrer">TOAST Meetup</a></li><li><a href="http://engineering.vcnc.co.kr/" target="_blank" rel="external nofollow noopener noreferrer">VCNC Engineering Blog</a></li><li><a href="https://woowabros.github.io/" target="_blank" rel="external nofollow noopener noreferrer">우아한형제들 기술 블로그</a></li><li><a href="https://blog.dramancompany.com/" target="_blank" rel="external nofollow noopener noreferrer">DRAMA&amp;COMPANY | DReam And MAke it happen</a></li><li><a href="https://tech.kakao.com/" target="_blank" rel="external nofollow noopener noreferrer">tech.kakao.com – 카카오는 사람과 사람, 사람과 기술을 한층 가깝게 연결함으로써, 어제보다 더 나은 세상을 만들어 갑니다.</a></li><li><a href="https://www.zerocho.com/" target="_blank" rel="external nofollow noopener noreferrer">ZeroCho Blog</a></li><li><a href="https://tutorialzine.com/2019/02/10-amazing-javascript-games" target="_blank" rel="external nofollow noopener noreferrer">10 Amazing JavaScript Games In Under 13kB of Code - Tutorialzine</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JavaScript&quot;&gt;&lt;a href=&quot;#JavaScript&quot; class=&quot;headerlink&quot; title=&quot;JavaScript&quot;&gt;&lt;/a&gt;JavaScript&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.mozil
      
    
    </summary>
    
    
      <category term="tip" scheme="http://codeameba.github.io/categories/tip/"/>
    
    
      <category term="tip" scheme="http://codeameba.github.io/tags/tip/"/>
    
      <category term="유용한사이트" scheme="http://codeameba.github.io/tags/%EC%9C%A0%EC%9A%A9%ED%95%9C%EC%82%AC%EC%9D%B4%ED%8A%B8/"/>
    
      <category term="북마크" scheme="http://codeameba.github.io/tags/%EB%B6%81%EB%A7%88%ED%81%AC/"/>
    
      <category term="즐겨찾기" scheme="http://codeameba.github.io/tags/%EC%A6%90%EA%B2%A8%EC%B0%BE%EA%B8%B0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript Fundamental 01(마지막 업데이트: 20.03.14)</title>
    <link href="http://codeameba.github.io/2020/03/14/programming/js-fundamental-01/"/>
    <id>http://codeameba.github.io/2020/03/14/programming/js-fundamental-01/</id>
    <published>2020-03-14T09:30:42.000Z</published>
    <updated>2020-05-13T18:05:42.733Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS-Study"><a href="#JS-Study" class="headerlink" title="JS Study"></a>JS Study</h1><ul><li>자바스크립트를 다시 공부하며 놓쳤던 개념들을 정리함.</li><li>교재: 모던 자바스크립트 입문(이소 히로시 지음)</li></ul><hr><h2 id="자바스크립트의-재탄생"><a href="#자바스크립트의-재탄생" class="headerlink" title="자바스크립트의 재탄생"></a>자바스크립트의 재탄생</h2><ul><li>자바스크립트는 기존의 다른 프로그래밍 언어들과 달리 불확실한 요소가 많아 외면 당했었다.</li><li>구글 지도에서 선보인 Ajax라는 비동기 통신 기술 덕분에 자바스크립트가 재탄생하며, 관심을 받게 되었다.</li><li>HTML5와 ES5의 등장은 자바스크립트에 날개를 달아주었다.</li></ul><h2 id="변수-variable"><a href="#변수-variable" class="headerlink" title="변수(variable)"></a>변수(variable)</h2><ul><li>변수는 값이 저장된 특정 메모리 영역을 가리키는 이름이다.</li><li>변수에 값을 할당하지 않고 선언만 하면 <code>undefined</code>가 담겨있다.</li><li><code>var</code>, <code>let</code>, <code>const</code> 등의 키워드 없이 선언된 변수는 전역변수로 취급한다.</li></ul><h2 id="변수-호이스팅-hoisting"><a href="#변수-호이스팅-hoisting" class="headerlink" title="변수 호이스팅(hoisting)"></a>변수 호이스팅(hoisting)</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><ul><li>프로그램 중간에서 변수를 선언하더라도 첫머리에 선언된 것처럼 작동하는데, 이것을 <strong>호이스팅</strong> 이라고 한다.</li><li>단, 호이스팅이 되는 것은 선언문 뿐이며, 자동으로 undefined로 초기화 된다.</li></ul><h2 id="getMonth-메서드에-1을-해야-하는-이유"><a href="#getMonth-메서드에-1을-해야-하는-이유" class="headerlink" title="getMonth() 메서드에 +1을 해야 하는 이유"></a>getMonth() 메서드에 +1을 해야 하는 이유</h2><ul><li><code>new Date()</code> 메서드 사용 시 <code>getMonth()</code> 는 0~11이기 때문에 <strong>+1</strong>을 해줘야 한다.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`오늘은 <span class="subst">$&#123;now.getMonth()+<span class="number">1</span>&#125;</span> 월 <span class="subst">$&#123;now.getDate()&#125;</span> 일입니다.`</span>); <span class="comment">//오늘은 2 월 19 일입니다.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(now.getMonth()); <span class="comment">//1</span></span><br></pre></td></tr></table></figure><h2 id="함수-function-의-동작원리"><a href="#함수-function-의-동작원리" class="headerlink" title="함수(function)의 동작원리"></a>함수(function)의 동작원리</h2><ul><li>함수를 호출하며 인수(argument)를 전달하면, 함수 정의문의 인자(parameter)로 받아 실행 결과를 반환(return)한다.</li><li><strong>자판기의 이미지가 연상됨.</strong><blockquote><ol><li>특정 음료의 가격에 맞는 금액 투입(argument)</li><li>특정 음료의 버튼 누름(call)</li><li>투입된 금액과 호출된 음료의 값을 비교</li><li>가격이 맞으면 해당 음료 반환(return)</li></ol></blockquote></li></ul><h2 id="자바스크립트의-함수는-일급객체"><a href="#자바스크립트의-함수는-일급객체" class="headerlink" title="자바스크립트의 함수는 일급객체"></a>자바스크립트의 함수는 일급객체</h2><ul><li>함수를 값으로 쓸 수 있음. -&gt; 변수에 할당 가능</li><li>다른 함수의 인수(argument)로 전달 가능</li></ul><h2 id="함수-선언문의-호이스팅"><a href="#함수-선언문의-호이스팅" class="headerlink" title="함수 선언문의 호이스팅"></a>함수 선언문의 호이스팅</h2><ul><li>변수와 마찬가지로 호이스팅이 됨</li><li>아래와 같은 <strong>함수선언문</strong> 은 전체가 통째로 호이스팅 됨</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(square(<span class="number">5</span>)); <span class="comment">// 25</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수선언문</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>return이 없으면 <code>undefined</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(square(<span class="number">5</span>)); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(square(<span class="number">3</span>)); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><ul><li>변수와 마찬가지로 <strong>선언문</strong> 만 호이스팅이 되기 때문에, 아래와 같은 <strong>함수표현식</strong> 은 변수명만 호이스팅이 됨.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 기명 함수표현식</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="function"><span class="keyword">function</span> <span class="title">bb</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'bb'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 익명 함수표현식</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'c'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>함수의 호이스팅은 코드의 순차실행을 저해하고 예측을 어렵게 하기 때문에 되도록 <strong>함수표현식</strong> 의 사용을 권함</li></ul><h2 id="값의-전달-참조의-전달"><a href="#값의-전달-참조의-전달" class="headerlink" title="값의 전달, 참조의 전달"></a>값의 전달, 참조의 전달</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add1</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x = x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> b = add1(a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`a = <span class="subst">$&#123;a&#125;</span>, b = <span class="subst">$&#123;b&#125;</span>`</span>); <span class="comment">// a = 3, b = 4</span></span><br></pre></td></tr></table></figure><ul><li>위와 같이 인수로 원시값(primitive-type)을 전달하면, 해당 값 자체가 복사되어 전달된다. 이것을 <strong>값의 전달</strong> 또는 <strong>깊은 복사(deep copy)</strong> 라고 한다.</li><li>별도의 메모리 공간에 복사되는 것이기 때문에 변수 a와 인자 x는 별개의 값이며, x의 값이 바뀌더라도 a가 영향을 받지 않는다.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add1</span>(<span class="params">p</span>) </span>&#123;</span><br><span class="line">  p.x = p.x + <span class="number">1</span>;</span><br><span class="line">  p.y = p.y + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">x</span>:<span class="number">3</span>, <span class="attr">y</span>:<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> b = add1(a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a, b); <span class="comment">// &#123; x: 4, y: 5 &#125; &#123; x: 4, y: 5 &#125;</span></span><br></pre></td></tr></table></figure><ul><li>반면에 인수로 객체(object-type)을 전달했을 때에는 참조(reference)가 전달되는 것으로 이를 <strong>참조 전달</strong> 또는 <strong>얕은 복사(shallow copy)</strong> 라고 한다.</li><li>하나의 메모리 공간에 있는 객체를 각기 다른 곳에서 가리키고 있다는 이미지로 이해할 수 있으며, 따라서 p의 값이 바뀌자 a의 값도 바뀐 것이다.</li></ul><h2 id="스코프"><a href="#스코프" class="headerlink" title="스코프"></a>스코프</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">'global'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="string">'local'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// global</span></span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f();</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// ReferenceError: b is not defined</span></span><br></pre></td></tr></table></figure><ul><li>위와 같이 함수 내부의 변수가 출력되지 않는 이유는 스코프(scope) 때문이다.</li><li>기본적으로 <strong>내부에서는 외부를 볼 수 있지만, 외부에서는 내부를 볼 수 없다</strong> 는 개념으로 이해할 수 있다.</li><li>코드가 작성되는 시점에 구문만으로 정해지는 스코프를 어휘적 스코프(lexical scope)라고 하며, 코드가 실행되는 와중에 정해지는 스코프를 동적 스코프(dynamic scope)라고 한다. <strong>자바스크립트는 lexical scope를 따른다</strong></li><li>스코프가 존재하는 가장 큰 이유는 식별자(identifier)의 충돌을 막기 위함이다.</li></ul><h2 id="메서드-method"><a href="#메서드-method" class="headerlink" title="메서드(method)"></a>메서드(method)</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> circle = &#123;</span><br><span class="line">  center: &#123; <span class="attr">x</span>:<span class="number">1.0</span>, <span class="attr">y</span>:<span class="number">2.0</span> &#125;, <span class="comment">// 원의 중심</span></span><br><span class="line">  radius: <span class="number">2.5</span>, <span class="comment">// 원의 반지름</span></span><br><span class="line">  area: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 원의 넓이를 구하는 메서드</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.PI * <span class="keyword">this</span>.radius * <span class="keyword">this</span>.radius;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">circle.translate = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123; <span class="comment">// 새로운 메서드를 추가하여 원을 이동</span></span><br><span class="line">  <span class="keyword">this</span>.center.x = <span class="keyword">this</span>.center.x + a;</span><br><span class="line">  <span class="keyword">this</span>.center.y = <span class="keyword">this</span>.center.y + b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">circle.translate(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">circle.center; <span class="comment">// &#123;x: 2, y: 4&#125;</span></span><br></pre></td></tr></table></figure><ul><li>자바스크립트에서는 객체 내부의 데이터는 모두 프로퍼티(property)이며, 프로퍼티가 함수를 값으로 가질 때, 일반 프로퍼티와 구분하기 위해 <strong>메서드(method)</strong> 라고 칭한다.</li><li>일반적으로 메서드는, 메서드가 속한 객체의 내부 데이터(프로퍼티 값) 상태를 바꾸는 용도로 사용한다.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JS-Study&quot;&gt;&lt;a href=&quot;#JS-Study&quot; class=&quot;headerlink&quot; title=&quot;JS Study&quot;&gt;&lt;/a&gt;JS Study&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;자바스크립트를 다시 공부하며 놓쳤던 개념들을 정리함.&lt;/li&gt;
&lt;li&gt;교
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://codeameba.github.io/categories/JavaScript/"/>
    
    
      <category term="til" scheme="http://codeameba.github.io/tags/til/"/>
    
      <category term="TIL" scheme="http://codeameba.github.io/tags/TIL/"/>
    
      <category term="Today I Learned" scheme="http://codeameba.github.io/tags/Today-I-Learned/"/>
    
      <category term="오늘배운것들" scheme="http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"/>
    
      <category term="자바스크립트" scheme="http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"/>
    
      <category term="Javascript" scheme="http://codeameba.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>불안의 이유</title>
    <link href="http://codeameba.github.io/2020/02/20/blog/do-it-now/"/>
    <id>http://codeameba.github.io/2020/02/20/blog/do-it-now/</id>
    <published>2020-02-20T09:05:42.000Z</published>
    <updated>2020-02-20T10:00:21.772Z</updated>
    
    <content type="html"><![CDATA[<p>대개의 경우 불안을 느끼는 이유는 부족함에 있다. 공부가 부족하여 아는 게 없을 때, 돈이 부족하여 할부금을 낼 수 없을 때, 시간이 부족하여 일을 마무리 할 수 없을 때 등.</p><p>그런데 재미있는 것은, ‘과거의 나’는 ‘지금의 나’의 불안을 예상 가능했다는 것이다. 그 말은 곧, 대부분의 불안은 ‘예측 가능한 미래보다 현재의 귀찮음이 앞설 때’ 이미 정해진다는 것이다.</p><p>불안이 싫다면, 지금 움직이자.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;대개의 경우 불안을 느끼는 이유는 부족함에 있다. 공부가 부족하여 아는 게 없을 때, 돈이 부족하여 할부금을 낼 수 없을 때, 시간이 부족하여 일을 마무리 할 수 없을 때 등.&lt;/p&gt;
&lt;p&gt;그런데 재미있는 것은, ‘과거의 나’는 ‘지금의 나’의 
      
    
    </summary>
    
    
      <category term="생각정리" scheme="http://codeameba.github.io/categories/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/"/>
    
    
      <category term="블로그" scheme="http://codeameba.github.io/tags/%EB%B8%94%EB%A1%9C%EA%B7%B8/"/>
    
      <category term="blog" scheme="http://codeameba.github.io/tags/blog/"/>
    
      <category term="생각정리" scheme="http://codeameba.github.io/tags/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/"/>
    
      <category term="불안의이유" scheme="http://codeameba.github.io/tags/%EB%B6%88%EC%95%88%EC%9D%98%EC%9D%B4%EC%9C%A0/"/>
    
  </entry>
  
  <entry>
    <title>[TIL] list와 tuple의 차이 그리고 dictionary</title>
    <link href="http://codeameba.github.io/2020/02/18/programming/python-til-01/"/>
    <id>http://codeameba.github.io/2020/02/18/programming/python-til-01/</id>
    <published>2020-02-18T04:40:42.000Z</published>
    <updated>2020-05-13T18:07:41.642Z</updated>
    
    <content type="html"><![CDATA[<h2 id="리스트-list"><a href="#리스트-list" class="headerlink" title="리스트(list)"></a>리스트(list)</h2><ul><li>리스트는 재할당(assignment)이 가능</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">x[<span class="number">0</span>] = <span class="number">5</span></span><br><span class="line">print(x) <span class="comment">#[5, 2, 3]</span></span><br></pre></td></tr></table></figure><h2 id="튜플-tuple"><a href="#튜플-tuple" class="headerlink" title="튜플(tuple)"></a>튜플(tuple)</h2><ul><li>튜플은 재할당 불가능</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">x[<span class="number">0</span>] = <span class="number">5</span></span><br><span class="line">print(x) <span class="comment">#TypeError: 'tuple' object does not support item assignment</span></span><br></pre></td></tr></table></figure><h2 id="딕셔너리-dictionary"><a href="#딕셔너리-dictionary" class="headerlink" title="딕셔너리(dictionary)"></a>딕셔너리(dictionary)</h2><ul><li><code>key : value</code> 한 쌍으로 이루어진 자료구조</li><li>자바스크립트의 객체와 유사</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = &#123;</span><br><span class="line">    “hello”: “world”,</span><br><span class="line">    “beer”: “good”,</span><br><span class="line">    <span class="number">3</span>: “what”</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(x[“beer”]) <span class="comment">#good</span></span><br><span class="line">print(x[<span class="number">3</span>]) <span class="comment">#what</span></span><br></pre></td></tr></table></figure><h2 id="리스트와-딕셔너리의-활용"><a href="#리스트와-딕셔너리의-활용" class="headerlink" title="리스트와 딕셔너리의 활용"></a>리스트와 딕셔너리의 활용</h2><ul><li>리스트에서 중복된 요소들을 딕셔너리로 정리</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fruit = [“사과”, “사과”, “바나나”, “바나나”, “딸기”, “키위”, “복숭아”, “복숭아”, “복숭아”]</span><br><span class="line"></span><br><span class="line">d = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> fruit:</span><br><span class="line">    <span class="keyword">if</span> f <span class="keyword">in</span> d:</span><br><span class="line">        d[f] = d[f] + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        d[f] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">print(d)</span><br><span class="line"><span class="comment">#&#123;'사과': 2, '바나나': 2, '딸기': 1, '키위': 1, '복숭아': 3&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;리스트-list&quot;&gt;&lt;a href=&quot;#리스트-list&quot; class=&quot;headerlink&quot; title=&quot;리스트(list)&quot;&gt;&lt;/a&gt;리스트(list)&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;리스트는 재할당(assignment)이 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;f
      
    
    </summary>
    
    
      <category term="Python" scheme="http://codeameba.github.io/categories/Python/"/>
    
    
      <category term="til" scheme="http://codeameba.github.io/tags/til/"/>
    
      <category term="TIL" scheme="http://codeameba.github.io/tags/TIL/"/>
    
      <category term="Today I Learned" scheme="http://codeameba.github.io/tags/Today-I-Learned/"/>
    
      <category term="오늘배운것들" scheme="http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"/>
    
      <category term="python" scheme="http://codeameba.github.io/tags/python/"/>
    
      <category term="파이썬" scheme="http://codeameba.github.io/tags/%ED%8C%8C%EC%9D%B4%EC%8D%AC/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 블로그에 디스커스(Disqus) 코드 추가하여 댓글 기능 넣기</title>
    <link href="http://codeameba.github.io/2020/02/15/blog/disqus-setting/"/>
    <id>http://codeameba.github.io/2020/02/15/blog/disqus-setting/</id>
    <published>2020-02-14T16:00:42.000Z</published>
    <updated>2020-02-20T22:13:53.702Z</updated>
    
    <content type="html"><![CDATA[<h2 id="디스커스-Disqus"><a href="#디스커스-Disqus" class="headerlink" title="디스커스(Disqus)"></a>디스커스(Disqus)</h2><p>네이버 블로그나 티스토리 같은 블로그 서비스에는 자체적인 댓글 기능이 있지만, Hexo, Jekyll, Gatsby 등의 정적 사이트로 블로그를 만든 경우에는 손수 댓글 기능을 추가해야만 한다. 내 경우에는 Hexo를 쓰고 있다.</p><p>물론, 테마에 따라서는 yml에 디스커스 ID를 추가하는 것만으로도 손쉽게 추가할 수도 있지만, 내가 쓰는 테마에는 없었기에 약간의 시행착오가 필요했다. 그리고, 마침내 코드를 추가하는 방식으로 디스커스 댓글 기능을 사용할 수 있게 되었고, 만약 나처럼 테마에 디스커스 항목이 없어서 당황할 사람들을 위해 기록을 남겨둔다.<br>뭐, 미래의 내가 다시 보고 따라해야 할 수도 있고…</p><h2 id="디스커스-코드-구하러-가기"><a href="#디스커스-코드-구하러-가기" class="headerlink" title="디스커스 코드 구하러 가기"></a>디스커스 코드 구하러 가기</h2><p>가입은 했다 치고, 디스커스에 접속한다. 그리고, GET STARTED를 클릭한다.<br><img src="/images/disqus01.png"></p><p>아래와 같은 페이지 넘어가게 되는데, 아이콘만 보더라도 댓글 기능처럼 보이는 위의 것을 선택한다.<br><img src="/images/disqus02.png"></p><p>그리고, 홈이 나오면, 우측 상단의 설정 메뉴에서 Admin을 눌러 이동한다. 이어서 나오는 페이지에서는 Installing Disqus를 클릭한다.<br><img src="/images/disqus03.png"><br><img src="/images/disqus04.png"></p><p>‘어라? 뭔가 잘못 찾아온 거 아닌가’ 싶을 것이다. 이어진 페이지에서 등장하는 아이콘들은 디스커스와 모종의 관계를 맺고 간단히 댓글 기능을 추가할 수 있는 자본의 노예들이다. 당황하지 말고 스크롤을 내리자.<br>그리고, ‘난 너희랑 달라~’ 라는 생각을 하며 당당하게 Universal Code를 얻으러 간다.<br><img src="/images/disqus05.png"></p><p>이것이 디스커스 댓글 기능이 담긴 코드다.<br><img src="/images/disqus06.png"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"disqus_thread"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">/**</span><br><span class="line">*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.</span><br><span class="line"><span class="actionscript">*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https:<span class="comment">//disqus.com/admin/universalcode/#configuration-variables*/</span></span></span><br><span class="line">/*</span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> disqus_config = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">this</span>.page.url = PAGE_URL;  <span class="comment">// Replace PAGE_URL with your page's canonical URL variable</span></span></span><br><span class="line"><span class="actionscript"><span class="keyword">this</span>.page.identifier = PAGE_IDENTIFIER; <span class="comment">// Replace PAGE_IDENTIFIER with your page's unique identifier variable</span></span></span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line"><span class="actionscript">(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123; <span class="comment">// DON'T EDIT BELOW THIS LINE</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> d = <span class="built_in">document</span>, s = d.createElement(<span class="string">'script'</span>);</span></span><br><span class="line"><span class="actionscript">s.src = <span class="string">'https://본인블로그URL/embed.js'</span>;</span></span><br><span class="line"><span class="javascript">s.setAttribute(<span class="string">'data-timestamp'</span>, +<span class="keyword">new</span> <span class="built_in">Date</span>());</span></span><br><span class="line">(d.head || d.body).appendChild(s);</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">noscript</span>&gt;</span>Please enable JavaScript to view the <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://disqus.com/?ref_noscript"</span>&gt;</span>comments powered by Disqus.<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">noscript</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="디스커스-코드-추가하기"><a href="#디스커스-코드-추가하기" class="headerlink" title="디스커스 코드 추가하기"></a>디스커스 코드 추가하기</h2><p>코드는 구했으니 이제 정적 페이지 소스 코드에 추가해야 한다.<br>내 경우에는 블로그를 구성하는 테마의 확장자가 ejs로 되어 있으며, 파일명을 통해 어느 페이지와 파트를 구성하는 지 대략 확인 가능하다.<br><img src="/images/disqus07.png"></p><p>댓글의 위치가 가장 하단이라고 해서 자칫 footer.ejs에 코드를 추가하는 불상사는 없길 바란다. 메인 페이지부터 컨텍 페이지까지 댓글이 달리게 되는 수가 있다. 물론, 그것이 바라던 바라면 그렇게 해도 무방하다.<br>하지만, 나는 포스트에만 댓글이 추가되길 바라기 떄문에 pose.ejs에 코드를 추가했다.<br><img src="/images/disqus08.png"></p><h2 id="디스커스-스타일-변경"><a href="#디스커스-스타일-변경" class="headerlink" title="디스커스 스타일 변경"></a>디스커스 스타일 변경</h2><p>아마 디스커스 코드만 추가하고 잘 붙었나~ 확인해보면, 아래와 같이 너비가 100%일 것이다.<br><img src="/images/disqus09.png"></p><p>이대로 마음에 든다면 그냥 써도 되겠지만, 내 포스트는 모두 최대 너비를 780px로 통일했기 때문에 조정이 필요했다. 따라서 블로그 테마의 CSS를 조금 만져야 했다. 이 또한 경우에 따라 다를 수 있겠지만, 대개의 경우 나처럼 styl(스타일러스)로 되어 있을 것이며, 만약 아니더라도 사용상의 차이는 크지 않을 것이다.<br><img src="/images/disqus10.png"></p><p>이 중에서 건드려야 할 것은 custom.styl이다. 디스커스 코드의 ID는 disqus_thread이며, 아래와 같이 스타일을 변경하였고,</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#disqus_thread</span> &#123;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">780px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">50px</span> auto;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>결과적으로 지금의 형태가 되었다.<br><img src="/images/disqus11.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;디스커스-Disqus&quot;&gt;&lt;a href=&quot;#디스커스-Disqus&quot; class=&quot;headerlink&quot; title=&quot;디스커스(Disqus)&quot;&gt;&lt;/a&gt;디스커스(Disqus)&lt;/h2&gt;&lt;p&gt;네이버 블로그나 티스토리 같은 블로그 서비스에는 자체적인 
      
    
    </summary>
    
    
      <category term="tip" scheme="http://codeameba.github.io/categories/tip/"/>
    
    
      <category term="댓글기능구현" scheme="http://codeameba.github.io/tags/%EB%8C%93%EA%B8%80%EA%B8%B0%EB%8A%A5%EA%B5%AC%ED%98%84/"/>
    
      <category term="디스커스" scheme="http://codeameba.github.io/tags/%EB%94%94%EC%8A%A4%EC%BB%A4%EC%8A%A4/"/>
    
      <category term="disqus" scheme="http://codeameba.github.io/tags/disqus/"/>
    
      <category term="hexo" scheme="http://codeameba.github.io/tags/hexo/"/>
    
      <category term="블로그" scheme="http://codeameba.github.io/tags/%EB%B8%94%EB%A1%9C%EA%B7%B8/"/>
    
      <category term="blog" scheme="http://codeameba.github.io/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>2020년은 황금시대일지도 모른다</title>
    <link href="http://codeameba.github.io/2020/02/06/blog/golden-age/"/>
    <id>http://codeameba.github.io/2020/02/06/blog/golden-age/</id>
    <published>2020-02-06T08:41:42.000Z</published>
    <updated>2020-02-06T08:53:13.697Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/midnight.png" alt="미드나잇 인 파리 캡쳐"><p>과거를 동경하는 문화는 어느 시대에나 있었을 것이다. 지금 80-90년대의 레트로 문화가 성행하듯이 말이다.</p><p>르네상스, 황금시대 등의 이름 역시 당대에 붙여진 이름이 아닌, 후대의 사람들이 과거를 동경하며 불렀을 이름이다.</p><p>현재가 아무리 최악의 시대라고 불리며, 살아가기에 녹록지 않긴 하지만, 먼 훗날 누군가는 2020년을 황금시대라며 동경할지도 모를 일이다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/images/midnight.png&quot; alt=&quot;미드나잇 인 파리 캡쳐&quot;&gt;

&lt;p&gt;과거를 동경하는 문화는 어느 시대에나 있었을 것이다. 지금 80-90년대의 레트로 문화가 성행하듯이 말이다.&lt;/p&gt;
&lt;p&gt;르네상스, 황금시대 등의 이름
      
    
    </summary>
    
    
      <category term="생각정리" scheme="http://codeameba.github.io/categories/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/"/>
    
    
      <category term="블로그" scheme="http://codeameba.github.io/tags/%EB%B8%94%EB%A1%9C%EA%B7%B8/"/>
    
      <category term="blog" scheme="http://codeameba.github.io/tags/blog/"/>
    
      <category term="생각정리" scheme="http://codeameba.github.io/tags/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/"/>
    
      <category term="황금시대" scheme="http://codeameba.github.io/tags/%ED%99%A9%EA%B8%88%EC%8B%9C%EB%8C%80/"/>
    
      <category term="미드나잇인파리" scheme="http://codeameba.github.io/tags/%EB%AF%B8%EB%93%9C%EB%82%98%EC%9E%87%EC%9D%B8%ED%8C%8C%EB%A6%AC/"/>
    
  </entry>
  
  <entry>
    <title>허니와 클로버</title>
    <link href="http://codeameba.github.io/2020/02/05/blog/honey-and-clovar/"/>
    <id>http://codeameba.github.io/2020/02/05/blog/honey-and-clovar/</id>
    <published>2020-02-05T09:05:42.000Z</published>
    <updated>2020-02-06T08:51:58.272Z</updated>
    
    <content type="html"><![CDATA[  <img src="/images/honey01.png" alt="honey and clovar">  <img src="/images/honey02.png" alt="honey and clovar">  <img src="/images/honey03.png" alt="honey and clovar"><p>20대 초반에 우연히 보게 된 허니와 클로버는 당시 혼란스러웠던 내 마음을 대변해주는 것 같았고, 10년이 훌쩍 지난 지금까지도 마음이 꺾일 것 같을 때면 다시 정주행을 하며 의욕을 재충전하는 나의 최애 콘텐츠로 자리 잡았다.</p><p>또, 수차례 정주행 하며 알게 된 또 하나의 사실은, 내 나이와 상황에 따라 감정이입을 하게 되는 캐릭터가 달라진다는 점이다.</p><p>처음에는 진로와 자아에 대해 고민하며 뛰어난 재능 앞에 열등감을 느끼는 타케모토에게서 나를 봤다면, 다음에는 얽히고설킨 인간관계 사이에서 망설이는 마야마에게서, 그리고 지금은 어른이 되어서도 여전히 과거의 고민으로부터 벗어나지 못하는 하나모토 교수에게서 내 모습이 보인다.</p><p>그리고 아무리 마음에 와닿는 장면이라도 담담하게 볼 수 있던 예전과는 달리, 몇 번씩 울컥하게 된다. 이것은 내가 감정적으로 성숙했다는 긍정적인 의미로 해석하면 될까.</p>]]></content>
    
    <summary type="html">
    
      
      
          &lt;img src=&quot;/images/honey01.png&quot; alt=&quot;honey and clovar&quot;&gt;
  &lt;img src=&quot;/images/honey02.png&quot; alt=&quot;honey and clovar&quot;&gt;
  &lt;img src=&quot;/images/honey0
      
    
    </summary>
    
    
      <category term="생각정리" scheme="http://codeameba.github.io/categories/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/"/>
    
    
      <category term="블로그" scheme="http://codeameba.github.io/tags/%EB%B8%94%EB%A1%9C%EA%B7%B8/"/>
    
      <category term="blog" scheme="http://codeameba.github.io/tags/blog/"/>
    
      <category term="생각정리" scheme="http://codeameba.github.io/tags/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/"/>
    
      <category term="허니와클로버" scheme="http://codeameba.github.io/tags/%ED%97%88%EB%8B%88%EC%99%80%ED%81%B4%EB%A1%9C%EB%B2%84/"/>
    
  </entry>
  
</feed>
