<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AmebaLab</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://codeameba.github.io/"/>
  <updated>2020-03-24T10:23:01.219Z</updated>
  <id>http://codeameba.github.io/</id>
  
  <author>
    <name>Sooyoung Jeong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript Fundamental 03(마지막 업데이트: 20.03.24)</title>
    <link href="http://codeameba.github.io/2020/03/24/programming/js-fundamental-03/"/>
    <id>http://codeameba.github.io/2020/03/24/programming/js-fundamental-03/</id>
    <published>2020-03-24T09:30:42.000Z</published>
    <updated>2020-03-24T10:23:01.219Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS-Study"><a href="#JS-Study" class="headerlink" title="JS Study"></a>JS Study</h1><ul><li>자바스크립트를 다시 공부하며 놓쳤던 개념들을 정리함.</li><li>교재: 모던 자바스크립트 입문(이소 히로시 지음)</li></ul><hr><h2 id="실행-컨텍스트-Execution-Centext"><a href="#실행-컨텍스트-Execution-Centext" class="headerlink" title="실행 컨텍스트(Execution Centext)"></a>실행 컨텍스트(Execution Centext)</h2><ul><li>자바스크립트 엔진은 실행 가능한 코드(Executable Code)를 만나면 그 코드를 평가(Evaluation)하여 실행 컨텍스트(Execution Context)를 만든다.</li><li>실행 컨텍스트는, 실행 가능한 코드가 실제로 실행되고 관리되는 영역이다.</li><li>실행에 필요한 모든 정보를 여러 컴포넌트에 나누어서 관리함.<ul><li>렉시컬 환경(Lexical Environment)<ul><li>환경 레코드(Environment Record)<ul><li>선언적 환경 레코드(Declarative Environment Record)</li><li>객체 환경 레코드(Object Environment Record)</li></ul></li><li>외부 렉시컬 환경 참조(Outer Lexical Environment Reference)</li></ul></li><li>변수 환경(Variable Environment)</li><li>디스 바인딩(This Binding)</li></ul></li></ul><p><strong>실행 컨텍스트의 구조를 의사 코드로 표현하면 아래와 같다.</strong><br>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 실행 컨텍스트의 구조를 보여주는 pseudo code</span></span><br><span class="line">ExecutionContext = &#123;</span><br><span class="line">  LexicalEnvironment: &#123;</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      DeclarativeEnvironmentRecord: &#123;&#125;,</span><br><span class="line">      ObjectEnvironmentRecord: &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    OuterLexicalEnvironmentReference: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  VariableEnvironment: &#123;&#125;,</span><br><span class="line">  ThisBinding: <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><strong>참고:</strong><ul><li><a href="https://www.zerocho.com/category/Javascript/post/5740531574288ebc5f2ba97e" target="_blank" rel="external nofollow noopener noreferrer">(JavaScript) 함수의 범위(scope) - lexical scoping - ZeroCho Blog</a></li><li><a href="https://www.zerocho.com/category/Javascript/post/5741d96d094da4986bc950a0" target="_blank" rel="external nofollow noopener noreferrer">(JavaScript) 실행 컨텍스트 - 클로저와 호이스팅 - ZeroCho Blog</a></li><li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Closures" target="_blank" rel="external nofollow noopener noreferrer">클로저 - JavaScript | MDN</a></li><li><a href="https://medium.com/free-code-camp/execution-context-and-the-call-stack-visually-illustrated-by-a-slice-of-tasty-cake-14f9a64dc460" target="_blank" rel="external nofollow noopener noreferrer">Execution context and the call stack — visually illustrated by a slice of tasty cake</a></li><li><a href="https://blog.bitsrc.io/understanding-execution-context-and-execution-stack-in-javascript-1c9ea8642dd0" target="_blank" rel="external nofollow noopener noreferrer">Understanding Execution Context and Execution Stack in Javascript</a></li></ul></li></ul><h2 id="렉시컬-환경-Lexical-Environment"><a href="#렉시컬-환경-Lexical-Environment" class="headerlink" title="렉시컬 환경(Lexical Environment)"></a>렉시컬 환경(Lexical Environment)</h2><ul><li>자바스크립트 엔진이 코드를 실행하기 위해 자원을 모아 둔 곳</li><li>해당 유효 범위(Scope) 안에 있는 식별자와 식별자가 가리키는 값을 <code>key : value</code>의 형태로 바인드하여 렉시컬 환경 컴포넌트에 기록한다.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LexicalEnvironment: &#123;</span><br><span class="line">  EnvironmentRecord: &#123;&#125;,</span><br><span class="line">  OuterLexicalEnvironmentReference: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>렉시컬 환경 컴포넌트에는 위와 같이 <strong>환경 레코드(Environment Record)</strong> 와 <strong>외부 렉시컬 환경 참조(Outer Lexical Environment Reference)</strong> 가 있다.<ul><li>환경 레코드: 유효 범위 내의 식별자와 값이 기록되어 있으며, 함수가 호출되면 1차적으로 이곳에서 식별자를 탐색한다.</li><li>외부 렉시컬 환경 참조: 유효 범위 너머의 식별자와 값이 기록되어 있는 곳으로, 환경 레코드에서 해당 식별자를 찾을 수 없을 때 외부 렉시컬 환경 참조를 탐색하게 된다.</li></ul></li><li>최상위의 렉시컬 환경은 <strong>전역 환경(Global Environment)</strong> 과 바인딩되어 있으며, 이곳에서의 외부 렉시컬 환경 참조는 <code>null</code>이다.</li><li><strong>결국 호이스팅(Hoisting)은, 자바스크립트의 식별자들이 해당 스코프의 렉시컬 환경에 등록된 결과라고 볼 수 있다.</strong></li></ul><h2 id="콜-스택-Call-Stack"><a href="#콜-스택-Call-Stack" class="headerlink" title="콜 스택(Call Stack)"></a>콜 스택(Call Stack)</h2><blockquote><p>후입선출(LIFO, Last In First Out) 방식으로 아래부터 데이터를 쌓아 올려 가장 마지막에 추가된 데이터부터 내보내는 자료구조를 <strong>스택(Stack)</strong> 이라고 한다.<br>이때, 데이터를 쌓는 행위를 <strong>push</strong> 라고 하고, 스택의 가장 윗부분에서 데이터를 꺼내는 행위를 <strong>pop</strong> 이라고 한다.</p></blockquote><ul><li><p>실행 컨텍스트(Execution Context)는 프로그램 실행 중 스택에 push되어 실행이 된다. 이때, 전역 코드(Global Execution Context)는 브라우저의 시작과 동시에 실행되어 브라우저를 종료할 때까지 스택의 가장 아래에 위치한다.</p></li><li><p>함수가 호출되면, 해당 실행 컨텍스트가 스택에 push 되어 실행되며, 해당 함수의 작업이 끝나면 호출했던 부분으로 제어권이 돌아오면서 스택에서 pop 된다. 이처럼 함수가 호출(Call)될 때마다 스택에 쌓인다 하여 <strong>콜 스택(Call Stack)</strong> 이라고 부른다.</p></li><li><p><strong>참고:</strong></p><ul><li><a href="https://joshua1988.github.io/web-development/translation/javascript/how-js-works-inside-engine/" target="_blank" rel="external nofollow noopener noreferrer">자바스크립트의 동작원리: 엔진, 런타임, 호출 스택 • Captain Pangyo</a></li></ul></li></ul><h2 id="스코프-체인-Scope-Chain"><a href="#스코프-체인-Scope-Chain" class="headerlink" title="스코프 체인(Scope Chain)"></a>스코프 체인(Scope Chain)</h2><ul><li>내부 스코프의 렉시컬 환경에서 필요한 식별자를 찾을 수 없을 때 외부 스코프의 렉시컬 환경을 점진적으로 탐색하게 되는데, 이처럼 렉시컬 환경을 매개로 내부와 외부의 스코프가 이어진 것을 <strong>스코프 체인(Scope Chain)</strong> 이라고 부른다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">'A'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="string">'B'</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> c = <span class="string">'C'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a + b + c);</span><br><span class="line">  &#125;</span><br><span class="line">  g();</span><br><span class="line">&#125;</span><br><span class="line">f(); <span class="comment">// ABC</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>위와 같은 중첩 함수가 있을 때, 식별자 탐색 과정을 단계별로 알아보자면 다음과 같다.</strong></p><ol><li><code>g()</code>의 렉시컬 환경의 선언적 환경 레코드(Declarative Environment Record)에서 식별자 <code>c</code>를 찾는다.</li><li><code>g()</code>의 선언적 환경 레코드에서 식별자 <code>b</code>를 찾지만 못 찾고, <code>g()</code>의 외부 렉시컬 환경 참조(Outer Lexical Environment Reference)에 기록된 상위 함수 <code>f()</code>로 이동하여 탐색한다.</li><li><code>f()</code>의 렉시컬 환경의 선언적 환경 레코드에서 식별자 <code>b</code>를 찾는다.</li><li><code>f()</code>의 선언적 환경 레코드에서 식별자 <code>a</code>를 찾지만 못 찾고, <code>f()</code>의 외부 렉시컬 환경 참조에 기록된 전역 렉시컬 환경(Global Lexical Environment)로 이동하여 탐색한다.</li><li>전역 렉시컬 환경의 객체 환경 레코드(Object Environment Record)에서 식별자 <code>a</code>를 발견한다. 이때의 외부 렉시컬 환경 참조는 <code>null</code>이다.</li></ol><ul><li><strong>참고:</strong><ul><li><a href="https://poiemaweb.com/js-scope" target="_blank" rel="external nofollow noopener noreferrer">Scope | PoiemaWeb</a></li></ul></li></ul><h2 id="스코프-scope-와-실행-컨텍스트-execution-context-의-차이"><a href="#스코프-scope-와-실행-컨텍스트-execution-context-의-차이" class="headerlink" title="스코프(scope)와 실행 컨텍스트(execution context)의 차이"></a>스코프(scope)와 실행 컨텍스트(execution context)의 차이</h2><ul><li>스코프는 변수의 <strong>유효 범위</strong> 이며, 실행 컨텍스트는 실행되는 코드 덩어리라는 추삭적 개념.</li><li>스코프는 함수가 <strong>정의될 때</strong> 결정되며, 실행 컨텍스트는 함수가 <strong>실행될 때</strong> 생성된다.</li></ul><h2 id="함수의-실행-절차"><a href="#함수의-실행-절차" class="headerlink" title="함수의 실행 절차"></a>함수의 실행 절차</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  inner();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">outer();</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p><strong>위와 같은 코드가 있을 때 내부적인 실행 절차는 다음과 같다.</strong></p><ol><li>전역 실행 컨텍스트 생성</li><li>전역 변수 <code>a</code> 선언(호이스팅)</li><li>외부 함수 <code>outer</code> 선언(호이스팅)</li><li>변수 <code>a</code>에 1 할당</li><li><code>outer</code> 함수 호출 및 <code>outer</code> 실행 컨텍스트 생성</li><li>함수 <code>inner</code> 선언(<code>outer</code> 스코프에서 호이스팅)</li><li><code>outer</code> 스코프에서 <code>a</code> 탐색하지만 찾을 수 없으므로 전역 스코프에서 재탐색 후 1 출력</li><li>중첩 함수 <code>inner</code> 호출 및 <code>inner</code> 실행 컨텍스트 생성</li><li>지역 변수 <code>a</code> 선언(<code>inner</code> 스코프에서 호이스팅)</li><li><code>inner</code> 스코프에서 <code>a</code> 탐색 후 출력하지만 호이스팅만 된 단계이므로 <code>undefined</code> 출력</li><li>지역 변수 <code>a</code>에 3 할당</li><li><code>inner</code> 실행 컨텍스트 종료</li><li>제어권이 <code>outer</code> 실행 컨텍스트로 돌아오며 전역 스코프에서 변수 <code>a</code> 탐색 후 1 출력</li><li><code>outer</code> 실행 컨텍스트 종료</li><li>전역 스코프에서 변수 <code>a</code> 탐색 후 1 출력</li></ol><h2 id="가비지-컬렉션-garbage-collection"><a href="#가비지-컬렉션-garbage-collection" class="headerlink" title="가비지 컬렉션(garbage collection)"></a>가비지 컬렉션(garbage collection)</h2><ul><li><p>자바스크립트 엔진 내부에는 <strong>가비지 컬렉터(garbage collector)</strong> 가 쉬지 않고 동작하며, <strong>참조가 없는 객체를 메모리에서 해제한다.</strong> 그리고, 이러한 매커니즘을 가비지 컬렉션이라고 한다.</p></li><li><p>가비지 컬렉터 덕분에 메모리의 공간 확보를 직접 하지 않아도 되는 만큼 메모리에는 크게 신경 쓰지 않아도 되지만, 메모리 누수로 인해 퍼포먼스가 저하될 가능성이 없지 않기 때문에 전혀 고려하지 않아도 되는 것은 아니다.</p></li><li><p><strong>참고:</strong></p><ul><li><a href="https://ko.javascript.info/garbage-collection" target="_blank" rel="external nofollow noopener noreferrer">가비지 컬렉션</a></li></ul></li></ul><h2 id="클로저-closure"><a href="#클로저-closure" class="headerlink" title="클로저(closure)"></a>클로저(closure)</h2><ul><li>클로저의 주 사용 목적은 외부로부터 내부의 상태를 숨기는 <strong>캡슐화(encapsulation)</strong> 에 있다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 보통은 익명함수를 사용하지만, 편의를 위해 이름을 붙임</span></span><br><span class="line">    <span class="keyword">return</span> count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> counter = makeCounter();</span><br><span class="line"><span class="built_in">console</span>.log(counter()); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(counter()); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(counter()); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>위와 같은 클로저가 있을 때 다음과 같은 특징을 알 수 있다.</strong></p><ol><li>외부 함수 <code>makeCounter</code>는 중첩 함수 <code>f</code>의 참조를 반환한다.</li><li>중첩 함수 <code>f</code>는 외부 함수 <code>makeCounter</code>의 지역 변수 <code>count</code>를 참조한다.</li><li>전역 변수 <code>counter</code>에 함수 <code>makeCounter</code>를 할당하였으므로, 전역 변수 <code>counter</code>는 중첩 함수 <code>f</code>의 함수 객체를 참조한다.</li><li><code>f</code>의 함수 객체는 함수 <code>makeCounter</code>의 렉시컬 환경 컴포넌트를 참조한다.</li><li>결과적으로, 전역 변수 <code>counter</code>는 중첩 함수 <code>f</code>의 함수 객체를 통해 간접적으로 외부 함수 <code>makeCounter</code>의 렉시컬 환경 컴포넌트를 참조한다.</li></ol><p><strong>클로저의 핵심:</strong></p><ul><li>외부 함수를 호출하면 해당 함수의 렉시컬 환경 컴포넌트가 생성되며, 중첩 함수의 함수 객체를 생성 및 반환한다.</li><li>외부 함수는 클로저를 생성하는 팩토리 함수이며, 클로저의 주 기능은 중첩 함수에 담겨있다.</li><li>외부 함수가 속한 렉시컬 환경 컴포넌트는 클로저 내부 상태 자체이며, 외부 함수가 호출될 때마다 새로 생성된다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = makeCounter();</span><br><span class="line"><span class="built_in">console</span>.log(counter()); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(counter()); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(counter()); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> counter2 = makeCounter();</span><br><span class="line"><span class="built_in">console</span>.log(counter2()); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(counter2()); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(counter2()); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li><li>중첩 함수의 함수 객체가 있는 한 외부 함수가 속한 렉시컬 환경 컴포넌트는 지워지지 않으며, 외부 함수의 함수 객체가 사라져도 지워지지 않는다.</li><li>클로저 내부 상태(외부 함수의 지역 변수, 선언적 환경 레코드)는 외부로부터 은폐되어 있으며 중첩 함수 안에서만 읽거나 쓸 수 있다.</li></ul><p><strong>참고:</strong></p><ul><li><a href="https://opentutorials.org/course/743/6544" target="_blank" rel="external nofollow noopener noreferrer">클로저 - 생활코딩</a></li><li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Closures" target="_blank" rel="external nofollow noopener noreferrer">클로저 - JavaScript | MDN</a></li><li><a href="https://poiemaweb.com/js-closure" target="_blank" rel="external nofollow noopener noreferrer">Closure | PoiemaWeb</a></li></ul><h2 id="네임-스페이스-Name-space-오염을-줄이는-방법"><a href="#네임-스페이스-Name-space-오염을-줄이는-방법" class="headerlink" title="네임 스페이스(Name space) 오염을 줄이는 방법"></a>네임 스페이스(Name space) 오염을 줄이는 방법</h2><p>전역 변수와 전역 함수 등을 남발하게 되면 라이브러리를 쓴다거나 협업을 할 때 식별자가 충돌할 수가 있다. 따라서 전역 변수의 사용이 불가피할 경우에는 소스 코드 상단에 모아서 한눈에 파악할 수 있게 하는 것이 좋다.</p><p>그리고, 네임 스페이스의 오염을 최소화 하기 위한 방법으로는 다음과 같은 것들이 있다.</p><ol><li><p><strong>객체를 네임 스페이스로 활용하기</strong></p><ul><li>프로그램을 대표할만한 이름의 전역 변수를 하나 생성하여 객체를 값으로 할당하고, 프로그램에서 필요한 모든 변수와 함수를 프로퍼티로 정의한다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myApp = myApp || &#123;&#125;;</span><br><span class="line"></span><br><span class="line">myApp.name = <span class="string">'Tom'</span>;</span><br><span class="line">myApp.showName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// something</span></span><br><span class="line">&#125;;</span><br><span class="line">myApp.view = &#123;&#125;; <span class="comment">// 내부에 또 다른 네임 스페이스를 만들 수도 있다.</span></span><br><span class="line">myApp.view.draw = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// something</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>즉시 실행 함수로 감싸기</strong></p><ul><li>일시적인 처리를 수행하는 내용들을 즉시 실행 함수로 감싸면 중복된 이름이 있더라도 전역 네임 스페이스를 오염시키지 않고 실행이 가능하다.</li></ul></li><li><p><strong>모듈 패턴</strong></p><ul><li>모듈(module)은 여러 기능을 하나로 묶은 것으로, 클로저(closure)를 즉시 실행 함수(IIFE)로 감싼 형태다.</li><li>이를 통하여 내부의 변수나 함수는 은폐하고, 원하는 함수만 공개할 수 있다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Module = Module || &#123;&#125;;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">_Module</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">'NoName'</span>; <span class="comment">// 프라이빗 변수</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 프라이빗 함수</span></span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">  _Module.showName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 퍼블릭 함수</span></span><br><span class="line">    <span class="built_in">console</span>.log(getName());</span><br><span class="line">  &#125;;</span><br><span class="line">  _Module.setName = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; <span class="comment">// 퍼블릭 함수</span></span><br><span class="line">    name = x;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)(Module)</span><br><span class="line"></span><br><span class="line">Module.setName(<span class="string">'Tom'</span>);</span><br><span class="line">Module.showName(); <span class="comment">// Tom</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><ul><li><strong>참고:</strong><ul><li><a href="https://webcoding.tistory.com/entry/JavaScript-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EB%AA%A8%EB%93%88-%ED%8C%A8%ED%84%B4%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%BA%A1%EC%8A%90%ED%99%94" target="_blank" rel="external nofollow noopener noreferrer">JavaScript 자바스크립트 모듈 패턴을 이용한 캡슐화 :: 심플한 코딩 백과사전</a></li><li><a href="https://poiemaweb.com/js-object-oriented-programming" target="_blank" rel="external nofollow noopener noreferrer">Object-Oriented Programming | PoiemaWeb</a></li><li><a href="https://www.zerocho.com/category/Javascript/post/57541bef7dfff917002c4e86" target="_blank" rel="external nofollow noopener noreferrer">(JavaScript) 디자인 패턴(싱글턴, 모듈, 생성자) - ZeroCho Blog</a></li></ul></li></ul><h2 id="apply-call-bind"><a href="#apply-call-bind" class="headerlink" title="apply, call, bind"></a>apply, call, bind</h2><ul><li><p>Function 객체의 메서드에는 apply와 call이 있으며, this 값과 함수의 인수를 사용하여 함수를 실행하는 메서드다.</p></li><li><p>apply와 call은 동일하게 동작하며, 유일한 차이점은 인수를 넘기는 방식이다. apply는 배열로 인수를 넘기고, call은 쉼표로 구분한 값의 목록으로 인수를 넘긴다. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params">greetings, honorifics</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(greetings + <span class="string">''</span> + honorifics + <span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tom = &#123; <span class="attr">name</span>: <span class="string">'Tom Sawyer'</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> becky = &#123; <span class="attr">name</span>: <span class="string">'Becky Thatcher'</span> &#125;;</span><br><span class="line">say.apply(tom, [<span class="string">'Hello! '</span>, <span class="string">'Mr.'</span>]); <span class="comment">// Hello! Mr.Tom Sawyer</span></span><br><span class="line">say.call(becky, <span class="string">'Hi '</span>, <span class="string">'Ms.'</span>); <span class="comment">// Hi Ms.Becky Thatcher</span></span><br></pre></td></tr></table></figure></li><li><p>bind 역시 Function 객체의 메서드이며, 객체에 함수를 바인드하는 역할을 한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params">greetings, honorifics</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(greetings + <span class="string">''</span> + honorifics + <span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tom = &#123; <span class="attr">name</span>: <span class="string">'Tom Sawyer'</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> sayToTom = say.bind(tom);</span><br><span class="line">sayToTom(<span class="string">'hello~ '</span>, <span class="string">'Mr.'</span>); <span class="comment">// hello~ Mr.Tom Sawyer</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="화살표-함수-arrow-function"><a href="#화살표-함수-arrow-function" class="headerlink" title="화살표 함수(arrow function)"></a>화살표 함수(arrow function)</h2><p>ES6에서는 익명함수의 단축 표현인 <strong>화살표 함수 표현식</strong>이 추가되었다. 화살표 함수 표현식은 아래와 같이 다양한 방법으로 작성이 가능하다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> square = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;<span class="keyword">return</span> x*x&#125;; <span class="comment">// 함수 표현식</span></span><br><span class="line"><span class="keyword">const</span> f = <span class="function">(<span class="params">x, y, z</span>) =&gt;</span> &#123;...&#125;; <span class="comment">// 인수가 여럿이라면 쉼표로 구분</span></span><br><span class="line"><span class="keyword">const</span> square = <span class="function"><span class="params">x</span> =&gt;</span> &#123;<span class="keyword">return</span> x*x&#125;; <span class="comment">// 인수가 하나라면 괄호 생략 가능</span></span><br><span class="line"><span class="keyword">const</span> f = <span class="function"><span class="params">()</span> =&gt;</span> &#123;...&#125;; <span class="comment">// 인수가 없을 때에는 빈 괄호 필수</span></span><br><span class="line"><span class="keyword">const</span> square = <span class="function"><span class="params">x</span> =&gt;</span> x*x; <span class="comment">// 함수 바디에 return문만 있으면 return 생략 가능</span></span><br><span class="line"><span class="keyword">const</span> f = <span class="function">(<span class="params">a, b</span>) =&gt;</span> (&#123;<span class="attr">x</span>:a, <span class="attr">y</span>:b&#125;); <span class="comment">// 반환값이 객체 리터럴이라면 괄호 필수</span></span><br><span class="line">(<span class="function"><span class="params">x</span> =&gt;</span> x*x)(<span class="number">3</span>); <span class="comment">// 즉시실행함수(IIFE)로 화살표 함수 사용 가능</span></span><br></pre></td></tr></table></figure><h3 id="일반-함수와-화살표-함수의-차이"><a href="#일반-함수와-화살표-함수의-차이" class="headerlink" title="일반 함수와 화살표 함수의 차이."></a>일반 함수와 화살표 함수의 차이.</h3><ol><li><p><strong>this</strong></p><ul><li>함수 리터럴로 정의한 함수는 <code>this</code>의 값이 함수를 호출할 때 결정되지만, 화살표 함수의 <code>this</code>값은 함수를 정의할 때 결정된다.</li></ul></li><li><p><strong>arguments 변수가 없음</strong></p><ul><li>화살표 함수 안에는 arguments 변수가 정의되어 있지 않아 사용할 수 없다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> f  = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">f(); <span class="comment">// Uncaught ReferenceError: arguments is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="built_in">arguments</span>);&#125;;</span><br><span class="line">s(); <span class="comment">// Arguments [callee: ƒ, Symbol(Symbol.iterator): ƒ]</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>생성자로 사용 불가</strong></p><ul><li>화살표 함수 앞에는 <code>new</code> 연산자를 붙여 호출할 수 없다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Person = <span class="function">(<span class="params">name, age</span>) =&gt;</span> &#123;<span class="keyword">this</span>.name = name; <span class="keyword">this</span>.age = age;&#125;;</span><br><span class="line"><span class="keyword">const</span> Tom = <span class="keyword">new</span> Person(<span class="string">'Tom'</span>, <span class="number">25</span>); <span class="comment">// Uncaught TypeError: Person is not a constructor</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Coffee = <span class="function"><span class="keyword">function</span>(<span class="params">name, price</span>) </span>&#123;<span class="keyword">this</span>.name = name; <span class="keyword">this</span>.price = price;&#125;;</span><br><span class="line"><span class="keyword">const</span> americano = <span class="keyword">new</span> Coffee(<span class="string">'Americano'</span>, <span class="number">4100</span>);</span><br><span class="line"><span class="built_in">console</span>.log(americano); <span class="comment">// Coffee &#123;name: "Americano", price: 4100&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(americano.price); <span class="comment">// 4100</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>yield 키워드를 쓸 수 없다</strong></p><ul><li>화살표 함수 안에서는 <code>yield</code> 키워드를 쓸 수 없으며, 따라서 화살표 함수는 제너레이터의 기능을 수행할 수 없다.</li></ul></li></ol><ul><li><strong>참고:</strong><ul><li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Functions/%EC%95%A0%EB%A1%9C%EC%9A%B0_%ED%8E%91%EC%85%98" target="_blank" rel="external nofollow noopener noreferrer">화살표 함수 - JavaScript | MDN</a></li><li><a href="https://poiemaweb.com/es6-arrow-function" target="_blank" rel="external nofollow noopener noreferrer">Arrow function | PoiemaWeb</a></li><li><a href="https://ko.javascript.info/arrow-functions-basics" target="_blank" rel="external nofollow noopener noreferrer">화살표 함수 기초</a></li><li><a href="https://ko.javascript.info/arrow-functions" target="_blank" rel="external nofollow noopener noreferrer">화살표 함수에 대한 재고</a></li><li><a href="https://ko.javascript.info/object-methods" target="_blank" rel="external nofollow noopener noreferrer">메서드와 ‘this’</a></li><li><a href="https://ko.javascript.info/generators" target="_blank" rel="external nofollow noopener noreferrer">제너레이터</a></li></ul></li></ul><h2 id="이터레이터-iterator"><a href="#이터레이터-iterator" class="headerlink" title="이터레이터(iterator)"></a>이터레이터(iterator)</h2><ul><li><p>이터레이터는 <strong>반복 처리(iteration)가 가능한 객체</strong> 를 말한다.</p></li><li><p><code>[Symbol.iterator]</code> 메서드를 갖고 있는 객체를 <strong>반복 가능(iterable) 한 객체</strong> 라고 한다.</p></li><li><p>주의해야 할 것은 <strong>이터레이터 객체 != 이터러블 객체</strong> 라는 점이다.</p></li><li><p>또한 <strong>이터러블 != 유사 배열</strong> 역시 다르다.</p><ul><li>유사 배열에는 <code>index</code>와 <code>length</code> 프로퍼티가 있다.</li><li>이터러블이라고 해서 꼭 유사 배열인 것은 아니며, 유사 배열이라고 해서 꼭 이터러블인 것도 아니다. 그러나 이터러블과 유사 배열의 특성을 동시에 갖는 객체도 있다. 대표적으로 문자열(String)이 그렇다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">'string'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 아래와 같이 이터러블의 [Symbol.iterator] 메서드와</span></span><br><span class="line"><span class="comment">// 유사 배열의 index, length 프로퍼티를 동시에 지닌다.</span></span><br><span class="line">str[<span class="built_in">Symbol</span>.iterator](); <span class="comment">// StringIterator &#123;&#125;</span></span><br><span class="line">str.length; <span class="comment">// 6</span></span><br><span class="line">str[<span class="number">0</span>]; <span class="comment">// "s"</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>참고:</strong></p><ul><li><a href="https://ko.javascript.info/iterable" target="_blank" rel="external nofollow noopener noreferrer">iterable 객체</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JS-Study&quot;&gt;&lt;a href=&quot;#JS-Study&quot; class=&quot;headerlink&quot; title=&quot;JS Study&quot;&gt;&lt;/a&gt;JS Study&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;자바스크립트를 다시 공부하며 놓쳤던 개념들을 정리함.&lt;/li&gt;
&lt;li&gt;교
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://codeameba.github.io/categories/JavaScript/"/>
    
    
      <category term="til" scheme="http://codeameba.github.io/tags/til/"/>
    
      <category term="TIL" scheme="http://codeameba.github.io/tags/TIL/"/>
    
      <category term="Today I Learned" scheme="http://codeameba.github.io/tags/Today-I-Learned/"/>
    
      <category term="오늘배운것들" scheme="http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"/>
    
      <category term="자바스크립트" scheme="http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"/>
    
      <category term="Javascript" scheme="http://codeameba.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript Fundamental 02(마지막 업데이트: 20.03.21)</title>
    <link href="http://codeameba.github.io/2020/03/21/programming/js-fundamental-02/"/>
    <id>http://codeameba.github.io/2020/03/21/programming/js-fundamental-02/</id>
    <published>2020-03-21T09:30:42.000Z</published>
    <updated>2020-03-24T10:24:24.825Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS-Study"><a href="#JS-Study" class="headerlink" title="JS Study"></a>JS Study</h1><ul><li>자바스크립트를 다시 공부하며 놓쳤던 개념들을 정리함.</li><li>교재: 모던 자바스크립트 입문(이소 히로시 지음)</li></ul><hr><h2 id="함수를-사용하는-이유"><a href="#함수를-사용하는-이유" class="headerlink" title="함수를 사용하는 이유"></a>함수를 사용하는 이유</h2><ol><li><p><strong>재사용이 가능하다.</strong></p><ul><li>동일한 작업이 반복될 경우 해당 작업을 하는 함수를 만들어 필요한 곳에서 호출만 하면 되기 때문에 코드가 간결해진다.</li></ul></li><li><p><strong>프로그램을 이해하기 쉽다.</strong></p><ul><li>함수의 이름을 알아보기 쉽게 지으면, 함수명만 보고도 프로그램의 흐름을 파악하기 쉽다.</li></ul></li><li><p><strong>프로그램의 수정이 간단해진다.</strong></p><ul><li>수정해야 할 일이 있을 때 해당되는 함수만 수정하면 된다.</li></ul></li></ol><h2 id="함수를-정의하는-방법"><a href="#함수를-정의하는-방법" class="headerlink" title="함수를 정의하는 방법"></a>함수를 정의하는 방법</h2><ol><li>함수 선언문<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>함수 리터럴<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> square = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>Function 생성자<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> square = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'x'</span>, <span class="string">'return x * x);</span></span><br></pre></td></tr></table></figure></li><li>화살표(arrow) 함수 표현식<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> square = <span class="function"><span class="params">x</span> =&gt;</span> x * x;</span><br></pre></td></tr></table></figure></li></ol><ul><li>함수 선언문을 제외한 세 가지 방법은 호이스팅이 되지 않기 때문에 <strong>변수에 할당 후에 사용이 가능</strong> 하며, 따라서 호출하는 코드보다 상단에 위치해야 한다.</li></ul><h2 id="생성자-함수"><a href="#생성자-함수" class="headerlink" title="생성자 함수"></a>생성자 함수</h2><ul><li>Java나 C++ 등의 객체지향 언어에는 <strong>클래스(class)</strong> 라는 객체 생성 방법이 있다.</li><li>자바스크립트에는 클래스가 없지만, 대신 <strong>프로토타입(prototype)</strong> 이 있기 때문에 클래스와 유사한 방식으로 객체를 생성할 수 있다.</li><li>생성자 함수를 통해 <strong>동일한 이름에 프로퍼티 값이 다른 객체</strong> 를 효율적으로 생성할 수 있다.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Card</span>(<span class="params">suit, rank</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.suit = suit;</span><br><span class="line">  <span class="keyword">this</span>.rank = rank;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> card = <span class="keyword">new</span> Card(<span class="string">'Heart'</span>, <span class="string">'A'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(card); <span class="comment">// Card &#123; suit: 'Heart', rank: 'A' &#125;</span></span><br></pre></td></tr></table></figure><ul><li>이때, 통상적으로 생성자 함수라는 것을 알리기 위해 <strong>파스칼 케이스</strong>를 쓴다.</li><li>이와 같이 생성된 객체를 <strong>인스턴스</strong> 라고 부르는데, 본래 객체지향 언어에서의 인스턴스와는 차이가 있지만, 일반 객체와 구분하기 위해 편의상 인스턴스라고 부른다.</li><li><code>this</code> 는 생성자가 생성하는 객체를 가리킨다. 즉, 생성자 함수 내부의 <code>this</code> 는 인스턴스를 가리킨다고 볼 수 있다.</li><li><strong>참고:</strong> <ul><li><a href="https://ko.javascript.info/constructor-new" target="_blank" rel="external nofollow noopener noreferrer">‘new’ 연산자와 생성자 함수</a></li><li><a href="https://ko.javascript.info/class" target="_blank" rel="external nofollow noopener noreferrer">클래스와 기본 문법</a></li><li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="external nofollow noopener noreferrer">Classes - JavaScript | MDN</a></li></ul></li></ul><h2 id="자바스크립트의-객체"><a href="#자바스크립트의-객체" class="headerlink" title="자바스크립트의 객체"></a>자바스크립트의 객체</h2><ul><li>자바스크립트의 객체는 크게 <strong>세 종류</strong> 로 구분할 수 있다.</li></ul><ol><li><p><strong>네이티브 객체</strong></p><ul><li>ECMAScript 스펙에 따라 정의된 객체를 네이티브 객체(native object)다. </li><li>Array, Function, Number 등의 내장 생성자로 생성된 객체와 JSON, Math, Reflect 등이 네이티브 객체에 포함된다.</li></ul></li><li><p><strong>호스트 객체</strong></p><ul><li>자바스크립트 실행 환경에 정의된 객체를 호스트 객체(host object)라고 한다.</li><li>Window, Navigator, History, Screen 등 브라우저 객체와 DOM 객체, Ajax를 위한 XMLHttpRequest 객체, HTML5의 여러 API에 이르기까지 클라이언트 측 자바스크립트에 정의된 객체들이 포함된다.</li></ul></li><li><p><strong>사용자 정의 객체</strong></p><ul><li>사용자가 직접 정의한 코드의 실행 결과로 생성된 객체를 말한다.</li></ul></li></ol><h2 id="희소-배열-sparse-array"><a href="#희소-배열-sparse-array" class="headerlink" title="희소 배열(sparse array)"></a>희소 배열(sparse array)</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</span><br><span class="line">a[<span class="number">4</span>] = <span class="string">'E'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// ["A", "B", "C", empty, "E"]</span></span><br><span class="line"><span class="built_in">console</span>.log(a[<span class="number">3</span>]); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(a.length); <span class="comment">// 5</span></span><br><span class="line">a.hasOwnProperty(<span class="string">"3"</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><ul><li>위와 같이 <code>length</code>가 요소의 개수보다 클 때 <strong>희소 배열</strong> 이라고 부른다.</li><li>이때 배열은 내부적으로 <strong>객체</strong> 의 형태로 저장되어 있으며, 리터럴로 표현하자면 아래와 같다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">  <span class="string">'0'</span>:<span class="string">'A'</span>,</span><br><span class="line">  <span class="string">'1'</span>:<span class="string">'B'</span>,</span><br><span class="line">  <span class="string">'2'</span>:<span class="string">'C'</span>,</span><br><span class="line">  <span class="string">'4'</span>:<span class="string">'E'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="표현식-expression"><a href="#표현식-expression" class="headerlink" title="표현식(expression)"></a>표현식(expression)</h2></li><li>표현식이란 결과적으로 어떤 값으로 평가(evaluation)되는 것</li><li>number, string, boolean 등의 원시 값(primitive value)은 그 자체로 가장 간단한 표현식이라고 할 수 있다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.14</span></span><br><span class="line"><span class="string">"hello"</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">null</span></span><br></pre></td></tr></table></figure></li><li>변수, 프로퍼티, 배열 요소, 함수 호출, 메서드 호출 등 또한 표현식이라고 할 수 있다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sum</span><br><span class="line">circle.radius</span><br><span class="line">a[<span class="number">3</span>]</span><br><span class="line">square(<span class="number">5</span>)</span><br><span class="line">card.getSum()</span><br></pre></td></tr></table></figure></li><li>연산자가 더해지더라도 결과적으로 값으로 평가된다면 역시 표현식이다.<ul><li>단항 연산자, 이항 연산자, 삼항 연산자 모두 그렇다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> c = a !== b ? <span class="string">'hello'</span> : <span class="string">'world'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">// hello</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="자바스크립트의-문자열은-불변-immutable"><a href="#자바스크립트의-문자열은-불변-immutable" class="headerlink" title="자바스크립트의 문자열은 불변(immutable)"></a>자바스크립트의 문자열은 불변(immutable)</h2><ul><li>자바스크립트는 원시 값을 처리할 때 원시 값을 래퍼(wrapper) 객체로 자동 변환한다.<ul><li>문자열은 String 객체, 숫자는 Number 객체, 논리값은 Boolean 객체</li><li>null과 undefined는 래퍼 객체가 없음.</li></ul></li><li>래핑은 일시적으로 진행되며 처리가 끝나면 곧바로 메모리에서 삭제된다.</li><li><strong>따라서 문자열을 직접 객체화 하지 않더라도 String 객체의 메서드를 사용할 수 있다.</strong></li><li>또한, <strong>자바스크립트의 문자열은 불변</strong> 이므로 메서드를 통해 반환되는 새로운 문자열은 원본 문자열과 별개의 값이다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> randomString = <span class="string">'microsoft'</span>;</span><br><span class="line"><span class="keyword">const</span> newString = randomString.replace(<span class="string">'soft'</span>, <span class="string">'hard'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(randomString); <span class="comment">// microsoft</span></span><br><span class="line"><span class="built_in">console</span>.log(newString); <span class="comment">// microhard</span></span><br></pre></td></tr></table></figure></li><li><strong>참고</strong><ul><li><a href="https://ko.javascript.info/string" target="_blank" rel="external nofollow noopener noreferrer">문자열</a></li></ul></li></ul><h2 id="truthy와-falsy"><a href="#truthy와-falsy" class="headerlink" title="truthy와 falsy"></a>truthy와 falsy</h2><ul><li>true나 false로 명시되어 있지 않더라도 논리값으로 평가되는 피연산자들이 있다.</li><li><strong>true로 평가되는 피연산자</strong><ul><li>0을 제외한 숫자, 빈 문자열을 제외한 문자열, 모든 객체, 심벌</li></ul></li><li><strong>false로 평가되는 피연산자</strong><ul><li>0, -0, 빈 문자열(“”), NaN, null, undefined</li></ul></li><li>truthy와 falsy에 각각 속한 피연산자들을 보면 나름대로의 일관성이 보이는 것을 알 수 있다. 대체적으로 <strong>없음</strong> 의 뉘앙스가 강한 쪽이 false로 평가된다.</li></ul><h2 id="암묵적-타입-변환"><a href="#암묵적-타입-변환" class="headerlink" title="암묵적 타입 변환"></a>암묵적 타입 변환</h2><ul><li>자바스크립트에서는 암묵적으로 타입을 변환하는 방법이 있다. 대표적으로 아래와 같은 방법으로 string을 number로 변환이 가능하다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'2'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(s, <span class="keyword">typeof</span>(s)); <span class="comment">// 2 string</span></span><br><span class="line"><span class="built_in">console</span>.log(s<span class="number">-0</span>, <span class="keyword">typeof</span>(s<span class="number">-0</span>)); <span class="comment">// 2 number</span></span><br><span class="line"><span class="built_in">console</span>.log(+s, <span class="keyword">typeof</span>(+s)); <span class="comment">// 2 number</span></span><br></pre></td></tr></table></figure></li><li>간단하고 편리한 방법이긴 하지만, 놓치고 지나칠 가능성이 농후하므로 되도록 <code>parseInt()</code>, <code>Number()</code>와 같은 명시적인 방법으로 타입을 변환하는 게 좋다고 생각한다.</li></ul><h2 id="대화상자의-종류"><a href="#대화상자의-종류" class="headerlink" title="대화상자의 종류"></a>대화상자의 종류</h2><ul><li>웹 브라우저의 전역 객체 window에는 <strong>대화상자</strong> 를 띄울 수 있는 방법이 세 가지가 있다.</li></ul><p><strong><code>window.alert()</code></strong></p><ul><li>경고 대화상자를 표시</li><li>확인을 누르면 undefiend 반환</li></ul><p><strong><code>window.prompt()</code></strong></p><ul><li>사용자의 문자열 입력을 받을 수 있는 대화상자를 표시</li><li>문자열 입력 후 확인을 누르면 해당 문자열 반환</li><li>문자열을 입력하지 않고 확인을 누르면 빈 문자열(“”) 반환</li><li>취소를 누르면 null 반환</li></ul><p><strong><code>window.confirm()</code></strong></p><ul><li>‘확인’ 버튼과 ‘취소’ 버튼이 있는 대화상자를 표시</li><li>‘확인’을 누르면 true를, ‘취소’를 누르면 false가 반환</li></ul><h2 id="for-문-실행순서"><a href="#for-문-실행순서" class="headerlink" title="for 문 실행순서"></a>for 문 실행순서</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>위와 같은 일반적인 for 문이 있을 때, 실행 순서는 다음과 같다.</strong></p><ol><li>변수 i를 선언 및 0으로 초기화 <code>let i = 0</code></li><li>i가 10 보다 작은지 확인 <code>i &lt; 10</code></li><li>블록문 실행 <code>console.log(i)</code></li><li>i의 값이 1 증가 <code>i++</code></li><li>i의 값이 10이 될 때까지 1번 내용을 제외하고 반복</li></ol><h2 id="객체-지향-프로그래밍의-의미"><a href="#객체-지향-프로그래밍의-의미" class="headerlink" title="객체 지향 프로그래밍의 의미"></a>객체 지향 프로그래밍의 의미</h2><p><strong>객체 지향 프로그래밍(OOP: Object Oriented Programming)</strong> 이란, 프로그램을 작성하는 방법 중 하나로 프로그램을 객체라고 부르는 부품 여러 개로 구성하여 만드는 방법이다. 이때, 객체란 데이터와 데이터를 처리하는 함수(메서드)를 한곳에 모아둔 덩어리를 말한다.</p><h2 id="즉시-실행-함수-Immediately-invoked-function"><a href="#즉시-실행-함수-Immediately-invoked-function" class="headerlink" title="즉시 실행 함수(Immediately-invoked function)"></a>즉시 실행 함수(Immediately-invoked function)</h2><ul><li>자바스크립트에는 익명 함수를 정의하는 동시에 실행되는 <strong>즉시 실행 함수</strong> 라는 것이 있다.</li><li>즉시 실행 함수는 전역 유효 범위(global scope)를 오염시키지 않는 이름 공간(name space)를 생성할 때 사용한다.</li><li>즉시 실행 함수는 아래와 같이 정의한다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 첫 번째 방법</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// something</span></span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 두 번째 방법</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// something</span></span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 인수를 넣을 수도 있음</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">fact</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> n * fact(n - <span class="number">1</span>);</span><br><span class="line">&#125;)(<span class="number">5</span>); <span class="comment">// 120</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 변수에 할당 가능</span></span><br><span class="line"><span class="keyword">const</span> x = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// something</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></li></ul><h2 id="인수의-생략"><a href="#인수의-생략" class="headerlink" title="인수의 생략"></a>인수의 생략</h2><ul><li>함수 정의식에서 요구하는 인자의 개수보다 적은 인수를 전달할 경우 생략된 부분은 undefined가 된다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`x = <span class="subst">$&#123;x&#125;</span>, y = <span class="subst">$&#123;y&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">2</span>); <span class="comment">// x = 2, y = undefined</span></span><br></pre></td></tr></table></figure></li><li>만약 두 개 이상의 인자를 연산하여 반환해야 할 때에는 undefined가 나오는 것을 막기 위해 아래와 같이 or 연산자(||)를 활용할 수 있다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  b = b || <span class="number">1</span>; <span class="comment">// b가 falsy값이면 1을 할당</span></span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line">multiply(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 6</span></span><br><span class="line">multiply(<span class="number">2</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="재귀함수"><a href="#재귀함수" class="headerlink" title="재귀함수"></a>재귀함수</h2><ul><li>함수가 자기 자신을 호출하는 행위를 재귀 호출(recursive call)이라고 한다.</li><li>재귀 호출을 수행하는 함수를 <strong>재귀 함수</strong> 라고 한다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 팩토리얼 재귀함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fact</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> n * fact(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">fact(<span class="number">5</span>); <span class="comment">// 120</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>재귀 함수를 정의할 때 유의해야 하는 사항</strong></p><ol><li><strong>재귀 호출은 반드시 멈춰야 한다.</strong><ul><li>재귀 함수가 멈추는 조건이 반드시 있어야 하며, 그렇지 않으면 스택 오버플로우(stact overflow)를 일으키게 된다.</li></ul></li><li><strong>재귀 호출을 통해 문제를 간단히 해결할 수 있을 때만 사용한다.</strong><ul><li>재귀 함수는 메모리를 많이 차지하는 작업이다. 따라서 while문이나 for문으로 해결 가능하다면 재귀 함수를 지양하는 것이 좋다.</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JS-Study&quot;&gt;&lt;a href=&quot;#JS-Study&quot; class=&quot;headerlink&quot; title=&quot;JS Study&quot;&gt;&lt;/a&gt;JS Study&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;자바스크립트를 다시 공부하며 놓쳤던 개념들을 정리함.&lt;/li&gt;
&lt;li&gt;교
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://codeameba.github.io/categories/JavaScript/"/>
    
    
      <category term="til" scheme="http://codeameba.github.io/tags/til/"/>
    
      <category term="TIL" scheme="http://codeameba.github.io/tags/TIL/"/>
    
      <category term="Today I Learned" scheme="http://codeameba.github.io/tags/Today-I-Learned/"/>
    
      <category term="오늘배운것들" scheme="http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"/>
    
      <category term="자바스크립트" scheme="http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"/>
    
      <category term="Javascript" scheme="http://codeameba.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>유용한 웹사이트 모음(마지막 업데이트 2020.03.31)</title>
    <link href="http://codeameba.github.io/2020/03/20/programming/tip-useful-site/"/>
    <id>http://codeameba.github.io/2020/03/20/programming/tip-useful-site/</id>
    <published>2020-03-20T09:13:42.000Z</published>
    <updated>2020-03-31T10:22:08.684Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><ol><li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript" target="_blank" rel="external nofollow noopener noreferrer">JavaScript | MDN</a></li><li><a href="https://ko.javascript.info/js" target="_blank" rel="external nofollow noopener noreferrer">코어 자바스크립트</a></li><li><a href="https://poiemaweb.com/" target="_blank" rel="external nofollow noopener noreferrer">웹 프로그래밍 튜토리얼 | PoiemaWeb</a></li><li><a href="https://illustrated.dev/" target="_blank" rel="external nofollow noopener noreferrer">Illustrated.dev</a></li><li><a href="https://keycode.info/" target="_blank" rel="external nofollow noopener noreferrer">JavaScript Event KeyCodes</a></li><li><a href="https://www.30secondsofcode.org/" target="_blank" rel="external nofollow noopener noreferrer">https://www.30secondsofcode.org/</a></li><li><a href="https://codequs.com/p/r1fCkfhQU/here-are-10-projects-you-can-do-to-build-with-vanilla-javascript/?fbclid=IwAR2I9Qpv_27gtzGG-lEUH7QF4AYIE4IVjnrYw9lC8RBlMu79Bw12JH4suuo" target="_blank" rel="external nofollow noopener noreferrer">Learn Startup - Build a successful business and change the world</a></li><li><a href="https://developer.mozilla.org/ko/docs/A_re-introduction_to_JavaScript" target="_blank" rel="external nofollow noopener noreferrer">JavaScript 재입문하기 (JS ​튜토리얼) | MDN</a></li></ol><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><ol><li><a href="https://flexboxfroggy.com/#ko" target="_blank" rel="external nofollow noopener noreferrer">Flexbox Froggy - A game for learning CSS flexbox</a></li><li><a href="https://leaverou.github.io/css3patterns/" target="_blank" rel="external nofollow noopener noreferrer">CSS3 Patterns Gallery</a></li><li><a href="https://www.mydevice.io/" target="_blank" rel="external nofollow noopener noreferrer">mydevice.io : web devices capabilities</a></li><li><a href="https://www.colorzilla.com/gradient-editor/" target="_blank" rel="external nofollow noopener noreferrer">https://www.colorzilla.com/gradient-editor/</a></li><li><a href="http://nthmaster.com/" target="_blank" rel="external nofollow noopener noreferrer">Mastering the :nth-child | CSS3 pseudo classes and :nth-child ranges</a></li><li><a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/" target="_blank" rel="external nofollow noopener noreferrer">A Complete Guide to Flexbox | CSS-Tricks</a></li><li><a href="https://webgradients.com/" target="_blank" rel="external nofollow noopener noreferrer">Fresh Background Gradients | WebGradients.com 💎</a></li><li><a href="https://www.the-art-of-web.com/css/timing-function/" target="_blank" rel="external nofollow noopener noreferrer">Transition Timing Functions &lt; CSS | The Art of Web</a></li><li><a href="https://cubic-bezier.com/#.17,.67,.83,.67" target="_blank" rel="external nofollow noopener noreferrer">cubic-bezier.com</a></li><li><a href="https://daneden.github.io/animate.css/" target="_blank" rel="external nofollow noopener noreferrer">Animate.css</a></li><li><a href="https://cssbattle.dev/" target="_blank" rel="external nofollow noopener noreferrer">CSSBattle</a></li><li><a href="https://pattle.github.io/simpsons-in-css/" target="_blank" rel="external nofollow noopener noreferrer">The Simpsons in CSS</a></li><li><a href="https://griddy.io/" target="_blank" rel="external nofollow noopener noreferrer">Griddy</a></li><li><a href="https://autoprefixer.github.io/" target="_blank" rel="external nofollow noopener noreferrer">Autoprefixer CSS online</a></li><li><a href="http://gridcalculator.dk/" target="_blank" rel="external nofollow noopener noreferrer">http://gridcalculator.dk/</a></li><li><a href="http://www.colors.commutercreative.com/grid/" target="_blank" rel="external nofollow noopener noreferrer">http://www.colors.commutercreative.com/grid/</a></li><li><a href="https://uigradients.com/#Socialive" target="_blank" rel="external nofollow noopener noreferrer">uiGradients - Beautiful colored gradients</a></li><li><a href="https://www.toptal.com/designers/subtlepatterns/" target="_blank" rel="external nofollow noopener noreferrer">Subtle Patterns | Free textures for your next web project</a></li><li><a href="https://ko.learnlayout.com/" target="_blank" rel="external nofollow noopener noreferrer">CSS 레이아웃을 배웁시다</a></li></ol><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><ol><li><a href="https://en.bem.info/" target="_blank" rel="external nofollow noopener noreferrer">BEM</a></li><li><a href="https://caniuse.com/" target="_blank" rel="external nofollow noopener noreferrer">Can I use… Support tables for HTML5, CSS3, etc</a></li></ol><h2 id="Tool"><a href="#Tool" class="headerlink" title="Tool"></a>Tool</h2><ol><li><a href="https://git-scm.com/book/ko/v2" target="_blank" rel="external nofollow noopener noreferrer">Git - Book</a></li><li><a href="https://ovenapp.io/" target="_blank" rel="external nofollow noopener noreferrer">Oven - HTML5-Powered Web/App Prototyping Tool</a></li><li><a href="https://www.conventionalcommits.org/ko/v1.0.0/" target="_blank" rel="external nofollow noopener noreferrer">Conventional Commits</a></li></ol><h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><ol><li><a href="https://velog.io/@velopert" target="_blank" rel="external nofollow noopener noreferrer">velopert (Minjun Kim) - velog</a></li></ol><h2 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h2><ol><li><a href="https://blog.gaerae.com/" target="_blank" rel="external nofollow noopener noreferrer">개발자스럽다</a></li><li><a href="https://www.44bits.io/ko" target="_blank" rel="external nofollow noopener noreferrer">44BITS 기술 블로그: 클라우드 컴퓨팅, 프로그래밍, 컨테이너, 리눅스</a></li><li><a href="https://d2.naver.com/home" target="_blank" rel="external nofollow noopener noreferrer">NAVER D2</a></li><li><a href="https://www.ridicorp.com/blog/" target="_blank" rel="external nofollow noopener noreferrer">Blog - 리디주식회사 RIDI Corporation</a></li><li><a href="https://meetup.toast.com/" target="_blank" rel="external nofollow noopener noreferrer">TOAST Meetup</a></li><li><a href="http://engineering.vcnc.co.kr/" target="_blank" rel="external nofollow noopener noreferrer">VCNC Engineering Blog</a></li><li><a href="https://woowabros.github.io/" target="_blank" rel="external nofollow noopener noreferrer">우아한형제들 기술 블로그</a></li><li><a href="https://blog.dramancompany.com/" target="_blank" rel="external nofollow noopener noreferrer">DRAMA&amp;COMPANY | DReam And MAke it happen</a></li><li><a href="https://tech.kakao.com/" target="_blank" rel="external nofollow noopener noreferrer">tech.kakao.com – 카카오는 사람과 사람, 사람과 기술을 한층 가깝게 연결함으로써, 어제보다 더 나은 세상을 만들어 갑니다.</a></li><li><a href="https://www.zerocho.com/" target="_blank" rel="external nofollow noopener noreferrer">ZeroCho Blog</a></li><li><a href="https://tutorialzine.com/2019/02/10-amazing-javascript-games" target="_blank" rel="external nofollow noopener noreferrer">10 Amazing JavaScript Games In Under 13kB of Code - Tutorialzine</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JavaScript&quot;&gt;&lt;a href=&quot;#JavaScript&quot; class=&quot;headerlink&quot; title=&quot;JavaScript&quot;&gt;&lt;/a&gt;JavaScript&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.mozil
      
    
    </summary>
    
    
      <category term="tip" scheme="http://codeameba.github.io/categories/tip/"/>
    
    
      <category term="tip" scheme="http://codeameba.github.io/tags/tip/"/>
    
      <category term="유용한사이트" scheme="http://codeameba.github.io/tags/%EC%9C%A0%EC%9A%A9%ED%95%9C%EC%82%AC%EC%9D%B4%ED%8A%B8/"/>
    
      <category term="북마크" scheme="http://codeameba.github.io/tags/%EB%B6%81%EB%A7%88%ED%81%AC/"/>
    
      <category term="즐겨찾기" scheme="http://codeameba.github.io/tags/%EC%A6%90%EA%B2%A8%EC%B0%BE%EA%B8%B0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript Fundamental 01(마지막 업데이트: 20.03.14)</title>
    <link href="http://codeameba.github.io/2020/03/14/programming/js-fundamental-01/"/>
    <id>http://codeameba.github.io/2020/03/14/programming/js-fundamental-01/</id>
    <published>2020-03-14T09:30:42.000Z</published>
    <updated>2020-03-24T10:24:17.189Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS-Study"><a href="#JS-Study" class="headerlink" title="JS Study"></a>JS Study</h1><ul><li>자바스크립트를 다시 공부하며 놓쳤던 개념들을 정리함.</li><li>교재: 모던 자바스크립트 입문(이소 히로시 지음)</li></ul><hr><h2 id="자바스크립트의-재탄생"><a href="#자바스크립트의-재탄생" class="headerlink" title="자바스크립트의 재탄생"></a>자바스크립트의 재탄생</h2><ul><li>자바스크립트는 기존의 다른 프로그래밍 언어들과 달리 불확실한 요소가 많아 외면 당했었다.</li><li>구글 지도에서 선보인 Ajax라는 비동기 통신 기술 덕분에 자바스크립트가 재탄생하며, 관심을 받게 되었다.</li><li>HTML5와 ES5의 등장은 자바스크립트에 날개를 달아주었다.</li></ul><h2 id="변수-variable"><a href="#변수-variable" class="headerlink" title="변수(variable)"></a>변수(variable)</h2><ul><li>변수는 값이 저장된 특정 메모리 영역을 가리키는 이름이다.</li><li>변수에 값을 할당하지 않고 선언만 하면 <code>undefined</code>가 담겨있다.</li><li><code>var</code>, <code>let</code>, <code>const</code> 등의 키워드 없이 선언된 변수는 전역변수로 취급한다.</li></ul><h2 id="변수-호이스팅-hoisting"><a href="#변수-호이스팅-hoisting" class="headerlink" title="변수 호이스팅(hoisting)"></a>변수 호이스팅(hoisting)</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><ul><li>프로그램 중간에서 변수를 선언하더라도 첫머리에 선언된 것처럼 작동하는데, 이것을 <strong>호이스팅</strong> 이라고 한다.</li><li>단, 호이스팅이 되는 것은 선언문 뿐이며, 자동으로 undefined로 초기화 된다.</li></ul><h2 id="getMonth-메서드에-1을-해야-하는-이유"><a href="#getMonth-메서드에-1을-해야-하는-이유" class="headerlink" title="getMonth() 메서드에 +1을 해야 하는 이유"></a>getMonth() 메서드에 +1을 해야 하는 이유</h2><ul><li><code>new Date()</code> 메서드 사용 시 <code>getMonth()</code> 는 0~11이기 때문에 <strong>+1</strong>을 해줘야 한다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`오늘은 <span class="subst">$&#123;now.getMonth()+<span class="number">1</span>&#125;</span> 월 <span class="subst">$&#123;now.getDate()&#125;</span> 일입니다.`</span>); <span class="comment">//오늘은 2 월 19 일입니다.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(now.getMonth()); <span class="comment">//1</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="함수-function-의-동작원리"><a href="#함수-function-의-동작원리" class="headerlink" title="함수(function)의 동작원리"></a>함수(function)의 동작원리</h2><ul><li>함수를 호출하며 인수(argument)를 전달하면, 함수 정의문의 인자(parameter)로 받아 실행 결과를 반환(return)한다.</li><li><strong>자판기의 이미지가 연상됨.</strong><blockquote><ol><li>특정 음료의 가격에 맞는 금액 투입(argument)</li><li>특정 음료의 버튼 누름(call)</li><li>투입된 금액과 호출된 음료의 값을 비교</li><li>가격이 맞으면 해당 음료 반환(return)</li></ol></blockquote></li></ul><h2 id="자바스크립트의-함수는-일급객체"><a href="#자바스크립트의-함수는-일급객체" class="headerlink" title="자바스크립트의 함수는 일급객체"></a>자바스크립트의 함수는 일급객체</h2><ul><li>함수를 값으로 쓸 수 있음. -&gt; 변수에 할당 가능</li><li>다른 함수의 인수(argument)로 전달 가능</li></ul><h2 id="함수-선언문의-호이스팅"><a href="#함수-선언문의-호이스팅" class="headerlink" title="함수 선언문의 호이스팅"></a>함수 선언문의 호이스팅</h2><ul><li>변수와 마찬가지로 호이스팅이 됨</li><li>아래와 같은 <strong>함수선언문</strong> 은 전체가 통째로 호이스팅 됨<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(square(<span class="number">5</span>)); <span class="comment">// 25</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수선언문</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>return이 없으면 undefined<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(square(<span class="number">5</span>)); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(square(<span class="number">3</span>)); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></li><li>변수와 마찬가지로 <strong>선언문</strong> 만 호이스팅이 되기 때문에, 아래와 같은 <strong>함수표현식</strong> 은 변수명만 호이스팅이 됨.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 기명 함수표현식</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="function"><span class="keyword">function</span> <span class="title">bb</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'bb'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 익명 함수표현식</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'c'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>함수의 호이스팅은 코드의 순차실행을 저해하고 예측을 어렵게 하기 때문에 되도록 <strong>함수표현식</strong> 의 사용을 권함</li></ul><h2 id="값의-전달-참조의-전달"><a href="#값의-전달-참조의-전달" class="headerlink" title="값의 전달, 참조의 전달"></a>값의 전달, 참조의 전달</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add1</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x = x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> b = add1(a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`a = <span class="subst">$&#123;a&#125;</span>, b = <span class="subst">$&#123;b&#125;</span>`</span>); <span class="comment">// a = 3, b = 4</span></span><br></pre></td></tr></table></figure><ul><li>위와 같이 인수로 원시값(primitive-type)을 전달하면, 해당 값 자체가 복사되어 전달된다. 이것을 <strong>값의 전달</strong> 또는 <strong>깊은 복사(deep copy)</strong> 라고 한다.</li><li>별도의 메모리 공간에 복사되는 것이기 때문에 변수 a와 인자 x는 별개의 값이며, x의 값이 바뀌더라도 a가 영향을 받지 않는다.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add1</span>(<span class="params">p</span>) </span>&#123;</span><br><span class="line">  p.x = p.x + <span class="number">1</span>;</span><br><span class="line">  p.y = p.y + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">x</span>:<span class="number">3</span>, <span class="attr">y</span>:<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> b = add1(a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a, b); <span class="comment">// &#123; x: 4, y: 5 &#125; &#123; x: 4, y: 5 &#125;</span></span><br></pre></td></tr></table></figure><ul><li>반면에 인수로 객체(object-type)을 전달했을 때에는 참조(reference)가 전달되는 것으로 이를 <strong>참조 전달</strong> 또는 <strong>얕은 복사(shallow copy)</strong> 라고 한다.</li><li>하나의 메모리 공간에 있는 객체를 각기 다른 곳에서 가리키고 있다는 이미지로 이해할 수 있으며, 따라서 p의 값이 바뀌자 a의 값도 바뀐 것이다.</li></ul><h2 id="스코프"><a href="#스코프" class="headerlink" title="스코프"></a>스코프</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">'global'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="string">'local'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// global</span></span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f();</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// ReferenceError: b is not defined</span></span><br></pre></td></tr></table></figure><ul><li>위와 같이 함수 내부의 변수가 출력되지 않는 이유는 스코프(scope) 때문이다.</li><li>기본적으로 <strong>내부에서는 외부를 볼 수 있지만, 외부에서는 내부를 볼 수 없다</strong> 는 개념으로 이해할 수 있다.</li><li>코드가 작성되는 시점에 구문만으로 정해지는 스코프를 어휘적 스코프(lexical scope)라고 하며, 코드가 실행되는 와중에 정해지는 스코프를 동적 스코프(dynamic scope)라고 한다. <strong>자바스크립트는 lexical scope를 따른다</strong></li><li>스코프가 존재하는 가장 큰 이유는 식별자(identifier)의 충돌을 막기 위함이다.</li></ul><h2 id="메서드-method"><a href="#메서드-method" class="headerlink" title="메서드(method)"></a>메서드(method)</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> circle = &#123;</span><br><span class="line">  center: &#123; <span class="attr">x</span>:<span class="number">1.0</span>, <span class="attr">y</span>:<span class="number">2.0</span> &#125;, <span class="comment">// 원의 중심</span></span><br><span class="line">  radius: <span class="number">2.5</span>, <span class="comment">// 원의 반지름</span></span><br><span class="line">  area: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 원의 넓이를 구하는 메서드</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.PI * <span class="keyword">this</span>.radius * <span class="keyword">this</span>.radius;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">circle.translate = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123; <span class="comment">// 새로운 메서드를 추가하여 원을 이동</span></span><br><span class="line">  <span class="keyword">this</span>.center.x = <span class="keyword">this</span>.center.x + a;</span><br><span class="line">  <span class="keyword">this</span>.center.y = <span class="keyword">this</span>.center.y + b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">circle.translate(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">circle.center; <span class="comment">// &#123;x: 2, y: 4&#125;</span></span><br></pre></td></tr></table></figure><ul><li>자바스크립트에서는 객체 내부의 데이터는 모두 프로퍼티(property)이며, 프로퍼티가 함수를 값으로 가질 때, 일반 프로퍼티와 구분하기 위해 <strong>메서드(method)</strong> 라고 칭한다.</li><li>일반적으로 메서드는, 메서드가 속한 객체의 내부 데이터(프로퍼티 값) 상태를 바꾸는 용도로 사용한다.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JS-Study&quot;&gt;&lt;a href=&quot;#JS-Study&quot; class=&quot;headerlink&quot; title=&quot;JS Study&quot;&gt;&lt;/a&gt;JS Study&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;자바스크립트를 다시 공부하며 놓쳤던 개념들을 정리함.&lt;/li&gt;
&lt;li&gt;교
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://codeameba.github.io/categories/JavaScript/"/>
    
    
      <category term="til" scheme="http://codeameba.github.io/tags/til/"/>
    
      <category term="TIL" scheme="http://codeameba.github.io/tags/TIL/"/>
    
      <category term="Today I Learned" scheme="http://codeameba.github.io/tags/Today-I-Learned/"/>
    
      <category term="오늘배운것들" scheme="http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"/>
    
      <category term="자바스크립트" scheme="http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"/>
    
      <category term="Javascript" scheme="http://codeameba.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>불안의 이유</title>
    <link href="http://codeameba.github.io/2020/02/20/blog/do-it-now/"/>
    <id>http://codeameba.github.io/2020/02/20/blog/do-it-now/</id>
    <published>2020-02-20T09:05:42.000Z</published>
    <updated>2020-02-20T10:00:21.772Z</updated>
    
    <content type="html"><![CDATA[<p>대개의 경우 불안을 느끼는 이유는 부족함에 있다. 공부가 부족하여 아는 게 없을 때, 돈이 부족하여 할부금을 낼 수 없을 때, 시간이 부족하여 일을 마무리 할 수 없을 때 등.</p><p>그런데 재미있는 것은, ‘과거의 나’는 ‘지금의 나’의 불안을 예상 가능했다는 것이다. 그 말은 곧, 대부분의 불안은 ‘예측 가능한 미래보다 현재의 귀찮음이 앞설 때’ 이미 정해진다는 것이다.</p><p>불안이 싫다면, 지금 움직이자.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;대개의 경우 불안을 느끼는 이유는 부족함에 있다. 공부가 부족하여 아는 게 없을 때, 돈이 부족하여 할부금을 낼 수 없을 때, 시간이 부족하여 일을 마무리 할 수 없을 때 등.&lt;/p&gt;
&lt;p&gt;그런데 재미있는 것은, ‘과거의 나’는 ‘지금의 나’의 
      
    
    </summary>
    
    
      <category term="생각정리" scheme="http://codeameba.github.io/categories/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/"/>
    
    
      <category term="블로그" scheme="http://codeameba.github.io/tags/%EB%B8%94%EB%A1%9C%EA%B7%B8/"/>
    
      <category term="생각정리" scheme="http://codeameba.github.io/tags/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/"/>
    
      <category term="blog" scheme="http://codeameba.github.io/tags/blog/"/>
    
      <category term="불안의이유" scheme="http://codeameba.github.io/tags/%EB%B6%88%EC%95%88%EC%9D%98%EC%9D%B4%EC%9C%A0/"/>
    
  </entry>
  
  <entry>
    <title>[TIL] list와 tuple의 차이 그리고 dictionary</title>
    <link href="http://codeameba.github.io/2020/02/18/programming/python-til-01/"/>
    <id>http://codeameba.github.io/2020/02/18/programming/python-til-01/</id>
    <published>2020-02-18T04:40:42.000Z</published>
    <updated>2020-02-19T13:00:43.752Z</updated>
    
    <content type="html"><![CDATA[<h2 id="리스트-list"><a href="#리스트-list" class="headerlink" title="리스트(list)"></a>리스트(list)</h2><ul><li>리스트는 재할당(assignment)이 가능</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">x[<span class="number">0</span>] = <span class="number">5</span></span><br><span class="line">print(x) <span class="comment">#[5, 2, 3]</span></span><br></pre></td></tr></table></figure><h2 id="튜플-tuple"><a href="#튜플-tuple" class="headerlink" title="튜플(tuple)"></a>튜플(tuple)</h2><ul><li>튜플은 재할당 불가능</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">x[<span class="number">0</span>] = <span class="number">5</span></span><br><span class="line">print(x) <span class="comment">#TypeError: 'tuple' object does not support item assignment</span></span><br></pre></td></tr></table></figure><h2 id="딕셔너리-dictionary"><a href="#딕셔너리-dictionary" class="headerlink" title="딕셔너리(dictionary)"></a>딕셔너리(dictionary)</h2><ul><li><code>key : value</code> 한 쌍으로 이루어진 자료구조</li><li>자바스크립트의 객체와 유사</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = &#123;</span><br><span class="line">    “hello”: “world”,</span><br><span class="line">    “beer”: “good”,</span><br><span class="line">    <span class="number">3</span>: “what”</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(x[“beer”]) <span class="comment">#good</span></span><br><span class="line">print(x[<span class="number">3</span>]) <span class="comment">#what</span></span><br></pre></td></tr></table></figure><h2 id="리스트와-딕셔너리의-활용"><a href="#리스트와-딕셔너리의-활용" class="headerlink" title="리스트와 딕셔너리의 활용"></a>리스트와 딕셔너리의 활용</h2><ul><li>리스트에서 중복된 요소들을 딕셔너리로 정리</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fruit = [“사과”, “사과”, “바나나”, “바나나”, “딸기”, “키위”, “복숭아”, “복숭아”, “복숭아”]</span><br><span class="line"></span><br><span class="line">d = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> fruit:</span><br><span class="line">    <span class="keyword">if</span> f <span class="keyword">in</span> d:</span><br><span class="line">        d[f] = d[f] + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        d[f] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">print(d)</span><br><span class="line"><span class="comment">#&#123;'사과': 2, '바나나': 2, '딸기': 1, '키위': 1, '복숭아': 3&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;리스트-list&quot;&gt;&lt;a href=&quot;#리스트-list&quot; class=&quot;headerlink&quot; title=&quot;리스트(list)&quot;&gt;&lt;/a&gt;리스트(list)&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;리스트는 재할당(assignment)이 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;f
      
    
    </summary>
    
    
      <category term="Python" scheme="http://codeameba.github.io/categories/Python/"/>
    
    
      <category term="til" scheme="http://codeameba.github.io/tags/til/"/>
    
      <category term="TIL" scheme="http://codeameba.github.io/tags/TIL/"/>
    
      <category term="Today I Learned" scheme="http://codeameba.github.io/tags/Today-I-Learned/"/>
    
      <category term="오늘배운것들" scheme="http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"/>
    
      <category term="python" scheme="http://codeameba.github.io/tags/python/"/>
    
      <category term="파이썬" scheme="http://codeameba.github.io/tags/%ED%8C%8C%EC%9D%B4%EC%8D%AC/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 블로그에 디스커스(Disqus) 코드 추가하여 댓글 기능 넣기</title>
    <link href="http://codeameba.github.io/2020/02/15/blog/disqus-setting/"/>
    <id>http://codeameba.github.io/2020/02/15/blog/disqus-setting/</id>
    <published>2020-02-14T16:00:42.000Z</published>
    <updated>2020-02-20T22:13:53.702Z</updated>
    
    <content type="html"><![CDATA[<h2 id="디스커스-Disqus"><a href="#디스커스-Disqus" class="headerlink" title="디스커스(Disqus)"></a>디스커스(Disqus)</h2><p>네이버 블로그나 티스토리 같은 블로그 서비스에는 자체적인 댓글 기능이 있지만, Hexo, Jekyll, Gatsby 등의 정적 사이트로 블로그를 만든 경우에는 손수 댓글 기능을 추가해야만 한다. 내 경우에는 Hexo를 쓰고 있다.</p><p>물론, 테마에 따라서는 yml에 디스커스 ID를 추가하는 것만으로도 손쉽게 추가할 수도 있지만, 내가 쓰는 테마에는 없었기에 약간의 시행착오가 필요했다. 그리고, 마침내 코드를 추가하는 방식으로 디스커스 댓글 기능을 사용할 수 있게 되었고, 만약 나처럼 테마에 디스커스 항목이 없어서 당황할 사람들을 위해 기록을 남겨둔다.<br>뭐, 미래의 내가 다시 보고 따라해야 할 수도 있고…</p><h2 id="디스커스-코드-구하러-가기"><a href="#디스커스-코드-구하러-가기" class="headerlink" title="디스커스 코드 구하러 가기"></a>디스커스 코드 구하러 가기</h2><p>가입은 했다 치고, 디스커스에 접속한다. 그리고, GET STARTED를 클릭한다.<br><img src="/images/disqus01.png"></p><p>아래와 같은 페이지 넘어가게 되는데, 아이콘만 보더라도 댓글 기능처럼 보이는 위의 것을 선택한다.<br><img src="/images/disqus02.png"></p><p>그리고, 홈이 나오면, 우측 상단의 설정 메뉴에서 Admin을 눌러 이동한다. 이어서 나오는 페이지에서는 Installing Disqus를 클릭한다.<br><img src="/images/disqus03.png"><br><img src="/images/disqus04.png"></p><p>‘어라? 뭔가 잘못 찾아온 거 아닌가’ 싶을 것이다. 이어진 페이지에서 등장하는 아이콘들은 디스커스와 모종의 관계를 맺고 간단히 댓글 기능을 추가할 수 있는 자본의 노예들이다. 당황하지 말고 스크롤을 내리자.<br>그리고, ‘난 너희랑 달라~’ 라는 생각을 하며 당당하게 Universal Code를 얻으러 간다.<br><img src="/images/disqus05.png"></p><p>이것이 디스커스 댓글 기능이 담긴 코드다.<br><img src="/images/disqus06.png"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"disqus_thread"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">/**</span><br><span class="line">*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.</span><br><span class="line"><span class="actionscript">*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https:<span class="comment">//disqus.com/admin/universalcode/#configuration-variables*/</span></span></span><br><span class="line">/*</span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> disqus_config = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">this</span>.page.url = PAGE_URL;  <span class="comment">// Replace PAGE_URL with your page's canonical URL variable</span></span></span><br><span class="line"><span class="actionscript"><span class="keyword">this</span>.page.identifier = PAGE_IDENTIFIER; <span class="comment">// Replace PAGE_IDENTIFIER with your page's unique identifier variable</span></span></span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line"><span class="actionscript">(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123; <span class="comment">// DON'T EDIT BELOW THIS LINE</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> d = <span class="built_in">document</span>, s = d.createElement(<span class="string">'script'</span>);</span></span><br><span class="line"><span class="actionscript">s.src = <span class="string">'https://본인블로그URL/embed.js'</span>;</span></span><br><span class="line"><span class="javascript">s.setAttribute(<span class="string">'data-timestamp'</span>, +<span class="keyword">new</span> <span class="built_in">Date</span>());</span></span><br><span class="line">(d.head || d.body).appendChild(s);</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">noscript</span>&gt;</span>Please enable JavaScript to view the <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://disqus.com/?ref_noscript"</span>&gt;</span>comments powered by Disqus.<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">noscript</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="디스커스-코드-추가하기"><a href="#디스커스-코드-추가하기" class="headerlink" title="디스커스 코드 추가하기"></a>디스커스 코드 추가하기</h2><p>코드는 구했으니 이제 정적 페이지 소스 코드에 추가해야 한다.<br>내 경우에는 블로그를 구성하는 테마의 확장자가 ejs로 되어 있으며, 파일명을 통해 어느 페이지와 파트를 구성하는 지 대략 확인 가능하다.<br><img src="/images/disqus07.png"></p><p>댓글의 위치가 가장 하단이라고 해서 자칫 footer.ejs에 코드를 추가하는 불상사는 없길 바란다. 메인 페이지부터 컨텍 페이지까지 댓글이 달리게 되는 수가 있다. 물론, 그것이 바라던 바라면 그렇게 해도 무방하다.<br>하지만, 나는 포스트에만 댓글이 추가되길 바라기 떄문에 pose.ejs에 코드를 추가했다.<br><img src="/images/disqus08.png"></p><h2 id="디스커스-스타일-변경"><a href="#디스커스-스타일-변경" class="headerlink" title="디스커스 스타일 변경"></a>디스커스 스타일 변경</h2><p>아마 디스커스 코드만 추가하고 잘 붙었나~ 확인해보면, 아래와 같이 너비가 100%일 것이다.<br><img src="/images/disqus09.png"></p><p>이대로 마음에 든다면 그냥 써도 되겠지만, 내 포스트는 모두 최대 너비를 780px로 통일했기 때문에 조정이 필요했다. 따라서 블로그 테마의 CSS를 조금 만져야 했다. 이 또한 경우에 따라 다를 수 있겠지만, 대개의 경우 나처럼 styl(스타일러스)로 되어 있을 것이며, 만약 아니더라도 사용상의 차이는 크지 않을 것이다.<br><img src="/images/disqus10.png"></p><p>이 중에서 건드려야 할 것은 custom.styl이다. 디스커스 코드의 ID는 disqus_thread이며, 아래와 같이 스타일을 변경하였고,</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#disqus_thread</span> &#123;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">780px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">50px</span> auto;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>결과적으로 지금의 형태가 되었다.<br><img src="/images/disqus11.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;디스커스-Disqus&quot;&gt;&lt;a href=&quot;#디스커스-Disqus&quot; class=&quot;headerlink&quot; title=&quot;디스커스(Disqus)&quot;&gt;&lt;/a&gt;디스커스(Disqus)&lt;/h2&gt;&lt;p&gt;네이버 블로그나 티스토리 같은 블로그 서비스에는 자체적인 
      
    
    </summary>
    
    
      <category term="tip" scheme="http://codeameba.github.io/categories/tip/"/>
    
    
      <category term="블로그" scheme="http://codeameba.github.io/tags/%EB%B8%94%EB%A1%9C%EA%B7%B8/"/>
    
      <category term="blog" scheme="http://codeameba.github.io/tags/blog/"/>
    
      <category term="댓글기능구현" scheme="http://codeameba.github.io/tags/%EB%8C%93%EA%B8%80%EA%B8%B0%EB%8A%A5%EA%B5%AC%ED%98%84/"/>
    
      <category term="디스커스" scheme="http://codeameba.github.io/tags/%EB%94%94%EC%8A%A4%EC%BB%A4%EC%8A%A4/"/>
    
      <category term="disqus" scheme="http://codeameba.github.io/tags/disqus/"/>
    
      <category term="hexo" scheme="http://codeameba.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>2020년은 황금시대일지도 모른다</title>
    <link href="http://codeameba.github.io/2020/02/06/blog/golden-age/"/>
    <id>http://codeameba.github.io/2020/02/06/blog/golden-age/</id>
    <published>2020-02-06T08:41:42.000Z</published>
    <updated>2020-02-06T08:53:13.697Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/midnight.png" alt="미드나잇 인 파리 캡쳐"><p>과거를 동경하는 문화는 어느 시대에나 있었을 것이다. 지금 80-90년대의 레트로 문화가 성행하듯이 말이다.</p><p>르네상스, 황금시대 등의 이름 역시 당대에 붙여진 이름이 아닌, 후대의 사람들이 과거를 동경하며 불렀을 이름이다.</p><p>현재가 아무리 최악의 시대라고 불리며, 살아가기에 녹록지 않긴 하지만, 먼 훗날 누군가는 2020년을 황금시대라며 동경할지도 모를 일이다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/images/midnight.png&quot; alt=&quot;미드나잇 인 파리 캡쳐&quot;&gt;

&lt;p&gt;과거를 동경하는 문화는 어느 시대에나 있었을 것이다. 지금 80-90년대의 레트로 문화가 성행하듯이 말이다.&lt;/p&gt;
&lt;p&gt;르네상스, 황금시대 등의 이름
      
    
    </summary>
    
    
      <category term="생각정리" scheme="http://codeameba.github.io/categories/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/"/>
    
    
      <category term="블로그" scheme="http://codeameba.github.io/tags/%EB%B8%94%EB%A1%9C%EA%B7%B8/"/>
    
      <category term="생각정리" scheme="http://codeameba.github.io/tags/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/"/>
    
      <category term="blog" scheme="http://codeameba.github.io/tags/blog/"/>
    
      <category term="황금시대" scheme="http://codeameba.github.io/tags/%ED%99%A9%EA%B8%88%EC%8B%9C%EB%8C%80/"/>
    
      <category term="미드나잇인파리" scheme="http://codeameba.github.io/tags/%EB%AF%B8%EB%93%9C%EB%82%98%EC%9E%87%EC%9D%B8%ED%8C%8C%EB%A6%AC/"/>
    
  </entry>
  
  <entry>
    <title>허니와 클로버</title>
    <link href="http://codeameba.github.io/2020/02/05/blog/honey-and-clovar/"/>
    <id>http://codeameba.github.io/2020/02/05/blog/honey-and-clovar/</id>
    <published>2020-02-05T09:05:42.000Z</published>
    <updated>2020-02-06T08:51:58.272Z</updated>
    
    <content type="html"><![CDATA[  <img src="/images/honey01.png" alt="honey and clovar">  <img src="/images/honey02.png" alt="honey and clovar">  <img src="/images/honey03.png" alt="honey and clovar"><p>20대 초반에 우연히 보게 된 허니와 클로버는 당시 혼란스러웠던 내 마음을 대변해주는 것 같았고, 10년이 훌쩍 지난 지금까지도 마음이 꺾일 것 같을 때면 다시 정주행을 하며 의욕을 재충전하는 나의 최애 콘텐츠로 자리 잡았다.</p><p>또, 수차례 정주행 하며 알게 된 또 하나의 사실은, 내 나이와 상황에 따라 감정이입을 하게 되는 캐릭터가 달라진다는 점이다.</p><p>처음에는 진로와 자아에 대해 고민하며 뛰어난 재능 앞에 열등감을 느끼는 타케모토에게서 나를 봤다면, 다음에는 얽히고설킨 인간관계 사이에서 망설이는 마야마에게서, 그리고 지금은 어른이 되어서도 여전히 과거의 고민으로부터 벗어나지 못하는 하나모토 교수에게서 내 모습이 보인다.</p><p>그리고 아무리 마음에 와닿는 장면이라도 담담하게 볼 수 있던 예전과는 달리, 몇 번씩 울컥하게 된다. 이것은 내가 감정적으로 성숙했다는 긍정적인 의미로 해석하면 될까.</p>]]></content>
    
    <summary type="html">
    
      
      
          &lt;img src=&quot;/images/honey01.png&quot; alt=&quot;honey and clovar&quot;&gt;
  &lt;img src=&quot;/images/honey02.png&quot; alt=&quot;honey and clovar&quot;&gt;
  &lt;img src=&quot;/images/honey0
      
    
    </summary>
    
    
      <category term="생각정리" scheme="http://codeameba.github.io/categories/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/"/>
    
    
      <category term="블로그" scheme="http://codeameba.github.io/tags/%EB%B8%94%EB%A1%9C%EA%B7%B8/"/>
    
      <category term="생각정리" scheme="http://codeameba.github.io/tags/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/"/>
    
      <category term="blog" scheme="http://codeameba.github.io/tags/blog/"/>
    
      <category term="허니와클로버" scheme="http://codeameba.github.io/tags/%ED%97%88%EB%8B%88%EC%99%80%ED%81%B4%EB%A1%9C%EB%B2%84/"/>
    
  </entry>
  
  <entry>
    <title>종이책으로의 회귀</title>
    <link href="http://codeameba.github.io/2020/02/04/blog/return-to-text/"/>
    <id>http://codeameba.github.io/2020/02/04/blog/return-to-text/</id>
    <published>2020-02-04T05:43:42.000Z</published>
    <updated>2020-02-05T09:10:11.882Z</updated>
    
    <content type="html"><![CDATA[<img src="https://images.unsplash.com/photo-1513475382585-d06e58bcb0e0?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1950&q=80" alt="select a book"><p>콘텐츠의 포맷에 따라 여백의 비중이 다르다. 여기서 말하는 여백이란, 독자가 전•후 사정과 배경을 상상할 수 있는 여지를 뜻한다.</p><p>예를 들어 텍스트 콘텐츠의 여백이 50% 라면, 이미지 콘텐츠는 30%, 동영상 콘텐츠는 10% 쯤 될 것이다. 그런 점에서 동영상 콘텐츠의 이용률이 월등한 지금의 세대는 본인의 상상으로 채울 수 있는 여지가 지극히 적을 수밖에 없다.</p><p>사람은 기본적으로 상상을 기반으로 자신만의 세계관을 구축하고자 하는 욕구가 있으며, 이들은 결국 동영상 콘텐츠가 채워주지 못하는 여백에 대한 갈증을 채우기 위해 텍스트 콘텐츠를 찾게 될 것이다.</p><p>나아가 종이책에서만 느낄 수 있는 온기와 질감을 동경하여 종이책으로 회귀하게 될 것이다.</p><p>이것은, 종이책을 사랑하는 사람의 예측 혹은 바람이다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;https://images.unsplash.com/photo-1513475382585-d06e58bcb0e0?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1950&amp;
      
    
    </summary>
    
    
      <category term="생각정리" scheme="http://codeameba.github.io/categories/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/"/>
    
    
      <category term="블로그" scheme="http://codeameba.github.io/tags/%EB%B8%94%EB%A1%9C%EA%B7%B8/"/>
    
      <category term="생각정리" scheme="http://codeameba.github.io/tags/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/"/>
    
      <category term="blog" scheme="http://codeameba.github.io/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>내가 생각하는 좋은 콘텐츠</title>
    <link href="http://codeameba.github.io/2020/02/03/blog/what-is-good-content/"/>
    <id>http://codeameba.github.io/2020/02/03/blog/what-is-good-content/</id>
    <published>2020-02-03T07:19:42.000Z</published>
    <updated>2020-02-03T07:49:23.254Z</updated>
    
    <content type="html"><![CDATA[<img src="https://images.unsplash.com/photo-1513185041617-8ab03f83d6c5?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1950&q=80" alt="many books"><h3 id="첫째-조금이라도-나은-사람이-되었다고-스스로-느낄-수-있는-콘텐츠가-좋은-콘텐츠의-기준이다"><a href="#첫째-조금이라도-나은-사람이-되었다고-스스로-느낄-수-있는-콘텐츠가-좋은-콘텐츠의-기준이다" class="headerlink" title="첫째, 조금이라도 나은 사람이 되었다고 스스로 느낄 수 있는 콘텐츠가 좋은 콘텐츠의 기준이다."></a>첫째, 조금이라도 나은 사람이 되었다고 스스로 느낄 수 있는 콘텐츠가 좋은 콘텐츠의 기준이다.</h3><p> 모든 사람은 기본적으로 어제보다 오늘, 오늘보다 내일 더 나아지고자 하는 마음 즉, 향상심을 갖고 있다고 생각한다. 따라서 향상심을 충족시킬 수 있어야 좋은 콘텐츠다. 여기서 의미하는 향상심은 비단 지식적 측면만이 아닌, 감정적, 정신적 측면까지 포괄하는 개념이다.</p><h3 id="둘째-저자의-경험에서-비롯된-스토리가-더해진-콘텐츠는-더욱-좋은-콘텐츠다"><a href="#둘째-저자의-경험에서-비롯된-스토리가-더해진-콘텐츠는-더욱-좋은-콘텐츠다" class="headerlink" title="둘째, 저자의 경험에서 비롯된 스토리가 더해진 콘텐츠는 더욱 좋은 콘텐츠다."></a>둘째, 저자의 경험에서 비롯된 스토리가 더해진 콘텐츠는 더욱 좋은 콘텐츠다.</h3><p> 똑같은 인사이트를 전달하려는 콘텐츠라고 해도 콘텐츠 제작자의 경험을 바탕으로 한 스토리가 더해진 콘텐츠가 진정성 있는 콘텐츠이며, 그런 콘텐츠는 독자의 기억에 오랫동안 긍정적으로 남을 수 있다고 생각한다.</p><h3 id="셋째-기존에-몰랐던-새로운-시각까지-깨닫게-해주는-콘텐츠는-가장-좋은-콘텐츠다"><a href="#셋째-기존에-몰랐던-새로운-시각까지-깨닫게-해주는-콘텐츠는-가장-좋은-콘텐츠다" class="headerlink" title="셋째, 기존에 몰랐던 새로운 시각까지 깨닫게 해주는 콘텐츠는 가장 좋은 콘텐츠다."></a>셋째, 기존에 몰랐던 새로운 시각까지 깨닫게 해주는 콘텐츠는 가장 좋은 콘텐츠다.</h3><p> 의도적으로 취향에 반하는 콘텐츠를 접하지 않는 이상, 사람들은 비슷한 성격의 콘텐츠를 이용하려는 관성이 있고, 콘텐츠 플랫폼의 추천 알고리즘은 이러한 관성에 더욱 힘을 싣고 있다. 물론, 자신만의 취향을 구축하고, 확고히 하는 것도 중요하지만, 취향에 갇혀 다른 시각과 경험의 기회를 놓치는 것은 결과적으로 안타까운 일이다.</p><p>만약, 세 가지 기준에 모두 만족하는 콘텐츠라면, 독자에게 ‘유쾌한 터닝포인트’를 선사할 수 있다고 생각한다. 개인적 경험을 바탕으로 좋은 콘텐츠라고 느꼈던 것들에는, 무라카미 하루키의 에세이 ‘이렇게 작지만 확실한 행복’, 벤 스틸러의 영화 ‘월터의 상상은 현실이 된다’, 우미노 치카의 만화 ‘허니와 클로버’가 있다. 이러한 콘텐츠들을 접했을 때, 고양감과 진정성을 느꼈으며, 새로운 시각으로 자신과 세상을 바라볼 수 있었다.</p><p>하지만 아무리 좋은 콘텐츠라도 독자에게 닿을 수 없으면, 가치를 인정받을 수 없다. 따라서 콘텐츠를 만드는 사람은, <strong>‘좋은 콘텐츠를, 필요로 하는 독자에게 보기 좋은 형태로 제시할 수 있어야’</strong> 한다고 생각한다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;https://images.unsplash.com/photo-1513185041617-8ab03f83d6c5?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1950&amp;
      
    
    </summary>
    
    
      <category term="생각정리" scheme="http://codeameba.github.io/categories/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/"/>
    
    
      <category term="블로그" scheme="http://codeameba.github.io/tags/%EB%B8%94%EB%A1%9C%EA%B7%B8/"/>
    
      <category term="생각정리" scheme="http://codeameba.github.io/tags/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/"/>
    
      <category term="blog" scheme="http://codeameba.github.io/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>오류의 이해</title>
    <link href="http://codeameba.github.io/2020/02/01/blog/understanding-error/"/>
    <id>http://codeameba.github.io/2020/02/01/blog/understanding-error/</id>
    <published>2020-02-01T11:50:42.000Z</published>
    <updated>2020-02-03T07:54:34.369Z</updated>
    
    <content type="html"><![CDATA[<img src="https://images.unsplash.com/photo-1484417894907-623942c8ee29?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=2089&q=80" alt="coding"><p>프로그래밍을 배울 때 들었던 말 중 가장 기억에 남는 말이, <strong>‘오류를 이해하라’</strong> 는 말이었다. 코딩을 하다 보면 다양한 형태의 오류가 다양한 상황에서 등장하는데, 구글에 복붙하여 찾아보고, 대강 수정하여 넘어가다 보면 동일한 오류가 다시 등장했을 때 대처를 못 하기 때문이다.</p><p>따라서 오류의 원인과 결과를 충분히 이해하고 넘어가야 한다는 것이다. 조금 더 부연설명을 하자면, 동일한 상황을 조성하여 의도적으로 동일한 오류를 발생시킬 수 있을 정도의 수준을 진정한 의미의 ‘오류의 이해’라고 할 수 있다.</p><p>그리고, ‘오류의 이해’가 필요한 곳은 비단 프로그래밍에만 국한된 것이 아니라고 생각한다. 삶을 살아가면서도 ‘나의 진짜 관심분야’, ‘다양한 상황에서의 인간관계’ 등 가설과 검증을 통한 ‘오류의 이해’가 유의미한 경우들이 있다.</p><p>물론, 극단적 가설에 의한 테스팅은 조금 곤란할지도…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;https://images.unsplash.com/photo-1484417894907-623942c8ee29?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=2089&amp;
      
    
    </summary>
    
    
      <category term="생각정리" scheme="http://codeameba.github.io/categories/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/"/>
    
    
      <category term="블로그" scheme="http://codeameba.github.io/tags/%EB%B8%94%EB%A1%9C%EA%B7%B8/"/>
    
      <category term="생각정리" scheme="http://codeameba.github.io/tags/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/"/>
    
      <category term="blog" scheme="http://codeameba.github.io/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>취향이 사람을 만든다</title>
    <link href="http://codeameba.github.io/2019/12/23/blog/taste-maketh-man/"/>
    <id>http://codeameba.github.io/2019/12/23/blog/taste-maketh-man/</id>
    <published>2019-12-23T05:43:42.000Z</published>
    <updated>2020-02-05T09:02:05.909Z</updated>
    
    <content type="html"><![CDATA[<p>남들은 어떤지 모르겠지만 내 경우에는 서로의 취향을 하나씩 던지며 대화가 이어진다. 그것이 내 취향과 겹치면 공통된 이야기가 생겨서 좋고, 겹치지 않으면 내가 모르던 것을 알게 되니 좋다. 그래서 취향이 분명하지 않은 사람과 가까운 관계로 발전하기란 썩 쉽지 않다.</p><p>즐겨 듣는 음악, 좋아하는 작가, 사용하는 카메라의 브랜드, 혼자 시간을 보내는 방법 등 취향을 드러낼만한 것들은 참 많다. 꼭 고상한 것일 필요는 없다. 하다 못해 점심 메뉴를 고르는 확고한 기준이라도 좋다. 뭐라도 좋으니 “난 이게 좋고 저건 싫다”라고 분명하게 말할 수 있는 영역을 지닌 사람이 좋다.</p><img src="https://images.unsplash.com/photo-1541443517255-9e9aa2962f14?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1950&q=80" alt="film"><p>취향은 곧 취미로 연결되고, 취미에 들이는 시간만큼 부정적인 생각에 사로잡힐 기회는 줄어든다. 물론 혼자 사색을 하는 시간도 소중하지만, 취향이 없는 사색은 알맹이 없는 몽상이 되기 쉽다. 그리고 그렇게 나이 드는 것은 너무나도 쓸쓸하지 않겠는가.</p><p>물론, 취향을 유지하기가 썩 쉽지 않은 시대라는 것은 잘 알고있다. 단지 취향일 뿐인데 손가락질을 받기도 하고, 적지 않은 돈이 들기도 하며, 때로는 이렇게까지 할 가치가 있는 건가… 싶을 때도 있다.</p><p>그럼에도 불구하고, 그런 시대이기에 더욱, 내 취향을 공고히 해야 할 필요가 있다. 취향은 곧, 나를 이루는 필수요소이며, 취향이 없이는 타인과 다른 ‘나’를 온전히 유지할 수도 없다.</p><img src="https://images.unsplash.com/photo-1486092573896-31a373bf1aad?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1950&q=80" alt="on my way">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;남들은 어떤지 모르겠지만 내 경우에는 서로의 취향을 하나씩 던지며 대화가 이어진다. 그것이 내 취향과 겹치면 공통된 이야기가 생겨서 좋고, 겹치지 않으면 내가 모르던 것을 알게 되니 좋다. 그래서 취향이 분명하지 않은 사람과 가까운 관계로 발전하
      
    
    </summary>
    
    
      <category term="생각정리" scheme="http://codeameba.github.io/categories/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/"/>
    
    
      <category term="블로그" scheme="http://codeameba.github.io/tags/%EB%B8%94%EB%A1%9C%EA%B7%B8/"/>
    
      <category term="생각정리" scheme="http://codeameba.github.io/tags/%EC%83%9D%EA%B0%81%EC%A0%95%EB%A6%AC/"/>
    
      <category term="blog" scheme="http://codeameba.github.io/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>[Book Review] 마켓 4.0 : 소비자를 소비자로만 보면 안 되는 시대</title>
    <link href="http://codeameba.github.io/2019/11/15/blog/book-review-market-4/"/>
    <id>http://codeameba.github.io/2019/11/15/blog/book-review-market-4/</id>
    <published>2019-11-14T16:00:42.000Z</published>
    <updated>2020-02-06T08:51:44.821Z</updated>
    
    <content type="html"><![CDATA[<div style="clear:left;text-align:left;"><div style="float:left;margin:0 15px 5px 0;"><a href="/Product/Goods/35952025" style="display:inline-block;overflow:hidden;border:solid 1px #ccc;" target="_blank"><img style="margin:-1px;vertical-align:top;" src="http://image.yes24.com/goods/35952025/M" border="0" alt="필립 코틀러의 마켓 4.0 "></a></div><div><p style="line-height:1.2em;color:#333;font-size:14px;font-weight:bold;">필립 코틀러의 마켓 4.0 </p><p style="margin-top:5px;line-height:1.2em;color:#666;"><a href="http://www.yes24.com/SearchCorner/Result?domain=ALL&author_yn=Y&query=&auth_no=114522" target="_blank" rel="external nofollow noopener noreferrer">필립 코틀러</a> 저</p><p style="margin-top:14px;line-height:1.5em;text-align:justify;color:#999;">4차 산업혁명 시대, 시장과 소비자는 어떻게 바뀌나 그리고 기업은 어떤 전략을 세워야 할까     ‘불확실한’ ‘복잡한’ ‘혼란스러운’…. 아쉽게도 이런 단어들만큼 요즘의 경제 환경을 잘 표현해준 말은 없을 것이다. 자동화, 기계화로 대변되는 ICT의 발달은 ‘4차 산업혁명’이라 부를 수 있을 만큼 광범위한 변화를...</p></div></div><br><br><p>마케팅의 아버지라고 불리우는 필립 코틀러의 신간이다. 마켓 3.0 이후 7년만(정식 번역본 기준)에 출간하였는데, 그리 길지 않은 시간이었지만 스마트폰이 보급되어 초연결 사회가 도래한 만큼 마케팅의 방법 또한 바뀌어야 한다고 말하는 책이다. 그 배경에는 디지털이 가장 큰 원인으로 자리잡고 있겠지만, 그로 말미암아 주류 고객층까지 바뀌었다는 것에 의의가 있겠다. 과거에는 주류 고객이 연장자, 남성, 시티즌이었다면, 이제는 디지털 네이티브 세대라고 불리우는 젊은이, 여성, 네티즌이 시장을 주도한다. 그리고, 이 책은 그러한 변화에 마케터들이 어떻게 전략을 세울 것인가에 대한 친절한 조언을 건낸다.</p><p>이 책은, 크게 3개의 파트로 나누어져 있다. 1부에서는 필립 코틀러가 현재 우리가 살고 있는 세계를 관찰하고 알아낸 결과물들에 대해 말하고 있다. 조금 더 자세히 말하자면, 세계의 변화와 트렌드에 영향을 주는 힘의 세 가지 변화가 어떻게 일어났는지 짚어주고 있다. 2부에서는 이러한 변화 속에서 마케터로서 생산성을 높이기 위해 무엇을 해야 하는지 이야기 하고 있다. 끝으로 3부에서는 마켓 4.0 시대에 필수적인 주요 전술들을 설명하고 있다.</p><p>사실 개인적으로 느끼기에는 1부-1장에 마켓 4.0의 핵심이 담겨있다고 생각한다. 디지털 시대를 맞아 시장이 어떻게 변하였는지 단, 세 문장으로 말해주고 있다.</p><p><strong>배타적에서 포용적으로</strong><br><strong>수직적에서 수평적으로</strong><br><strong>개인적에서 사회적으로</strong></p><p>디지털화를 통해 초연결 사회가 되면서 전세계가 실시간으로 소통할 수 있는 시대가 열렸고, 자연스럽게 다양성을 존중하는 문화가 만들어졌다. 그에 발맞춰 다양한 소비자들의 집단 즉, 커뮤니티가 등장했고, 결국, 자본을 지닌 개인보다 연결된 전체가 강한 힘을 갖게 되었다.</p><img src="https://images.unsplash.com/photo-1528642474498-1af0c17fd8c3?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1950&q=80" alt="walking people"><p>이런 시대라서 벌어지는 또 다른 재미있는 구경거리들도 있는데, 경쟁 관계에 있는 기업들 또한, 수직적이 아닌 수평적 관계로 변화하고 있다는 점이다. 과거에는 빠르게 시장을 선점한 기업이 후발주자들을 저만치 떨어뜨린 채 독주를 하는 그림이 흔했다. 하지만, 요즘에는 그 어떤 기업도 영원한 1위로 남을 수 있다고 장담하지 못 한다. 불과 몇 개월 전까지 세상에 없던 기업이 ‘공유경제’라느니, ‘중간 유통 마진 제로’라느니 하는 등의 과거에는 상상도 못 했던 아이디어들로 금방 글로벌 기업 반열에 드는 시대인 것이다.</p><p>우버, 에어비앤비, 넷플릭스 등 디지털 시대를 맞아 급성장한 기업들이 이전까지 그 누구도 시도하지 않았던 아이디어를 들고 나온 것도 물론 맞지만, 그에 앞서 디지털 시대의 소비자들을 이해 했기 때문에 나올 수 있던 아이디어라고 할 수 있다.</p><img src="https://images.unsplash.com/photo-1559136555-9303baea8ebd?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1950&q=80" alt="startup"><p>지금의 그리고, 앞으로의 소비자들은 더 이상 기업이 일방적으로 타겟팅 할 수 있는 대상이 아니다. 브랜드와 소비자의 관계가 단순히 물건을 팔고, 사는 관계로 남는다면, 그 브랜드에게 미래는 없다고 볼 수 있다.</p><p><strong>그 어느 때보다 가족처럼 친구처럼 진정성 있고 투명한 관계가 요구되는 시기라고 생각한다.</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div style=&quot;clear:left;text-align:left;&quot;&gt;&lt;div style=&quot;float:left;margin:0 15px 5px 0;&quot;&gt;&lt;a href=&quot;/Product/Goods/35952025&quot; style=&quot;display:inlin
      
    
    </summary>
    
    
      <category term="내가 읽은 책" scheme="http://codeameba.github.io/categories/%EB%82%B4%EA%B0%80-%EC%9D%BD%EC%9D%80-%EC%B1%85/"/>
    
    
      <category term="마케팅" scheme="http://codeameba.github.io/tags/%EB%A7%88%EC%BC%80%ED%8C%85/"/>
    
      <category term="book review" scheme="http://codeameba.github.io/tags/book-review/"/>
    
      <category term="마켓4.0" scheme="http://codeameba.github.io/tags/%EB%A7%88%EC%BC%934-0/"/>
    
      <category term="독후감" scheme="http://codeameba.github.io/tags/%EB%8F%85%ED%9B%84%EA%B0%90/"/>
    
  </entry>
  
  <entry>
    <title>[Book Review] 내가 했던 모든 일이 마케터의 일이었다</title>
    <link href="http://codeameba.github.io/2019/10/09/blog/book-review-work-of-marketer/"/>
    <id>http://codeameba.github.io/2019/10/09/blog/book-review-work-of-marketer/</id>
    <published>2019-10-09T07:38:42.000Z</published>
    <updated>2020-02-07T07:50:30.863Z</updated>
    
    <content type="html"><![CDATA[<div style="clear:left;text-align:left;"><div style="float:left;margin:0 15px 5px 0;"><a href="/Product/Goods/59438439" style="display:inline-block;overflow:hidden;border:solid 1px #ccc;" target="_blank"><img style="margin:-1px;vertical-align:top;" src="http://image.yes24.com/goods/59438439/M" border="0" alt="마케터의 일 "></a></div><div><p style="line-height:1.2em;color:#333;font-size:14px;font-weight:bold;">마케터의 일 </p><p style="margin-top:5px;line-height:1.2em;color:#666;"><a href="http://www.yes24.com/SearchCorner/Result?domain=ALL&author_yn=Y&query=&auth_no=211762" target="_blank" rel="external nofollow noopener noreferrer">장인성</a> 저/<a href="http://www.yes24.com/SearchCorner/Result?domain=ALL&author_yn=Y&query=&auth_no=211827" target="_blank" rel="external nofollow noopener noreferrer">김규림</a> 그림</p><p style="margin-top:14px;line-height:1.5em;text-align:justify;color:#999;">‘직업으로서의 마케터’를 이야기합니다오늘도 치열하게 목표를 세우고 방법을 찾고 계획을 실현하는 마케터들을 위한 책『마케터의 일』은 비슷한 고민을 거쳐 성장해온 선배 마케터가 후배 마케터들에게 전하는 이야기다. 저자는 마케터가 하는 일은 회사마다 개인마다 다르지만, 그럴수록 마케팅의 본질을 놓치지 말아...</p></div></div><br><br><br>현 시점 국내 기업 중 가장 핫한 마케팅을 하는 '배달의 민족'. 그곳의 CBO 장인성 님의 책이다. 저자는, 책을 쓰게 된 계기에 대하여 다음과 같이 말한다.<blockquote><p>“이 책은 어떤 IT서비스 회사에서 마케터들이 일상적으로 주고받는 이야기이자 마케터 장인성의 개인적 경험에 기반한 본격 ‘저는 이렇던데요’ 이야기 묶음집입니다. 어쩌면 이 책의 숨은 제목은 ‘마케터 장인성의 일’인지도 모릅니다. 처음에는 함께 일하는 주니어 마케터들에게 제 잔소리이자 경험자산을 나눠주려고 글을 쓰기 시작했습니다. 그렇데 쓰다 보니, 같이 일하는 마케터들뿐 아니라 옆 회사, 다른 회사, 경쟁사의 마케터들에게도 읽을 만한 글이 될 수 있겠다는 용감한(?) 생각이 들더라고요. 그래서 씁니다. 마케터의 일”</p></blockquote><p>비록 내가 지금은 백수(또는 전업 집사)로 하루하루 즐겁게(?) 지내는 중이긴 하지만, 2014년부터 2018년까지는 마케터였다. 아니, 정확하게 말하자면 ‘나의 명함에 적혀있던 직함이 마케터’였다. 당시의 나는 마케팅에 대한 공부는 커녕 관심조차 없었는데 우연한 기회에 마케팅대행사에 들어가게 되었다. 지금 생각해보면 관심도 없는 일은 왜 했나 싶기도 하지만, 아마 조급했던 것 같다. 20대 중반, 군대를 다녀오고, 대학을 졸업하고, 전공(플라워디자인)을 살려 1년 정도 일을 해봤지만 이 길은 아니다 싶었다. 그렇다고 다른 일을 해보자니 막막하여 국비지원으로 편집디자인을 배우며 어설픈 포트폴리오를 만들었었다. 그렇게 만들어진 포트폴리오를 첨부하여 취업포탈사이트 몇 군데에 이력서를 등록했었는데 이를 본 마케팅대행사에서 먼저 연락이 온 것이었다. 근데 재밌는 것은, 당연히 디자이너로 뽑힌 줄 알았는데 마케터로 뽑았다는 점이다. 마케터가 무엇인지, 무슨 일을 하는지도 몰랐지만 앞서 말했듯 나는 조급했기에 어떤 이유였든 단지 나를 뽑아주었다는 그 호의를 고맙게 받았다.</p><p>내게 주어진 일들은 상당히 다양했다. 블로그에 장문의 글을 쓰거나 매월 콘텐츠 스케쥴을 짜기도 하고, 프로모션에 쓰일 포스터를 디자인 하기도 하고, 행사를 준비하기도 했으며, 인터뷰 질문을 구상하기도 하고, 제품이나 인물 사진을 찍기도 하고, 심지어 일본어나 영어로 된 원문을 번역하기도 했다. 이 외에도 모두 떠올리기 어려울 정도로 다양한 일을 했다. 기본적으로 다양한 분야에 관심이 있고, 새로운 것을 좋아하는 나로서는 무척 재미있게 일을 했었다. 3년차까지는.</p><p>자칫 3개월로 끝날 수 있었을 수습직원은 정직원이 되고, 주임이 되고, 3년차 쯤에는 대리가 되었다. 그렇다. 직장인들이 권태기라 부르는 ‘마의 3년차’였다. 나 역시 마의 3년차를 피할 수 없었는데, 당시 내 나이가 29살이라는 점도 큰 기여를 했던 것 같다. 단순히 일이 재미 없다기 보다는 목표의 부재와 미래에 대한 불안함. 뭐 그런 복합적인 상황이었는데, 지금 생각해보면, ‘마케터의 일’이 무엇인지 모르기 때문에 느꼈던 불안함이었던 것 같다. 막 성장하는 스타트업이었고, ‘이것이 마케터의 일이다!’라며 확신을 주는 백전노장 같은 사수가 없었다. 그들에게도 나에게도 대부분의 일들이 처음이었다. 그런 배경 속에서 자연스럽게 드는 생각이었다.</p><p><em>‘내가 지금 제대로 하고 있는 걸까?’</em><br><em>‘여기에 과연 전문성이 있는 걸까?’</em><br><em>‘굳이 내가 아니어도 누구나 심지어 갓 입사한 신입이라도 할 수 있는 일 아닐까?’</em></p><p>생각이 많고 결단력이 있는 사람이라면 이런 상황에 놓였을 때 즉시 그만 두고 다른 길을 가거나 확신을 갖고 초심으로 돌아갈 것이다. 반면에 생각이 많고 우유부단한 사람은 이도 저도 아닌 상태로 고민만 지속할 뿐 이렇다 할만한 행동을 취하지 못 한다. 안타깝게도 난 후자였다. 물론 경우에 따라 신중함이라는 좋은 말로 포장할 수도 있긴 하지만, 그렇다 하더라도 나의 고민은 너무 길었다. 결국 답을 얻지 못한채 껍데기 뿐인 마케터로 지냈으며, 해가 넘어가기 직전에서야 퇴사를 결심했다.</p><img src="https://images.unsplash.com/photo-1519389950473-47ba0277781c?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1950&q=80" alt="working table"><p>서론부터 지지부진하고 재미없는 이야기를 길게 늘어놨는데, 그나마 글로 적어서 이 정도다. 내가 체감한 고민의 시간은 ‘내가 지금 시간과 정신의 방에 갇힌 게 아닐까’ 하는 생각이 들 정도로 길었다. 그리고, 100% 내 경험담인 이 이야기가 ‘마케터의 일’ 도입부에 등장한다. 물론 저자와 일면식도 없으니 내 사례를 가져가 쓴 것은 아닐 것이다. 그럼에도 불구하고 내가 놓였던 상황, 내가 했던 고민들과 놀랍도록 닮았다. 나는 허탈감과 동시에 개운함을 느꼈다. 내가 특수한 상황에 놓인 것도 아니었고, 내 고민이 이상한 것도 아니었던 것이다. 아, 좀 더 일찍 읽었더라면……</p><p>마케터가 하는 일이 무엇인지 모르면서 그저 다양한 경험에 즐거워하고, 새로운 경험에 설레던 20대의 나. 마찬가지로 마케터가 하는 일이 무엇인지 모르기 때문에 불안해하고 고민하던 30대의 나. 이제야 알았다. 내가 했던 모든 일이 마케터의 일이었다. 마침내 내 방황에도 끝이 보이는 것 같다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div style=&quot;clear:left;text-align:left;&quot;&gt;&lt;div style=&quot;float:left;margin:0 15px 5px 0;&quot;&gt;&lt;a href=&quot;/Product/Goods/59438439&quot; style=&quot;display:inlin
      
    
    </summary>
    
    
      <category term="내가 읽은 책" scheme="http://codeameba.github.io/categories/%EB%82%B4%EA%B0%80-%EC%9D%BD%EC%9D%80-%EC%B1%85/"/>
    
    
      <category term="마케팅" scheme="http://codeameba.github.io/tags/%EB%A7%88%EC%BC%80%ED%8C%85/"/>
    
      <category term="book review" scheme="http://codeameba.github.io/tags/book-review/"/>
    
      <category term="독후감" scheme="http://codeameba.github.io/tags/%EB%8F%85%ED%9B%84%EA%B0%90/"/>
    
      <category term="마케터의 일" scheme="http://codeameba.github.io/tags/%EB%A7%88%EC%BC%80%ED%84%B0%EC%9D%98-%EC%9D%BC/"/>
    
  </entry>
  
  <entry>
    <title>TIL(190918) - Vue.js 01</title>
    <link href="http://codeameba.github.io/2019/09/18/programming/vue-til-01/"/>
    <id>http://codeameba.github.io/2019/09/18/programming/vue-til-01/</id>
    <published>2019-09-17T16:00:42.000Z</published>
    <updated>2020-02-03T07:47:26.950Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TIL-190918-Vue-js-01"><a href="#TIL-190918-Vue-js-01" class="headerlink" title="TIL(190918) - Vue.js 01"></a>TIL(190918) - Vue.js 01</h1><hr><p><strong>Vue.js 시작하기 - Age of Vue.js를 보고 정리함</strong></p><h2 id="Vue-js-Documents"><a href="#Vue-js-Documents" class="headerlink" title="Vue.js Documents"></a>Vue.js Documents</h2><hr><ul><li><a href="https://kr.vuejs.org/" target="_blank" rel="external nofollow noopener noreferrer">Vue.js</a></li></ul><br><h2 id="Vue-js는-무엇인가"><a href="#Vue-js는-무엇인가" class="headerlink" title="Vue.js는 무엇인가?"></a>Vue.js는 무엇인가?</h2><hr><ul><li>MVVM 패턴의 뷰모델 레이어에 해당하는 화면단 라이브러리<ul><li><a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel" target="_blank" rel="external nofollow noopener noreferrer">Model–view–viewmodel - Wikipedia</a></li><li>DOM(View)을 조작하면 Vue.js(ViewModel) 내부의 DOM Listeners가 이를 인지하여 자바스크립트(Model)에 전달하고, 자바스크립트는 다시 Vue.js 내부의 Data Bindings를 통해 DOM에 데이터를 전달한다. 결과적으로 화면에 보여지는 내용 역시 변경된다.</li></ul></li></ul><br><h2 id="Vue-js를-쓰는-이유"><a href="#Vue-js를-쓰는-이유" class="headerlink" title="Vue.js를 쓰는 이유"></a>Vue.js를 쓰는 이유</h2><hr><ul><li>Vue.js와 같은 프레임워크를 사용하지 않고 html, css, JavaScript만 사용한 기본적인 웹개발에서는 View를 바꾸려면 직접적으로 코드를 손봐야만 했다.</li><li>하지만 매번 변경할 때마다 사람이 손수 고치는 것은 무리가 있기 때문에 Vue.js같은 프레임워크를 사용한다.</li><li>결론적으로, View의 내용을 변경하면 내부의 코드가 자동적으로 변경되고 그 상태가 유지 될 수 있도록 하는 것에 의의가 있다.</li><li>이러한 것이 Vue.js의 핵심 사상인 <strong>Reactivity</strong><ul><li><a href="https://kr.vuejs.org/v2/guide/reactivity.html" target="_blank" rel="external nofollow noopener noreferrer">반응형에 대해 깊이 알아보기 — Vue.js</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;TIL-190918-Vue-js-01&quot;&gt;&lt;a href=&quot;#TIL-190918-Vue-js-01&quot; class=&quot;headerlink&quot; title=&quot;TIL(190918) - Vue.js 01&quot;&gt;&lt;/a&gt;TIL(190918) - Vue.js 01
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://codeameba.github.io/categories/JavaScript/"/>
    
    
      <category term="til" scheme="http://codeameba.github.io/tags/til/"/>
    
      <category term="TIL" scheme="http://codeameba.github.io/tags/TIL/"/>
    
      <category term="Today I Learned" scheme="http://codeameba.github.io/tags/Today-I-Learned/"/>
    
      <category term="오늘배운것들" scheme="http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"/>
    
      <category term="자바스크립트" scheme="http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"/>
    
      <category term="Javascript" scheme="http://codeameba.github.io/tags/Javascript/"/>
    
      <category term="vue.js" scheme="http://codeameba.github.io/tags/vue-js/"/>
    
      <category term="뷰" scheme="http://codeameba.github.io/tags/%EB%B7%B0/"/>
    
  </entry>
  
  <entry>
    <title>[ReactJS] 무비앱 만들기 Day 06</title>
    <link href="http://codeameba.github.io/2019/09/09/programming/react-movie-app-06/"/>
    <id>http://codeameba.github.io/2019/09/09/programming/react-movie-app-06/</id>
    <published>2019-09-08T16:00:42.000Z</published>
    <updated>2020-02-03T07:47:26.945Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ReactJS-무비앱-만들기-Day-06"><a href="#ReactJS-무비앱-만들기-Day-06" class="headerlink" title="[ReactJS] 무비앱 만들기 Day 06"></a>[ReactJS] 무비앱 만들기 Day 06</h1><hr><h2 id="5-0-Container-Presenter-Pattern-part-One"><a href="#5-0-Container-Presenter-Pattern-part-One" class="headerlink" title="5.0 Container Presenter Pattern part One"></a>5.0 Container Presenter Pattern part One</h2><hr><ul><li>Container Presenter Pattern에서 컨테이너는 data와 state를 지니고, api를 불러온다. 그리고 모든 로직을 처리.</li><li>그 다음, 프레젠터가 그 data들을 보여주는 역할.(프레젠터에는 state가 없고, api도 모르며 클래스도 없고 단지 함수형 컴포넌트)</li><li>쉽게 말해서 프레젠터는 ‘스타일’, 컨테이너는 ‘데이터’</li></ul><h3 id="각-컨테이너별-폴더를-따로-구성"><a href="#각-컨테이너별-폴더를-따로-구성" class="headerlink" title="각 컨테이너별 폴더를 따로 구성"></a>각 컨테이너별 폴더를 따로 구성</h3><ul><li>폴더마다 index.js가 있어야 함. 컨테이너를 export해야 하기 때문.</li><li>이렇게 정리하는 게 혼란을 줄일 수 있음.</li><li>index.js가 HomeContainer를 import / export하는 역할을 하고</li><li>HomeContainer는 state를 가진 모든 리액트 컴포넌트가 된다.</li></ul><p><strong>src - Routes - Home - HomeContainer.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> HomePresenter <span class="keyword">from</span> <span class="string">'./HomePresenter'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    nowPlaying: <span class="literal">null</span>,</span><br><span class="line">    upcoming: <span class="literal">null</span>,</span><br><span class="line">    popular: <span class="literal">null</span>,</span><br><span class="line">    error: <span class="literal">null</span>,</span><br><span class="line">    loading: <span class="literal">true</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; nowPlaying, upcoming, popular, error, loading &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;HomePresenter </span><br><span class="line">        nowPlaying=&#123;nowPlaying&#125; </span><br><span class="line">        upcoming=&#123;upcoming&#125; </span><br><span class="line">        popular=&#123;popular&#125; </span><br><span class="line">        error=&#123;error&#125;</span><br><span class="line">        loading=&#123;loading&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h2 id="5-1-Container-Presenter-Pattern-part-Two"><a href="#5-1-Container-Presenter-Pattern-part-Two" class="headerlink" title="5.1 Container Presenter Pattern part Two"></a>5.1 Container Presenter Pattern part Two</h2><hr><ul><li>search container는 <strong>상호작용</strong>이 필요하기 때문에 조금 까다로움</li><li>loading의 경우 기본값은 false<ul><li>유저가 아무런 행동을 취하지 않았는데 로딩이 되면 안 되니까</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> SearchPresenter <span class="keyword">from</span> <span class="string">'./SearchPresenter'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    MovieResults: <span class="literal">null</span>,</span><br><span class="line">    TvResults: <span class="literal">null</span>,</span><br><span class="line">    SearchTerm: <span class="string">''</span>,</span><br><span class="line">    error: <span class="literal">null</span>,</span><br><span class="line">    loading: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; MovieResults, TvResults, SearchTerm, error, loading &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;SearchPresenter</span><br><span class="line">        MovieResults=&#123;MovieResults&#125;</span><br><span class="line">        TvResults=&#123;TvResults&#125;</span><br><span class="line">        SearchTerm=&#123;SearchTerm&#125;</span><br><span class="line">        error=&#123;error&#125;</span><br><span class="line">        loading=&#123;loading&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h2 id="5-2-Home-Container"><a href="#5-2-Home-Container" class="headerlink" title="5.2 Home Container"></a>5.2 Home Container</h2><hr><ul><li><p>두 가지 옵션이 있음</p><ul><li>componentDidMount()를 통해 전체 api 요청을 할 수 있고</li><li>각각의 요청을 분리된 함수로 따로 요청할 수도 있음.<ul><li>ex) getNowPlaying(), getUpComing() 등등</li></ul></li></ul></li><li><p>이번 경우엔 굳이 분리할 필요가 없으므로 componentDidMount()를 사용함</p></li></ul><h3 id="try-catch"><a href="#try-catch" class="headerlink" title="try - catch"></a>try - catch</h3><ul><li>try가 먼저 실행되고, 작동하지 않으면 error를 catch 한다.</li></ul><h3 id="async-await"><a href="#async-await" class="headerlink" title="async / await"></a>async / await</h3><ul><li>준비가 될 때까지 기다려달라는 의미</li><li>예를 들어 아래와 같은 상황에서 async/await이 없으면, nowPlaying 데이터를 가져오기 시작한다. 하지만 api가 리턴할 때까지 자바스크립트는 기다려주지 않음.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> componentDidMount() &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> MoviesApi.nowPlaying();</span><br><span class="line">  &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      error: <span class="string">"Can't find movis information."</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      loading: <span class="literal">false</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>하지만, async/await을 쓰면 데이터가 준비될 때까지 자바스크립트가 기다려줌.</li></ul><h3 id="비구조화-할당"><a href="#비구조화-할당" class="headerlink" title="비구조화 할당"></a>비구조화 할당</h3><ul><li>변수명에 data를 정할 때 비구조화 할당을 쓰면 보기 좋음<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> componentDidMount() &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="attr">data</span>: &#123; <span class="attr">results</span>: nowPlaying &#125;&#125; = <span class="keyword">await</span> MoviesApi.nowPlaying();</span><br><span class="line">    <span class="built_in">console</span>.log(nowPlaying);</span><br><span class="line">  &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      error: <span class="string">"Aw, Snap!"</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      loading: <span class="literal">false</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><br><h2 id="5-3-TV-Container"><a href="#5-3-TV-Container" class="headerlink" title="5.3 TV Container"></a>5.3 TV Container</h2><hr><ul><li>Movies와 동일</li></ul><br><h2 id="5-4-Search-Container"><a href="#5-4-Search-Container" class="headerlink" title="5.4 Search Container"></a>5.4 Search Container</h2><hr><ul><li>모든 로직을 갖는다.</li><li>첫 번째 로직은 handleSubmit<ul><li>입력 폼에 text를 입력한 뒤 엔터키를 누르면 Submit이 됨</li><li>searchTerm이 공백이 아닌지 체크하고 search 함수를 실행할 것</li></ul></li><li>특히 try는 다른 컨테이너와 다름<ul><li>검색을 시도했을 때 로딩을 true로 만든다(기본값은 false).<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">handleSubmit = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; searchTerm &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">  <span class="keyword">if</span> (searchTerm !== <span class="string">''</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.searchByTerm();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">searchByTerm = <span class="keyword">async</span>() =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; searchTerm &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="attr">data</span>: &#123; <span class="attr">results</span>: movieResults &#125;&#125; = <span class="keyword">await</span> MoviesApi.search(searchTerm);</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="attr">data</span>: &#123; <span class="attr">results</span>: tvResults &#125;&#125; = <span class="keyword">await</span> TvApi.search(searchTerm);</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      movieResults,</span><br><span class="line">      tvResults</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      loading: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      error: <span class="string">"Can't find results."</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      loading: <span class="literal">false</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><br><h2 id="5-5-Detail-Container-part-One"><a href="#5-5-Detail-Container-part-One" class="headerlink" title="5.5 Detail Container part One"></a>5.5 Detail Container part One</h2><hr><ul><li>Router Component에 Detail을 추가해야 함.</li><li>Movie나 TV의 id를 가져와서 보여주는 방식</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; (</span><br><span class="line">  &lt;Router&gt;</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;Header /&gt;</span><br><span class="line">      &lt;Switch&gt;</span><br><span class="line">        &lt;Route path=<span class="string">"/"</span> exact component=&#123;Home&#125; /&gt;</span><br><span class="line">        &lt;Route path=<span class="string">"/tv"</span> component=&#123;TV&#125; /&gt;</span><br><span class="line">        &lt;Route path=<span class="string">"/search"</span> component=&#123;Search&#125; /&gt;</span><br><span class="line">        &lt;Route path=<span class="string">"/movie/:id"</span> component=&#123;Detail&#125; /&gt;</span><br><span class="line">        &lt;Route path=<span class="string">"/tv/:id"</span> component=&#123;Detail&#125; /&gt;</span><br><span class="line">        &lt;Redirect <span class="keyword">from</span>=<span class="string">"*"</span> to=<span class="string">"/"</span> /&gt;</span><br><span class="line">      &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">  &lt;<span class="regexp">/Router&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><ul><li><p><code>:id</code>는 해당 위치는 랜덤한 id가 올 수 있음을 의미</p></li><li><p>id는 url에서 가져올 예정</p></li><li><p>Header component는 라우터의 위치를 알고 있음.</p><ul><li>withRouter로 감쌌기 때문에</li></ul></li><li><p>id가 보기에는 숫자지만, typeof를 해보면 string으로 나옴 따라서 parseInt를 해줘야 함</p></li><li><p>id가 숫자가 아닌 경우에는 home으로 보냄</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> componentDidMount() &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="attr">match</span>: &#123; <span class="attr">params</span>: &#123; id &#125;&#125;, <span class="attr">history</span>: &#123; push &#125;&#125; = <span class="keyword">this</span>.props;</span><br><span class="line">  <span class="keyword">const</span> parseId = <span class="built_in">parseInt</span>(id);</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">isNaN</span>(parseId)) &#123;</span><br><span class="line">    push(<span class="string">'/'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ReactJS-무비앱-만들기-Day-06&quot;&gt;&lt;a href=&quot;#ReactJS-무비앱-만들기-Day-06&quot; class=&quot;headerlink&quot; title=&quot;[ReactJS] 무비앱 만들기 Day 06&quot;&gt;&lt;/a&gt;[ReactJS] 무비앱 만들기 
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://codeameba.github.io/categories/JavaScript/"/>
    
    
      <category term="til" scheme="http://codeameba.github.io/tags/til/"/>
    
      <category term="TIL" scheme="http://codeameba.github.io/tags/TIL/"/>
    
      <category term="Today I Learned" scheme="http://codeameba.github.io/tags/Today-I-Learned/"/>
    
      <category term="오늘배운것들" scheme="http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"/>
    
      <category term="자바스크립트" scheme="http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"/>
    
      <category term="리액트" scheme="http://codeameba.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"/>
    
      <category term="react" scheme="http://codeameba.github.io/tags/react/"/>
    
      <category term="노마드코더" scheme="http://codeameba.github.io/tags/%EB%85%B8%EB%A7%88%EB%93%9C%EC%BD%94%EB%8D%94/"/>
    
      <category term="nomadcoders" scheme="http://codeameba.github.io/tags/nomadcoders/"/>
    
  </entry>
  
  <entry>
    <title>[ReactJS] 무비앱 만들기 Day 05</title>
    <link href="http://codeameba.github.io/2019/09/05/programming/react-movie-app-05/"/>
    <id>http://codeameba.github.io/2019/09/05/programming/react-movie-app-05/</id>
    <published>2019-09-04T16:00:42.000Z</published>
    <updated>2020-02-03T07:47:26.920Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ReactJS-무비앱-만들기-Day-05"><a href="#ReactJS-무비앱-만들기-Day-05" class="headerlink" title="[ReactJS] 무비앱 만들기 Day 05"></a>[ReactJS] 무비앱 만들기 Day 05</h1><hr><h2 id="4-0-Introduction-to-The-Movie-DB-API"><a href="#4-0-Introduction-to-The-Movie-DB-API" class="headerlink" title="4.0 Introduction to The Movie DB API"></a>4.0 Introduction to The Movie DB API</h2><hr><ul><li>데이터가 오는 곳이 API(Application Programming Interface)</li><li>Nomflix에서는 the movie db를 이용함(가입 필요).<ul><li><a href="https://www.themoviedb.org/" target="_blank" rel="external nofollow noopener noreferrer">https://www.themoviedb.org/</a> </li></ul></li><li>setting -&gt; API -&gt; API KEY copy</li></ul><h2 id="4-1-Sexy-Networking-with-Axios-Instances"><a href="#4-1-Sexy-Networking-with-Axios-Instances" class="headerlink" title="4.1 Sexy Networking with Axios Instances"></a>4.1 Sexy Networking with Axios Instances</h2><hr><h3 id="API-Verbs"><a href="#API-Verbs" class="headerlink" title="API Verbs"></a>API Verbs</h3><ul><li><input disabled type="checkbox"> Now playing (Movie</li><li><input disabled type="checkbox"> Top Rated (TV, Movie)</li><li><input disabled type="checkbox"> Popular (TV, Movie)</li><li><input disabled type="checkbox"> Upcoming (Movie)</li><li><input disabled type="checkbox"> Airing Today (TV)</li></ul><h3 id="요청-방식"><a href="#요청-방식" class="headerlink" title="요청 방식"></a>요청 방식</h3><ul><li>이전 강의들에서는 주로 fetch를 썼음<ul><li>라우터에서 호출하고, fetch 하고, 나머지 모든 작업들을 하는 방식인데 효율적이지 않음.</li><li>왜냐하면 url의 동일한 내용이 반복되기 때문</li><li>따라서 네트워킹과 API만 다루는 별도의 파일을 따로 만들고 호출할 것</li><li>또한, fetch가 아닌, axios를 사용</li></ul></li></ul><h3 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h3><ul><li><a href="https://github.com/axios/axios" target="_blank" rel="external nofollow noopener noreferrer">GitHub - axios/axios: Promise based HTTP client for the browser and node.js</a></li><li>별도 모듈 설치 필요<ul><li><code>yarn add axios</code></li></ul></li><li>axios의 장점은, 직접 인스턴스를 configure(설정)할 수 있다는 점.</li></ul><p><strong>axios.create([config])</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">  baseURL: <span class="string">'https://some-domain.com/api/'</span>,</span><br><span class="line">  timeout: <span class="number">1000</span>,</span><br><span class="line">  headers: &#123;<span class="string">'X-Custom-Header'</span>: <span class="string">'foobar'</span>&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>위의 axios.create를 통해 반복을 최소화 할 수 있음.<ul><li>parameter에 api_key와 language 전달</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> api = axios.create(&#123;</span><br><span class="line">  baseURL: <span class="string">'https://api.themoviedb.org/3/'</span>,</span><br><span class="line">  params: &#123;</span><br><span class="line">    api_key: <span class="string">'b8e07a1bc39775b44d7ad690b461e764'</span>,</span><br><span class="line">    language: <span class="string">'en-US'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">api.get(<span class="string">'tv/popular'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> api;</span><br></pre></td></tr></table></figure><ul><li>index.js에 api.js를 import하고 실행해보면 아래와 같이 데이터가 들어오는 것을 확인할 수 있음.</li><li>주의) api.get에서 <code>tv/popular</code>로 작성해야 상대경로로 접근함<ul><li><code>/tv/popular</code>로 작성하면 절대경로가 됨</li></ul></li></ul><img src="/images/api-response.png"><img src="/images/api-response2.png"><hr><h2 id="4-2-API-Verbs-part-One"><a href="#4-2-API-Verbs-part-One" class="headerlink" title="4.2 API Verbs part One"></a>4.2 API Verbs part One</h2><hr><h3 id="API-Verbs-1"><a href="#API-Verbs-1" class="headerlink" title="API Verbs"></a>API Verbs</h3><ul><li><input checked disabled type="checkbox"> <p>Now playing (Movie)</p></li><li><input checked disabled type="checkbox"> <p>Upcoming (Movie)</p></li><li><input checked disabled type="checkbox"> <p>Top Rated (TV)</p></li><li><input checked disabled type="checkbox"> <p>Popular (TV, X)</p></li><li><input checked disabled type="checkbox"> <p>Airing Today (TV)</p></li><li><input disabled type="checkbox"> <p>TV Show Detail</p></li><li><input disabled type="checkbox"> <p>Movie Detail</p></li><li><p>TV와 Movies 각각의 api 요청</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> api = axios.create(&#123;</span><br><span class="line">  baseURL: <span class="string">'https://api.themoviedb.org/3/'</span>,</span><br><span class="line">  params: &#123;</span><br><span class="line">    api_key: <span class="string">'b8e07a1bc39775b44d7ad690b461e764'</span>,</span><br><span class="line">    language: <span class="string">'en-US'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> MoviesApi = &#123;</span><br><span class="line">  nowPlaying: <span class="function"><span class="params">()</span> =&gt;</span> api.get(<span class="string">'movie/now_playing'</span>),</span><br><span class="line">  upcoming: <span class="function"><span class="params">()</span> =&gt;</span> api.get(<span class="string">'movie/upcoming'</span>),</span><br><span class="line">  popluar: <span class="function"><span class="params">()</span> =&gt;</span> api.get(<span class="string">'movie/popular'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> TvApi = &#123;</span><br><span class="line">  topRated: <span class="function"><span class="params">()</span> =&gt;</span> api.get(<span class="string">'tv/top_rated'</span>),</span><br><span class="line">  popular: <span class="function"><span class="params">()</span> =&gt;</span> api.get(<span class="string">'tv/popular'</span>),</span><br><span class="line">  airingToday: <span class="function"><span class="params">()</span> =&gt;</span> api.get(<span class="string">'tv/airing_today'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>fetch 방식의 api 요청에 비해 훨씬 간결하고 가독성이 좋음.</li><li>axios 짱짱맨</li></ul><h2 id="4-3-API-Verbs-part-Two"><a href="#4-3-API-Verbs-part-Two" class="headerlink" title="4.3 API Verbs part Two"></a>4.3 API Verbs part Two</h2><hr><ul><li>Movie Detail을 가져오기 위해 id가 필요함<ul><li><code>movie/{movie_id}</code></li></ul></li></ul><h3 id="API-Verbs-2"><a href="#API-Verbs-2" class="headerlink" title="API Verbs"></a>API Verbs</h3><ul><li><input checked disabled type="checkbox"> Now playing (Movie)</li><li><input checked disabled type="checkbox"> Upcoming (Movie)</li><li><input checked disabled type="checkbox"> Top Rated (TV)</li><li><input checked disabled type="checkbox"> Popular (TV, X)</li><li><input checked disabled type="checkbox"> Airing Today (TV)</li><li><input checked disabled type="checkbox"> TV Show Detail</li><li><input checked disabled type="checkbox"> Movie Detail</li><li><input checked disabled type="checkbox"> Search  (Movie, TV)</li></ul><h3 id="append-to-response"><a href="#append-to-response" class="headerlink" title="append_to_response"></a>append_to_response</h3><ul><li>api에서 지원하는 기능</li><li><a href="https://developers.themoviedb.org/3/getting-started/append-to-response" target="_blank" rel="external nofollow noopener noreferrer">API Docs</a></li><li>video나 image같은 것들을 덧붙이기(append)하면 포스터나 예고편 등으로 출력이 된다.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> MoviesApi = &#123;</span><br><span class="line">  nowPlaying: <span class="function"><span class="params">()</span> =&gt;</span> api.get(<span class="string">'movie/now_playing'</span>),</span><br><span class="line">  upcoming: <span class="function"><span class="params">()</span> =&gt;</span> api.get(<span class="string">'movie/upcoming'</span>),</span><br><span class="line">  popluar: <span class="function"><span class="params">()</span> =&gt;</span> api.get(<span class="string">'movie/popular'</span>),</span><br><span class="line">  movieDetail: <span class="function"><span class="params">id</span> =&gt;</span> api.get(<span class="string">`movie/<span class="subst">$&#123;id&#125;</span>`</span>, &#123;</span><br><span class="line">    params: &#123;</span><br><span class="line">      appent_to_response: <span class="string">'videos'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Search"><a href="#Search" class="headerlink" title="Search"></a>Search</h3><ul><li>search 기능은 url 외에도 검색어에 해당하는 파라미터가 추가로 필요함</li></ul><img src="/images/api-search.png"><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">search: <span class="function">(<span class="params">term</span>) =&gt;</span> api.get(<span class="string">'search/movie'</span>, &#123;</span><br><span class="line">  params: &#123;</span><br><span class="line">    query: term</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>그리고 api의 명세를 잘 찾아보면 아래와 같이 요구사항이 설명되어 있음.</li><li>이 경우에는 URI로 인코딩이 필요하다고 함.</li></ul><img src="/images/api-search2.png"><ul><li>따라서 아래와 같이 encodeURIComponent를 사용하면 값을 인코팅하고 그 문자열로 검색을 하게 됨.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">search: <span class="function">(<span class="params">term</span>) =&gt;</span> api.get(<span class="string">'search/movie'</span>, &#123;</span><br><span class="line">  params: &#123;</span><br><span class="line">    query: <span class="built_in">encodeURIComponent</span>(term)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ReactJS-무비앱-만들기-Day-05&quot;&gt;&lt;a href=&quot;#ReactJS-무비앱-만들기-Day-05&quot; class=&quot;headerlink&quot; title=&quot;[ReactJS] 무비앱 만들기 Day 05&quot;&gt;&lt;/a&gt;[ReactJS] 무비앱 만들기 
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://codeameba.github.io/categories/JavaScript/"/>
    
    
      <category term="til" scheme="http://codeameba.github.io/tags/til/"/>
    
      <category term="TIL" scheme="http://codeameba.github.io/tags/TIL/"/>
    
      <category term="Today I Learned" scheme="http://codeameba.github.io/tags/Today-I-Learned/"/>
    
      <category term="오늘배운것들" scheme="http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"/>
    
      <category term="자바스크립트" scheme="http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"/>
    
      <category term="리액트" scheme="http://codeameba.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"/>
    
      <category term="react" scheme="http://codeameba.github.io/tags/react/"/>
    
      <category term="노마드코더" scheme="http://codeameba.github.io/tags/%EB%85%B8%EB%A7%88%EB%93%9C%EC%BD%94%EB%8D%94/"/>
    
      <category term="nomadcoders" scheme="http://codeameba.github.io/tags/nomadcoders/"/>
    
  </entry>
  
  <entry>
    <title>[ReactJS] 무비앱 만들기 Day 04</title>
    <link href="http://codeameba.github.io/2019/08/29/programming/react-movie-app-04/"/>
    <id>http://codeameba.github.io/2019/08/29/programming/react-movie-app-04/</id>
    <published>2019-08-28T16:00:42.000Z</published>
    <updated>2020-02-03T07:47:26.945Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ReactJS-무비앱-만들기-Day-04"><a href="#ReactJS-무비앱-만들기-Day-04" class="headerlink" title="[ReactJS] 무비앱 만들기 Day 04"></a>[ReactJS] 무비앱 만들기 Day 04</h1><hr><h2 id="3-0-CSS-in-React-part-One"><a href="#3-0-CSS-in-React-part-One" class="headerlink" title="3.0 CSS in React part One"></a>3.0 CSS in React part One</h2><hr><h3 id="리액트에서-CSS를-적용하는-방법-01"><a href="#리액트에서-CSS를-적용하는-방법-01" class="headerlink" title="리액트에서 CSS를 적용하는 방법 01"></a>리액트에서 CSS를 적용하는 방법 01</h3><ul><li>styles.css 파일을 만들어서 스타일 적용</li><li>CSS를 적용할 요소에 className으로 클래스명 적어야 함</li><li>최상위 파일(index.js)에 import<ul><li><code>import &#39;styles.css&#39;;</code></li></ul></li><li>나쁜 방법은 아니나, 컴포넌트와 CSS가 분리되어 있다는 게 단점.<ul><li>컴포넌트를 쓰는 가장 큰 이유는 캡슐화(Encapulation)에 있음.</li></ul></li></ul><br><h3 id="리액트에서-CSS를-적용하는-방법-02"><a href="#리액트에서-CSS를-적용하는-방법-02" class="headerlink" title="리액트에서 CSS를 적용하는 방법 02"></a>리액트에서 CSS를 적용하는 방법 02</h3><ul><li>기능별로 별도 컴포넌트를 생성</li><li>각 컴포넌트마다 CSS 파일의 생성 및 적용</li><li>이 방법에도 단점은 있음<ul><li>첫째, CSS 파일을 생성해야 된다는 점.</li><li>둘째, 사용할 때마다 import를 해야 한다는 점.</li><li>셋째, className을 기억해야 한다는 점.(CSS는 Global로 작동하기 때문)</li></ul></li></ul><br><h2 id="3-1-CSS-in-React-part-Two"><a href="#3-1-CSS-in-React-part-Two" class="headerlink" title="3.1 CSS in React part Two"></a>3.1 CSS in React part Two</h2><hr><h3 id="리액트에서-CSS를-적용하는-방법-03"><a href="#리액트에서-CSS를-적용하는-방법-03" class="headerlink" title="리액트에서 CSS를 적용하는 방법 03"></a>리액트에서 CSS를 적용하는 방법 03</h3><ul><li>CSS를 컴포넌트 스코프에서 작동하도록 하는 방법.</li><li>CSS 모듈이라고 부름.</li><li>className을 임의화해서 local로 작동하게 함.</li></ul><p><strong>src - Components - Header - Header.module.css</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.navList</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>CSS 파일명을 <code>Header.module.css</code> 방식으로 변경</li><li>import는 자바스크립트와 같은 방식<ul><li><code>import styles from ‘./Header.module.css’;</code></li></ul></li><li>className을 자바스크립트의 객체처럼 사용함.</li></ul><p><strong>src - Components - Header - Header.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; (</span><br><span class="line">    &lt;header&gt;</span><br><span class="line">      &lt;ul className=&#123;styles.navList&#125;&gt; <span class="comment">// &lt;- like this</span></span><br><span class="line">        &lt;li&gt;</span><br><span class="line">          &lt;a href=<span class="string">"/a"</span>&gt;Home&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>li&gt;</span><br><span class="line">        &lt;li&gt;</span><br><span class="line">          &lt;a href=<span class="string">"/tv"</span>&gt;TV&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>li&gt;</span><br><span class="line">        &lt;li&gt;</span><br><span class="line">          &lt;a href=<span class="string">"/search"</span>&gt;Search&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>li&gt;</span><br><span class="line">      &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>header&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li><p>class명이 랜덤으로 생성됨.</p><img src="/images/random-class.png"></li><li><p><code>yarn add node-sass</code> 설치 후 아래와 같이 작성할 수도 있음.</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.navList</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  &amp;<span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: deeppink;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>이러한 모듈 방식도 괜찮기는 하지만 className을 기억해야 한다는 점이 단점이다.</p></li><li><p>여전히 JS와 CSS가 동떨어져 있다는 느낌을 지울 수가 없다. 둘을 하나의 파일에서 쓸 수 있는 방법은 무엇이 있을까?</p></li></ul><br><h2 id="3-2-CSS-in-React-part-Three"><a href="#3-2-CSS-in-React-part-Three" class="headerlink" title="3.2 CSS in React part Three"></a>3.2 CSS in React part Three</h2><hr><h3 id="리액트에서-CSS를-적용하는-방법-04"><a href="#리액트에서-CSS를-적용하는-방법-04" class="headerlink" title="리액트에서 CSS를 적용하는 방법 04"></a>리액트에서 CSS를 적용하는 방법 04</h3><ul><li>JS를 이용한 니코의 최애 방법은 <strong>styled-components</strong></li><li>우선 설치가 필요함<ul><li><code>yarn add styled-components</code></li></ul></li><li>설치 후 import<ul><li><code>import styled from &#39;styled-components&#39;</code></li></ul></li></ul><blockquote><p>TIP)<br><strong>vscode-styled-components</strong> 확장 프로그램을 설치하면 텍스트에 색상이 들어감.</p></blockquote><ul><li>styled-component 작성 후 아래와 같이 태그로 사용</li></ul><p><strong>src - Components - Header.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> styled <span class="keyword">from</span> <span class="string">'styled-components'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> List = styled.ul<span class="string">`</span></span><br><span class="line"><span class="string">  display: flex;</span></span><br><span class="line"><span class="string">  &amp;:hover &#123;</span></span><br><span class="line"><span class="string">    background-color: deeppink;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; (</span><br><span class="line">    &lt;header&gt;</span><br><span class="line">      &lt;List&gt; <span class="comment">// &lt;- here</span></span><br><span class="line">        &lt;li&gt;</span><br><span class="line">          &lt;a href=<span class="string">"/"</span>&gt;Home&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>li&gt;</span><br><span class="line">        &lt;li&gt;</span><br><span class="line">          &lt;a href=<span class="string">"/tv"</span>&gt;TV&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>li&gt;</span><br><span class="line">        &lt;li&gt;</span><br><span class="line">          &lt;a href=<span class="string">"/search"</span>&gt;Search&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>li&gt;</span><br><span class="line">      &lt;<span class="regexp">/List&gt; /</span><span class="regexp">/ &lt;- here</span></span><br><span class="line"><span class="regexp">    &lt;/</span>header&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><br><h3 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h3><ul><li><code>&lt;a&gt;&lt;/a&gt;</code>태그를 사용하면 링크로 이동할 때마다 뷰를 다시 렌더링 하는데, 굉장히 비효율적이다.</li><li>따라서, React에서는 <code>Link</code>라는 기능을 사용함.<ul><li><code>import { Link } from &#39;react-router-dom&#39;;</code></li><li>동일한 페이지에 있을 경우 해당 요소만 교체하는 방식</li></ul></li><li>이 경우에는 아래와 같이 styled-components를 적용<ul><li><code>const SLink = styled(Link)``;</code></li></ul></li><li>Link는 Router 밖에서 사용할 수 없으므로 아래와 같은 형식의 문장 구조를 이룸</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; (</span><br><span class="line">  &lt;Router&gt;</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;Header /&gt; <span class="comment">// &lt;- here</span></span><br><span class="line">      &lt;Switch&gt;</span><br><span class="line">        &lt;Route path=<span class="string">"/"</span> exact component=&#123;Home&#125; /&gt;</span><br><span class="line">        &lt;Route path=<span class="string">"/tv"</span> exact component=&#123;TV&#125; /&gt;</span><br><span class="line">        &lt;Route path=<span class="string">"/tv/popular"</span> render=&#123;() =&gt; <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>popular<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>&#125; /&gt;</span><br><span class="line">        &lt;Route path=<span class="string">"/search"</span> component=&#123;Search&#125; /&gt;</span><br><span class="line">        &lt;Redirect <span class="keyword">from</span>=<span class="string">"*"</span> to=<span class="string">"/"</span> /&gt;</span><br><span class="line">      &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">  &lt;<span class="regexp">/Router&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><br><h2 id="3-3-GlobalStyles-and-Header"><a href="#3-3-GlobalStyles-and-Header" class="headerlink" title="3.3 GlobalStyles and Header"></a>3.3 GlobalStyles and Header</h2><hr><h3 id="Global-style-적용"><a href="#Global-style-적용" class="headerlink" title="Global style 적용"></a>Global style 적용</h3><ul><li>글로벌로 설정하는 이유는 해당 사이트의 폰트를 설정하거나, styled-components를 설치하거나 하는 등의 작업 때문.</li><li>우선 <code>yarn add styled-reset</code></li><li><a href="https://github.com/zacanger/styled-reset" target="_blank" rel="external nofollow noopener noreferrer">GitHub - zacanger/styled-reset: Eric Meyer’s Reset CSS for styled-components</a></li><li>styled-reset은 SC를 이용하여 CSS초기화 한 뒤 0의 상태에서 시작할 수 있게 해줌.</li><li>GlobalStyles.js 파일 생성</li></ul><p><strong>src - Components - GlobalStyles.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createGlobalStyle &#125; <span class="keyword">from</span> <span class="string">'styled-components'</span>;</span><br><span class="line"><span class="keyword">import</span> reset <span class="keyword">from</span> <span class="string">'styled-reset'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> globalStyles = createGlobalStyle<span class="string">`</span></span><br><span class="line"><span class="string">  <span class="subst">$&#123;reset&#125;</span>;</span></span><br><span class="line"><span class="string">  a &#123;</span></span><br><span class="line"><span class="string">    text-decoration: none;</span></span><br><span class="line"><span class="string">    color: inherit;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  * &#123;</span></span><br><span class="line"><span class="string">    box-sizing: border-box;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  body &#123;</span></span><br><span class="line"><span class="string">    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;</span></span><br><span class="line"><span class="string">    font-size: 14px;</span></span><br><span class="line"><span class="string">    background-color: rgba(20, 20, 20, 1);</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> globalStyles;</span><br></pre></td></tr></table></figure><p><strong>src - Components - App.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'Components/Router'</span>;</span><br><span class="line"><span class="keyword">import</span> GlobalStyles <span class="keyword">from</span> <span class="string">'./GlobalStyles'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;Router /&gt;</span><br><span class="line">        &lt;GlobalStyles /&gt;</span><br><span class="line">      &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure><br><h2 id="3-4-Location-Aware-Header"><a href="#3-4-Location-Aware-Header" class="headerlink" title="3.4 Location Aware Header"></a>3.4 Location Aware Header</h2><hr><ul><li>선택된 Header의 border에만 컬러링</li><li>해당 요소에 props를 줌</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Item = styled.li<span class="string">`</span></span><br><span class="line"><span class="string">  width: 50px;</span></span><br><span class="line"><span class="string">  height: 50px;</span></span><br><span class="line"><span class="string">  text-align: center;</span></span><br><span class="line"><span class="string">  border-bottom: 5px solid <span class="subst">$&#123;props =&gt; props.current ? <span class="string">'deeppink'</span> : <span class="string">'transparent'</span>&#125;</span>;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure><ul><li>props로 현재 선택된 Header의 Router를 전달해야 함<ul><li>이때 <code>withRouter</code>을 사용. 이것은 컴포넌트를 감싸는 또 다른 컴포넌트의 개념.</li><li>Router에 대한 정보를 줌.</li><li><code>import { Link, withRouter } from ‘react-router-dom’;</code></li><li>아래와 같은 형식으로 withRouter로 기존의 컴포넌트를 감싼다.</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HeaderC = <span class="function">(<span class="params">props</span>) =&gt;</span> (</span><br><span class="line">    &lt;Header&gt;</span><br><span class="line">      &#123;<span class="built_in">console</span>.log(props)&#125;</span><br><span class="line">      &lt;List&gt;</span><br><span class="line">        &lt;Item current=&#123;<span class="literal">false</span>&#125;&gt;</span><br><span class="line">          &lt;SLink to=<span class="string">"/"</span>&gt;Movies&lt;<span class="regexp">/SLink&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>Item&gt;</span><br><span class="line">        &lt;Item current=&#123;<span class="literal">true</span>&#125;&gt;</span><br><span class="line">          &lt;SLink to=<span class="string">"/tv"</span>&gt;TV&lt;<span class="regexp">/SLink&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>Item&gt;</span><br><span class="line">        &lt;Item current=&#123;<span class="literal">false</span>&#125;&gt;</span><br><span class="line">          &lt;SLink to=<span class="string">"/search"</span>&gt;Search&lt;<span class="regexp">/SLink&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>Item&gt;</span><br><span class="line">      &lt;<span class="regexp">/List&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Header&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withRouter(HeaderC);</span><br></pre></td></tr></table></figure><ul><li>위와 동일한 내용을 다른 형식으로 작성</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withRouter(<span class="function"><span class="params">props</span> =&gt;</span> (</span><br><span class="line">    &lt;Header&gt;</span><br><span class="line">      &#123;<span class="built_in">console</span>.log(props)&#125;</span><br><span class="line">      &lt;List&gt;</span><br><span class="line">        &lt;Item current=&#123;<span class="literal">false</span>&#125;&gt;</span><br><span class="line">          &lt;SLink to=<span class="string">"/"</span>&gt;Movies&lt;<span class="regexp">/SLink&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>Item&gt;</span><br><span class="line">        &lt;Item current=&#123;<span class="literal">true</span>&#125;&gt;</span><br><span class="line">          &lt;SLink to=<span class="string">"/tv"</span>&gt;TV&lt;<span class="regexp">/SLink&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>Item&gt;</span><br><span class="line">        &lt;Item current=&#123;<span class="literal">false</span>&#125;&gt;</span><br><span class="line">          &lt;SLink to=<span class="string">"/search"</span>&gt;Search&lt;<span class="regexp">/SLink&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>Item&gt;</span><br><span class="line">      &lt;<span class="regexp">/List&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Header&gt;</span><br><span class="line">));</span><br></pre></td></tr></table></figure><ul><li>console.log를 찍어보면 아래와 같이 props를 얻을 수 있음.</li></ul><img src="/images/withRouter-props.png"><ul><li><p>여기서 필요한 것은 pathname</p><ul><li><code>{ location: { pathname } }</code></li></ul></li><li><p>최종적으로 아래와 같이 pathname의 확인 결과가 boolean으로 나올 수 있도록 작성하면 선택한 요소에만 border 색상이 들어감.</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withRouter(<span class="function">(<span class="params">&#123; location: &#123; pathname &#125; &#125;</span>) =&gt;</span> (</span><br><span class="line">    &lt;Header&gt;</span><br><span class="line">      &lt;List&gt;</span><br><span class="line">        &lt;Item current=&#123;pathname === <span class="string">'/'</span>&#125;&gt;</span><br><span class="line">          &lt;SLink to=<span class="string">'/'</span>&gt;Movies&lt;<span class="regexp">/SLink&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>Item&gt;</span><br><span class="line">        &lt;Item current=&#123;pathname === <span class="string">'/tv'</span>&#125;&gt;</span><br><span class="line">          &lt;SLink to=<span class="string">'/tv'</span>&gt;TV&lt;<span class="regexp">/SLink&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>Item&gt;</span><br><span class="line">        &lt;Item current=&#123;pathname === <span class="string">'/search'</span>&#125;&gt;</span><br><span class="line">          &lt;SLink to=<span class="string">'/search'</span>&gt;Search&lt;<span class="regexp">/SLink&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>Item&gt;</span><br><span class="line">      &lt;<span class="regexp">/List&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Header&gt;</span><br><span class="line">));</span><br></pre></td></tr></table></figure><br><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ReactJS-무비앱-만들기-Day-04&quot;&gt;&lt;a href=&quot;#ReactJS-무비앱-만들기-Day-04&quot; class=&quot;headerlink&quot; title=&quot;[ReactJS] 무비앱 만들기 Day 04&quot;&gt;&lt;/a&gt;[ReactJS] 무비앱 만들기 
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://codeameba.github.io/categories/JavaScript/"/>
    
    
      <category term="til" scheme="http://codeameba.github.io/tags/til/"/>
    
      <category term="TIL" scheme="http://codeameba.github.io/tags/TIL/"/>
    
      <category term="Today I Learned" scheme="http://codeameba.github.io/tags/Today-I-Learned/"/>
    
      <category term="오늘배운것들" scheme="http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"/>
    
      <category term="자바스크립트" scheme="http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"/>
    
      <category term="리액트" scheme="http://codeameba.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"/>
    
      <category term="react" scheme="http://codeameba.github.io/tags/react/"/>
    
      <category term="노마드코더" scheme="http://codeameba.github.io/tags/%EB%85%B8%EB%A7%88%EB%93%9C%EC%BD%94%EB%8D%94/"/>
    
      <category term="nomadcoders" scheme="http://codeameba.github.io/tags/nomadcoders/"/>
    
  </entry>
  
  <entry>
    <title>TIL(190829) - TDD(Test Driven Development) 02</title>
    <link href="http://codeameba.github.io/2019/08/29/programming/tdd-til-02/"/>
    <id>http://codeameba.github.io/2019/08/29/programming/tdd-til-02/</id>
    <published>2019-08-28T16:00:42.000Z</published>
    <updated>2020-02-03T07:47:26.950Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TIL-190829-TDD-Test-Driven-Development-02"><a href="#TIL-190829-TDD-Test-Driven-Development-02" class="headerlink" title="# TIL(190829) - TDD(Test Driven Development) 02"></a># TIL(190829) - TDD(Test Driven Development) 02</h1><hr><p><i>인프런의 ‘견고한 JS 소프트웨어 만들기’ 강의를 보며 정리함</i></p><h2 id="Jasmine-Setting-Up"><a href="#Jasmine-Setting-Up" class="headerlink" title="Jasmine Setting Up"></a>Jasmine Setting Up</h2><hr><ul><li><a href="https://github.com/jasmine/jasmine/releases?after=v2.9.1" target="_blank" rel="external nofollow noopener noreferrer">Releases · jasmine/jasmine · GitHub</a></li><li>강의에서는 2.7.0 버전 다운로드</li><li>SpecRunner.html 파일 실행</li></ul><img src="/images/spec-runner.png">### 테스트 러너<ul><li>자스민, 소스, 테스트 코드를 실행하는 파일</li><li>스탠드 얼론의 경우 HTML 파일이 테스트 러너</li><li>테스트 자동화를 하려면 카르마(Karma) 라이브러리와 연동해야 한다.</li></ul><h2 id="자스민의-활용"><a href="#자스민의-활용" class="headerlink" title="자스민의 활용"></a>자스민의 활용</h2><ul><li>자스민의 SpecRunner.html의 코드를 보면 아래와 같다.</li></ul><img src="/images/spec-runner-code.png"><ul><li>빨간 박스의 자바스크립트 세 줄이 자스민의 테스트 도구라고 할 수 있다.</li><li>그리고, 아래와 같이 본인의 테스트 코드를 넣어서 테스트를 한다.</li></ul><img src="/images/spec-runner-use.png"><ul><li>첫 번째 줄의 describe 함수는 테스트 꾸러미를 만들 때 사용함. 보통은 함수 하나 하나를 테스트 할 때 주로 사용한다.</li><li>두 번째 줄의 it 함수는 테스트 케이스를 만들 때 사용함. 함수의 기능을 테스트 한다고 보면 됨.  첫 번째 인자로 함수 기능의 스펙을 문자열 형태로 넣고, 두 번째 인자로 테스트 함수를 구현할 수 있는 함수를 넣는다.</li><li>세 번째 줄은 테스트 코드 구현 부. 함수의 결과값을 expect 함수의 인자로 넣고, 함수의 기대값을 toBe 함수의 인자로 넣는다.</li></ul><p><strong>테스트 꾸러미(Test Suite)</strong></p><ul><li>describe - 테스트 설명, 테스트 구현 함수</li></ul><p><strong>테스트 스펙(Test Spec)</strong></p><ul><li>it - 테스트 설명, 기대식을 가진 테스트 구현 함수</li></ul><p><strong>기대식과 매쳐</strong></p><ul><li>expect(결과값).toBe(기대값)</li></ul><p><strong>스파이</strong></p><ul><li>spyOn(감시할 객체, 감시할 메서드)</li></ul><h3 id="테스트-결과-확인-방법"><a href="#테스트-결과-확인-방법" class="headerlink" title="테스트 결과 확인 방법"></a>테스트 결과 확인 방법</h3><img src="/images/test-result.png"><ul><li>hello world는 describe  함수로 선언했던 테스트 꾸러미의 이름이라고 할 수 있음.</li><li>true is true는 hello world 테스트 꾸러미에 속한 테스트 케이스.</li><li>위의 내용을 통틀어 1개의 테스트가 실행되었으므로 1spec이라고 명시되었다.</li><li>실패는 없으므로 0 failures.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;TIL-190829-TDD-Test-Driven-Development-02&quot;&gt;&lt;a href=&quot;#TIL-190829-TDD-Test-Driven-Development-02&quot; class=&quot;headerlink&quot; title=&quot;# TIL(1908
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://codeameba.github.io/categories/JavaScript/"/>
    
    
      <category term="til" scheme="http://codeameba.github.io/tags/til/"/>
    
      <category term="TIL" scheme="http://codeameba.github.io/tags/TIL/"/>
    
      <category term="Today I Learned" scheme="http://codeameba.github.io/tags/Today-I-Learned/"/>
    
      <category term="오늘배운것들" scheme="http://codeameba.github.io/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"/>
    
      <category term="자바스크립트" scheme="http://codeameba.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"/>
    
      <category term="Javascript" scheme="http://codeameba.github.io/tags/Javascript/"/>
    
      <category term="패스트캠퍼스" scheme="http://codeameba.github.io/tags/%ED%8C%A8%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%8D%BC%EC%8A%A4/"/>
    
      <category term="TDD" scheme="http://codeameba.github.io/tags/TDD/"/>
    
      <category term="테스트주도개발" scheme="http://codeameba.github.io/tags/%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%A3%BC%EB%8F%84%EA%B0%9C%EB%B0%9C/"/>
    
  </entry>
  
</feed>
