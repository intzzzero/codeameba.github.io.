<!DOCTYPE html>
<html lang="ko">
<head>
    

<!-- Google Tag Manager -->
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-PM2CPLV');
</script>
<!-- End Google Tag Manager -->

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-151869647-3"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-151869647-3');
</script>


<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Sooyoung Jeong">



    <meta name="description" content="생각과 학습의 아카이브">


<link rel="canonical" href="http://codeameba.github.io/2020/03/12/programming/js-fundamental/">


<title>JavaScript Fundamental(마지막 업데이트: 20.03.12) | AmebaLab</title>



    <link rel="icon" href="/image/favicon2.png">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    




<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="AmebaLab" type="application/atom+xml">
</head>
<body>
    <div class="wrapper">
          
<header>
    <!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-PM2CPLV" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->
  
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">AmebaLab</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/contact">Contact</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>

        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">AmebaLab</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/contact">Contact</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">JavaScript Fundamental(마지막 업데이트: 20.03.12)</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Sooyoung Jeong</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">3월 12, 2020&nbsp;&nbsp;18:40:42</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/JavaScript/">JavaScript</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="JS-Study"><a href="#JS-Study" class="headerlink" title="JS Study"></a>JS Study</h1><ul>
<li>자바스크립트를 다시 공부하며 놓쳤던 개념들을 정리함.</li>
<li>교재: 모던 자바스크립트 입문(이소 히로시 지음)</li>
</ul>
<hr>
<h2 id="자바스크립트의-재탄생"><a href="#자바스크립트의-재탄생" class="headerlink" title="자바스크립트의 재탄생"></a>자바스크립트의 재탄생</h2><ul>
<li>자바스크립트는 기존의 다른 프로그래밍 언어들과 달리 불확실한 요소가 많아 외면 당했었다.</li>
<li>구글 지도에서 선보인 Ajax라는 비동기 통신 기술 덕분에 자바스크립트가 재탄생하며, 관심을 받게 되었다.</li>
<li>HTML5와 ES5의 등장은 자바스크립트에 날개를 달아주었다.</li>
</ul>
<h2 id="변수-variable"><a href="#변수-variable" class="headerlink" title="변수(variable)"></a>변수(variable)</h2><ul>
<li>변수는 값이 저장된 특정 메모리 영역을 가리키는 이름이다.</li>
<li>변수에 값을 할당하지 않고 선언만 하면 <code>undefined</code>가 담겨있다.</li>
<li><code>var</code>, <code>let</code>, <code>const</code> 등의 키워드 없이 선언된 변수는 전역변수로 취급한다.</li>
</ul>
<h2 id="변수-호이스팅-hoisting"><a href="#변수-호이스팅-hoisting" class="headerlink" title="변수 호이스팅(hoisting)"></a>변수 호이스팅(hoisting)</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<ul>
<li>프로그램 중간에서 변수를 선언하더라도 첫머리에 선언된 것처럼 작동하는데, 이것을 <strong>호이스팅</strong> 이라고 한다.</li>
<li>단, 호이스팅이 되는 것은 선언문 뿐이며, 자동으로 undefined로 초기화 된다.</li>
</ul>
<h2 id="getMonth-메서드에-1을-해야-하는-이유"><a href="#getMonth-메서드에-1을-해야-하는-이유" class="headerlink" title="getMonth() 메서드에 +1을 해야 하는 이유"></a>getMonth() 메서드에 +1을 해야 하는 이유</h2><ul>
<li><code>new Date()</code> 메서드 사용 시 <code>getMonth()</code> 는 0~11이기 때문에 <strong>+1</strong>을 해줘야 한다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`오늘은 <span class="subst">$&#123;now.getMonth()+<span class="number">1</span>&#125;</span> 월 <span class="subst">$&#123;now.getDate()&#125;</span> 일입니다.`</span>); <span class="comment">//오늘은 2 월 19 일입니다.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(now.getMonth()); <span class="comment">//1</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="함수-function-의-동작원리"><a href="#함수-function-의-동작원리" class="headerlink" title="함수(function)의 동작원리"></a>함수(function)의 동작원리</h2><ul>
<li>함수를 호출하며 인수(argument)를 전달하면, 함수 정의문의 인자(parameter)로 받아 실행 결과를 반환(return)한다.</li>
<li><strong>자판기의 이미지가 연상됨.</strong><blockquote>
<ol>
<li>특정 음료의 가격에 맞는 금액 투입(argument)</li>
<li>특정 음료의 버튼 누름(call)</li>
<li>투입된 금액과 호출된 음료의 값을 비교</li>
<li>가격이 맞으면 해당 음료 반환(return)</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="자바스크립트의-함수는-일급객체"><a href="#자바스크립트의-함수는-일급객체" class="headerlink" title="자바스크립트의 함수는 일급객체"></a>자바스크립트의 함수는 일급객체</h2><ul>
<li>함수를 값으로 쓸 수 있음. -&gt; 변수에 할당 가능</li>
<li>다른 함수의 인수(argument)로 전달 가능</li>
</ul>
<h2 id="함수-선언문의-호이스팅"><a href="#함수-선언문의-호이스팅" class="headerlink" title="함수 선언문의 호이스팅"></a>함수 선언문의 호이스팅</h2><ul>
<li>변수와 마찬가지로 호이스팅이 됨</li>
<li>아래와 같은 <strong>함수선언문</strong> 은 전체가 통째로 호이스팅 됨<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(square(<span class="number">5</span>)); <span class="comment">// 25</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수선언문</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>return이 없으면 undefined<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(square(<span class="number">5</span>)); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(square(<span class="number">3</span>)); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></li>
<li>변수와 마찬가지로 <strong>선언문</strong> 만 호이스팅이 되기 때문에, 아래와 같은 <strong>함수표현식</strong> 은 변수명만 호이스팅이 됨.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 기명 함수표현식</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="function"><span class="keyword">function</span> <span class="title">bb</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'bb'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 익명 함수표현식</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'c'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>함수의 호이스팅은 코드의 순차실행을 저해하고 예측을 어렵게 하기 때문에 되도록 <strong>함수표현식</strong> 의 사용을 권함</li>
</ul>
<h2 id="값의-전달-참조의-전달"><a href="#값의-전달-참조의-전달" class="headerlink" title="값의 전달, 참조의 전달"></a>값의 전달, 참조의 전달</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add1</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x = x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> b = add1(a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`a = <span class="subst">$&#123;a&#125;</span>, b = <span class="subst">$&#123;b&#125;</span>`</span>); <span class="comment">// a = 3, b = 4</span></span><br></pre></td></tr></table></figure>
<ul>
<li>위와 같이 인수로 원시값(primitive-type)을 전달하면, 해당 값 자체가 복사되어 전달된다. 이것을 <strong>값의 전달</strong> 또는 <strong>깊은 복사(deep copy)</strong> 라고 한다.</li>
<li>별도의 메모리 공간에 복사되는 것이기 때문에 변수 a와 인자 x는 별개의 값이며, x의 값이 바뀌더라도 a가 영향을 받지 않는다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add1</span>(<span class="params">p</span>) </span>&#123;</span><br><span class="line">  p.x = p.x + <span class="number">1</span>;</span><br><span class="line">  p.y = p.y + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">x</span>:<span class="number">3</span>, <span class="attr">y</span>:<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> b = add1(a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a, b); <span class="comment">// &#123; x: 4, y: 5 &#125; &#123; x: 4, y: 5 &#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>반면에 인수로 객체(object-type)을 전달했을 때에는 참조(reference)가 전달되는 것으로 이를 <strong>참조 전달</strong> 또는 <strong>얕은 복사(shallow copy)</strong> 라고 한다.</li>
<li>하나의 메모리 공간에 있는 객체를 각기 다른 곳에서 가리키고 있다는 이미지로 이해할 수 있으며, 따라서 p의 값이 바뀌자 a의 값도 바뀐 것이다.</li>
</ul>
<h2 id="스코프"><a href="#스코프" class="headerlink" title="스코프"></a>스코프</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">'global'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="string">'local'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// global</span></span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f();</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// ReferenceError: b is not defined</span></span><br></pre></td></tr></table></figure>
<ul>
<li>위와 같이 함수 내부의 변수가 출력되지 않는 이유는 스코프(scope) 때문이다.</li>
<li>기본적으로 <strong>내부에서는 외부를 볼 수 있지만, 외부에서는 내부를 볼 수 없다</strong> 는 개념으로 이해할 수 있다.</li>
<li>코드가 작성되는 시점에 구문만으로 정해지는 스코프를 어휘적 스코프(lexical scope)라고 하며, 코드가 실행되는 와중에 정해지는 스코프를 동적 스코프(dynamic scope)라고 한다. <strong>자바스크립트는 lexical scope를 따른다</strong></li>
<li>스코프가 존재하는 가장 큰 이유는 식별자(identifier)의 충돌을 막기 위함이다.</li>
</ul>
<h2 id="메서드-method"><a href="#메서드-method" class="headerlink" title="메서드(method)"></a>메서드(method)</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> circle = &#123;</span><br><span class="line">  center: &#123; <span class="attr">x</span>:<span class="number">1.0</span>, <span class="attr">y</span>:<span class="number">2.0</span> &#125;, <span class="comment">// 원의 중심</span></span><br><span class="line">  radius: <span class="number">2.5</span>, <span class="comment">// 원의 반지름</span></span><br><span class="line">  area: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 원의 넓이를 구하는 메서드</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.PI * <span class="keyword">this</span>.radius * <span class="keyword">this</span>.radius;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">circle.translate = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123; <span class="comment">// 새로운 메서드를 추가하여 원을 이동</span></span><br><span class="line">  <span class="keyword">this</span>.center.x = <span class="keyword">this</span>.center.x + a;</span><br><span class="line">  <span class="keyword">this</span>.center.y = <span class="keyword">this</span>.center.y + b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">circle.translate(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">circle.center; <span class="comment">// &#123;x: 2, y: 4&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>자바스크립트에서는 객체 내부의 데이터는 모두 프로퍼티(property)이며, 프로퍼티가 함수를 값으로 가질 때, 일반 프로퍼티와 구분하기 위해 <strong>메서드(method)</strong> 라고 칭한다.</li>
<li>일반적으로 메서드는, 메서드가 속한 객체의 내부 데이터(프로퍼티 값) 상태를 바꾸는 용도로 사용한다.</li>
</ul>
<h2 id="함수를-사용하는-이유"><a href="#함수를-사용하는-이유" class="headerlink" title="함수를 사용하는 이유"></a>함수를 사용하는 이유</h2><ol>
<li><p><strong>재사용이 가능하다.</strong></p>
<ul>
<li>동일한 작업이 반복될 경우 해당 작업을 하는 함수를 만들어 필요한 곳에서 호출만 하면 되기 때문에 코드가 간결해진다.</li>
</ul>
</li>
<li><p><strong>프로그램을 이해하기 쉽다.</strong></p>
<ul>
<li>함수의 이름을 알아보기 쉽게 지으면, 함수명만 보고도 프로그램의 흐름을 파악하기 쉽다.</li>
</ul>
</li>
<li><p><strong>프로그램의 수정이 간단해진다.</strong></p>
<ul>
<li>수정해야 할 일이 있을 때 해당되는 함수만 수정하면 된다.</li>
</ul>
</li>
</ol>
<h2 id="함수를-정의하는-방법"><a href="#함수를-정의하는-방법" class="headerlink" title="함수를 정의하는 방법"></a>함수를 정의하는 방법</h2><ol>
<li>함수 선언문<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>함수 리터럴<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> square = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>Function 생성자<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> square = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'x'</span>, <span class="string">'return x * x);</span></span><br></pre></td></tr></table></figure></li>
<li>화살표(arrow) 함수 표현식<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> square = <span class="function"><span class="params">x</span> =&gt;</span> x * x;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>함수 선언문을 제외한 세 가지 방법은 호이스팅이 되지 않기 때문에 <strong>변수에 할당 후에 사용이 가능</strong> 하며, 따라서 호출하는 코드보다 상단에 위치해야 한다.</li>
</ul>
<h2 id="생성자-함수"><a href="#생성자-함수" class="headerlink" title="생성자 함수"></a>생성자 함수</h2><ul>
<li>Java나 C++ 등의 객체지향 언어에는 <strong>클래스(class)</strong> 라는 객체 생성 방법이 있다.</li>
<li>자바스크립트에는 클래스가 없지만, 대신 <strong>프로토타입(prototype)</strong> 이 있기 때문에 클래스와 유사한 방식으로 객체를 생성할 수 있다.</li>
<li>생성자 함수를 통해 <strong>동일한 이름에 프로퍼티 값이 다른 객체</strong> 를 효율적으로 생성할 수 있다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Card</span>(<span class="params">suit, rank</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.suit = suit;</span><br><span class="line">  <span class="keyword">this</span>.rank = rank;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> card = <span class="keyword">new</span> Card(<span class="string">'Heart'</span>, <span class="string">'A'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(card); <span class="comment">// Card &#123; suit: 'Heart', rank: 'A' &#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>이때, 통상적으로 생성자 함수라는 것을 알리기 위해 <strong>파스칼 케이스</strong>를 쓴다.</li>
<li>이와 같이 생성된 객체를 <strong>인스턴스</strong> 라고 부르는데, 본래 객체지향 언어에서의 인스턴스와는 차이가 있지만, 일반 객체와 구분하기 위해 편의상 인스턴스라고 부른다.</li>
<li><code>this</code> 는 생성자가 생성하는 객체를 가리킨다. 즉, 생성자 함수 내부의 <code>this</code> 는 인스턴스를 가리킨다고 볼 수 있다.</li>
<li><strong>참고:</strong> <ul>
<li><a href="https://ko.javascript.info/constructor-new" target="_blank" rel="external nofollow noopener noreferrer">‘new’ 연산자와 생성자 함수</a></li>
<li><a href="https://ko.javascript.info/class" target="_blank" rel="external nofollow noopener noreferrer">클래스와 기본 문법</a></li>
<li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="external nofollow noopener noreferrer">Classes - JavaScript | MDN</a></li>
</ul>
</li>
</ul>
<h2 id="자바스크립트의-객체"><a href="#자바스크립트의-객체" class="headerlink" title="자바스크립트의 객체"></a>자바스크립트의 객체</h2><ul>
<li>자바스크립트의 객체는 크게 <strong>세 종류</strong> 로 구분할 수 있다.</li>
</ul>
<ol>
<li><p><strong>네이티브 객체</strong></p>
<ul>
<li>ECMAScript 스펙에 따라 정의된 객체를 네이티브 객체(native object)다. </li>
<li>Array, Function, Number 등의 내장 생성자로 생성된 객체와 JSON, Math, Reflect 등이 네이티브 객체에 포함된다.</li>
</ul>
</li>
<li><p><strong>호스트 객체</strong></p>
<ul>
<li>자바스크립트 실행 환경에 정의된 객체를 호스트 객체(host object)라고 한다.</li>
<li>Window, Navigator, History, Screen 등 브라우저 객체와 DOM 객체, Ajax를 위한 XMLHttpRequest 객체, HTML5의 여러 API에 이르기까지 클라이언트 측 자바스크립트에 정의된 객체들이 포함된다.</li>
</ul>
</li>
<li><p><strong>사용자 정의 객체</strong></p>
<ul>
<li>사용자가 직접 정의한 코드의 실행 결과로 생성된 객체를 말한다.</li>
</ul>
</li>
</ol>
<h2 id="희소-배열-sparse-array"><a href="#희소-배열-sparse-array" class="headerlink" title="희소 배열(sparse array)"></a>희소 배열(sparse array)</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</span><br><span class="line">a[<span class="number">4</span>] = <span class="string">'E'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// ["A", "B", "C", empty, "E"]</span></span><br><span class="line"><span class="built_in">console</span>.log(a[<span class="number">3</span>]); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(a.length); <span class="comment">// 5</span></span><br><span class="line">a.hasOwnProperty(<span class="string">"3"</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<ul>
<li>위와 같이 <code>length</code>가 요소의 개수보다 클 때 <strong>희소 배열</strong> 이라고 부른다.</li>
<li>이때 배열은 내부적으로 <strong>객체</strong> 의 형태로 저장되어 있으며, 리터럴로 표현하자면 아래와 같다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">  <span class="string">'0'</span>:<span class="string">'A'</span>,</span><br><span class="line">  <span class="string">'1'</span>:<span class="string">'B'</span>,</span><br><span class="line">  <span class="string">'2'</span>:<span class="string">'C'</span>,</span><br><span class="line">  <span class="string">'4'</span>:<span class="string">'E'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="표현식-expression"><a href="#표현식-expression" class="headerlink" title="표현식(expression)"></a>표현식(expression)</h2></li>
<li>표현식이란 결과적으로 어떤 값으로 평가(evaluation)되는 것</li>
<li>number, string, boolean 등의 원시 값(primitive value)은 그 자체로 가장 간단한 표현식이라고 할 수 있다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.14</span></span><br><span class="line"><span class="string">"hello"</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">null</span></span><br></pre></td></tr></table></figure></li>
<li>변수, 프로퍼티, 배열 요소, 함수 호출, 메서드 호출 등 또한 표현식이라고 할 수 있다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sum</span><br><span class="line">circle.radius</span><br><span class="line">a[<span class="number">3</span>]</span><br><span class="line">square(<span class="number">5</span>)</span><br><span class="line">card.getSum()</span><br></pre></td></tr></table></figure></li>
<li>연산자가 더해지더라도 결과적으로 값으로 평가된다면 역시 표현식이다.<ul>
<li>단항 연산자, 이항 연산자, 삼항 연산자 모두 그렇다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> c = a !== b ? <span class="string">'hello'</span> : <span class="string">'world'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">// hello</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="자바스크립트의-문자열은-불변-immutable"><a href="#자바스크립트의-문자열은-불변-immutable" class="headerlink" title="자바스크립트의 문자열은 불변(immutable)"></a>자바스크립트의 문자열은 불변(immutable)</h2><ul>
<li>자바스크립트는 원시 값을 처리할 때 원시 값을 래퍼(wrapper) 객체로 자동 변환한다.<ul>
<li>문자열은 String 객체, 숫자는 Number 객체, 논리값은 Boolean 객체</li>
<li>null과 undefined는 래퍼 객체가 없음.</li>
</ul>
</li>
<li>래핑은 일시적으로 진행되며 처리가 끝나면 곧바로 메모리에서 삭제된다.</li>
<li><strong>따라서 문자열을 직접 객체화 하지 않더라도 String 객체의 메서드를 사용할 수 있다.</strong></li>
<li>또한, <strong>자바스크립트의 문자열은 불변</strong> 이므로 메서드를 통해 반환되는 새로운 문자열은 원본 문자열과 별개의 값이다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> randomString = <span class="string">'microsoft'</span>;</span><br><span class="line"><span class="keyword">const</span> newString = randomString.replace(<span class="string">'soft'</span>, <span class="string">'hard'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(randomString); <span class="comment">// microsoft</span></span><br><span class="line"><span class="built_in">console</span>.log(newString); <span class="comment">// microhard</span></span><br></pre></td></tr></table></figure></li>
<li><strong>참고</strong><ul>
<li><a href="https://ko.javascript.info/string" target="_blank" rel="external nofollow noopener noreferrer">문자열</a></li>
</ul>
</li>
</ul>
<h2 id="truthy와-falsy"><a href="#truthy와-falsy" class="headerlink" title="truthy와 falsy"></a>truthy와 falsy</h2><ul>
<li>true나 false로 명시되어 있지 않더라도 논리값으로 평가되는 피연산자들이 있다.</li>
<li><strong>true로 평가되는 피연산자</strong><ul>
<li>0을 제외한 숫자, 빈 문자열을 제외한 문자열, 모든 객체, 심벌</li>
</ul>
</li>
<li><strong>false로 평가되는 피연산자</strong><ul>
<li>0, -0, 빈 문자열(“”), NaN, null, undefined</li>
</ul>
</li>
<li>truthy와 falsy에 각각 속한 피연산자들을 보면 나름대로의 일관성이 보이는 것을 알 수 있다. 대체적으로 <strong>없음</strong> 의 뉘앙스가 강한 쪽이 false로 평가된다.</li>
</ul>
<h2 id="암묵적-타입-변환"><a href="#암묵적-타입-변환" class="headerlink" title="암묵적 타입 변환"></a>암묵적 타입 변환</h2><ul>
<li>자바스크립트에서는 암묵적으로 타입을 변환하는 방법이 있다. 대표적으로 아래와 같은 방법으로 string을 number로 변환이 가능하다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'2'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(s, <span class="keyword">typeof</span>(s)); <span class="comment">// 2 string</span></span><br><span class="line"><span class="built_in">console</span>.log(s<span class="number">-0</span>, <span class="keyword">typeof</span>(s<span class="number">-0</span>)); <span class="comment">// 2 number</span></span><br><span class="line"><span class="built_in">console</span>.log(+s, <span class="keyword">typeof</span>(+s)); <span class="comment">// 2 number</span></span><br></pre></td></tr></table></figure></li>
<li>간단하고 편리한 방법이긴 하지만, 놓치고 지나칠 가능성이 농후하므로 되도록 <code>parseInt()</code>, <code>Number()</code>와 같은 명시적인 방법으로 타입을 변환하는 게 좋다고 생각한다.</li>
</ul>
<h2 id="대화상자의-종류"><a href="#대화상자의-종류" class="headerlink" title="대화상자의 종류"></a>대화상자의 종류</h2><ul>
<li>웹 브라우저의 전역 객체 window에는 <strong>대화상자</strong> 를 띄울 수 있는 방법이 세 가지가 있다.</li>
</ul>
<p><strong><code>window.alert()</code></strong></p>
<ul>
<li>경고 대화상자를 표시</li>
<li>확인을 누르면 undefiend 반환</li>
</ul>
<p><strong><code>window.prompt()</code></strong></p>
<ul>
<li>사용자의 문자열 입력을 받을 수 있는 대화상자를 표시</li>
<li>문자열 입력 후 확인을 누르면 해당 문자열 반환</li>
<li>문자열을 입력하지 않고 확인을 누르면 빈 문자열(“”) 반환</li>
<li>취소를 누르면 null 반환</li>
</ul>
<p><strong><code>window.confirm()</code></strong></p>
<ul>
<li>‘확인’ 버튼과 ‘취소’ 버튼이 있는 대화상자를 표시</li>
<li>‘확인’을 누르면 true를, ‘취소’를 누르면 false가 반환</li>
</ul>
<h2 id="for-문-실행순서"><a href="#for-문-실행순서" class="headerlink" title="for 문 실행순서"></a>for 문 실행순서</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>위와 같은 일반적인 for 문이 있을 때, 실행 순서는 다음과 같다.</strong></p>
<ol>
<li>변수 i를 선언 및 0으로 초기화 <code>let i = 0</code></li>
<li>i가 10 보다 작은지 확인 <code>i &lt; 10</code></li>
<li>블록문 실행 <code>console.log(i)</code></li>
<li>i의 값이 1 증가 <code>i++</code></li>
<li>i의 값이 10이 될 때까지 1번 내용을 제외하고 반복</li>
</ol>
<h2 id="객체-지향-프로그래밍의-의미"><a href="#객체-지향-프로그래밍의-의미" class="headerlink" title="객체 지향 프로그래밍의 의미"></a>객체 지향 프로그래밍의 의미</h2><p><strong>객체 지향 프로그래밍(OOP: Object Oriented Programming)</strong> 이란, 프로그램을 작성하는 방법 중 하나로 프로그램을 객체라고 부르는 부품 여러 개로 구성하여 만드는 방법이다. 이때, 객체란 데이터와 데이터를 처리하는 함수(메서드)를 한곳에 모아둔 덩어리를 말한다.</p>
<h2 id="즉시-실행-함수-Immediately-invoked-function"><a href="#즉시-실행-함수-Immediately-invoked-function" class="headerlink" title="즉시 실행 함수(Immediately-invoked function)"></a>즉시 실행 함수(Immediately-invoked function)</h2><ul>
<li>자바스크립트에는 익명 함수를 정의하는 동시에 실행되는 <strong>즉시 실행 함수</strong> 라는 것이 있다.</li>
<li>즉시 실행 함수는 전역 유효 범위(global scope)를 오염시키지 않는 이름 공간(name space)를 생성할 때 사용한다.</li>
<li>즉시 실행 함수는 아래와 같이 정의한다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 첫 번째 방법</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// something</span></span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 두 번째 방법</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// something</span></span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 인수를 넣을 수도 있음</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">fact</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> n * fact(n - <span class="number">1</span>);</span><br><span class="line">&#125;)(<span class="number">5</span>); <span class="comment">// 120</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 변수에 할당 가능</span></span><br><span class="line"><span class="keyword">const</span> x = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// something</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="인수의-생략"><a href="#인수의-생략" class="headerlink" title="인수의 생략"></a>인수의 생략</h2><ul>
<li>함수 정의식에서 요구하는 인자의 개수보다 적은 인수를 전달할 경우 생략된 부분은 undefined가 된다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`x = <span class="subst">$&#123;x&#125;</span>, y = <span class="subst">$&#123;y&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">2</span>); <span class="comment">// x = 2, y = undefined</span></span><br></pre></td></tr></table></figure></li>
<li>만약 두 개 이상의 인자를 연산하여 반환해야 할 때에는 undefined가 나오는 것을 막기 위해 아래와 같이 or 연산자(||)를 활용할 수 있다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  b = b || <span class="number">1</span>; <span class="comment">// b가 falsy값이면 1을 할당</span></span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line">multiply(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 6</span></span><br><span class="line">multiply(<span class="number">2</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="재귀함수"><a href="#재귀함수" class="headerlink" title="재귀함수"></a>재귀함수</h2><ul>
<li>함수가 자기 자신을 호출하는 행위를 재귀 호출(recursive call)이라고 한다.</li>
<li>재귀 호출을 수행하는 함수를 <strong>재귀 함수</strong> 라고 한다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 팩토리얼 재귀함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fact</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> n * fact(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">fact(<span class="number">5</span>); <span class="comment">// 120</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>재귀 함수를 정의할 때 유의해야 하는 사항</strong></p>
<ol>
<li><strong>재귀 호출은 반드시 멈춰야 한다.</strong><ul>
<li>재귀 함수가 멈추는 조건이 반드시 있어야 하며, 그렇지 않으면 스택 오버플로우(stact overflow)를 일으키게 된다.</li>
</ul>
</li>
<li><strong>재귀 호출을 통해 문제를 간단히 해결할 수 있을 때만 사용한다.</strong><ul>
<li>재귀 함수는 메모리를 많이 차지하는 작업이다. 따라서 while문이나 for문으로 해결 가능하다면 재귀 함수를 지양하는 것이 좋다.</li>
</ul>
</li>
</ol>
<h2 id="실행-컨텍스트-Execution-Centext"><a href="#실행-컨텍스트-Execution-Centext" class="headerlink" title="실행 컨텍스트(Execution Centext)"></a>실행 컨텍스트(Execution Centext)</h2><ul>
<li>자바스크립트 엔진은 실행 가능한 코드(Executable Code)를 만나면 그 코드를 평가(Evaluation)하여 실행 컨텍스트(Execution Context)를 만든다.</li>
<li>실행 컨텍스트는, 실행 가능한 코드가 실제로 실행되고 관리되는 영역이다.</li>
<li>실행에 필요한 모든 정보를 여러 컴포넌트에 나누어서 관리함.<ul>
<li>렉시컬 환경(Lexical Environment)<ul>
<li>환경 레코드(Environment Record)<ul>
<li>선언적 환경 레코드(Declarative Environment Record)</li>
<li>객체 환경 레코드(Object Environment Record)</li>
</ul>
</li>
<li>외부 렉시컬 환경 참조(Outer Lexical Environment Reference)</li>
</ul>
</li>
<li>변수 환경(Variable Environment)</li>
<li>디스 바인딩(This Binding)</li>
</ul>
</li>
</ul>
<p><strong>실행 컨텍스트의 구조를 의사 코드로 표현하면 아래와 같다.</strong><br>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 실행 컨텍스트의 구조를 보여주는 pseudo code</span></span><br><span class="line">ExecutionContext = &#123;</span><br><span class="line">  LexicalEnvironment: &#123;</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      DeclarativeEnvironmentRecord: &#123;&#125;,</span><br><span class="line">      ObjectEnvironmentRecord: &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    OuterLexicalEnvironmentReference: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  VariableEnvironment: &#123;&#125;,</span><br><span class="line">  ThisBinding: <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>참고:</strong><ul>
<li><a href="https://www.zerocho.com/category/Javascript/post/5740531574288ebc5f2ba97e" target="_blank" rel="external nofollow noopener noreferrer">(JavaScript) 함수의 범위(scope) - lexical scoping - ZeroCho Blog</a></li>
<li><a href="https://www.zerocho.com/category/Javascript/post/5741d96d094da4986bc950a0" target="_blank" rel="external nofollow noopener noreferrer">(JavaScript) 실행 컨텍스트 - 클로저와 호이스팅 - ZeroCho Blog</a></li>
<li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Closures" target="_blank" rel="external nofollow noopener noreferrer">클로저 - JavaScript | MDN</a></li>
<li><a href="https://medium.com/free-code-camp/execution-context-and-the-call-stack-visually-illustrated-by-a-slice-of-tasty-cake-14f9a64dc460" target="_blank" rel="external nofollow noopener noreferrer">Execution context and the call stack — visually illustrated by a slice of tasty cake</a></li>
<li><a href="https://blog.bitsrc.io/understanding-execution-context-and-execution-stack-in-javascript-1c9ea8642dd0" target="_blank" rel="external nofollow noopener noreferrer">Understanding Execution Context and Execution Stack in Javascript</a></li>
</ul>
</li>
</ul>
<h2 id="렉시컬-환경-Lexical-Environment"><a href="#렉시컬-환경-Lexical-Environment" class="headerlink" title="렉시컬 환경(Lexical Environment)"></a>렉시컬 환경(Lexical Environment)</h2><ul>
<li>자바스크립트 엔진이 코드를 실행하기 위해 자원을 모아 둔 곳</li>
<li>해당 유효 범위(Scope) 안에 있는 식별자와 식별자가 가리키는 값을 <code>key : value</code>의 형태로 바인드하여 렉시컬 환경 컴포넌트에 기록한다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LexicalEnvironment: &#123;</span><br><span class="line">  EnvironmentRecord: &#123;&#125;,</span><br><span class="line">  OuterLexicalEnvironmentReference: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>렉시컬 환경 컴포넌트에는 위와 같이 <strong>환경 레코드(Environment Record)</strong> 와 <strong>외부 렉시컬 환경 참조(Outer Lexical Environment Reference)</strong> 가 있다.<ul>
<li>환경 레코드: 유효 범위 내의 식별자와 값이 기록되어 있으며, 함수가 호출되면 1차적으로 이곳에서 식별자를 탐색한다.</li>
<li>외부 렉시컬 환경 참조: 유효 범위 너머의 식별자와 값이 기록되어 있는 곳으로, 환경 레코드에서 해당 식별자를 찾을 수 없을 때 외부 렉시컬 환경 참조를 탐색하게 된다.</li>
</ul>
</li>
<li>최상위의 렉시컬 환경은 <strong>전역 환경(Global Environment)</strong> 과 바인딩되어 있으며, 이곳에서의 외부 렉시컬 환경 참조는 <code>null</code>이다.</li>
<li><strong>결국 호이스팅(Hoisting)은, 자바스크립트의 식별자들이 해당 스코프의 렉시컬 환경에 등록된 결과라고 볼 수 있다.</strong></li>
</ul>
<h2 id="콜-스택-Call-Stack"><a href="#콜-스택-Call-Stack" class="headerlink" title="콜 스택(Call Stack)"></a>콜 스택(Call Stack)</h2><blockquote>
<p>후입선출(LIFO, Last In First Out) 방식으로 아래부터 데이터를 쌓아 올려 가장 마지막에 추가된 데이터부터 내보내는 자료구조를 <strong>스택(Stack)</strong> 이라고 한다.<br>이때, 데이터를 쌓는 행위를 <strong>push</strong> 라고 하고, 스택의 가장 윗부분에서 데이터를 꺼내는 행위를 <strong>pop</strong> 이라고 한다.</p>
</blockquote>
<ul>
<li><p>실행 컨텍스트(Execution Context)는 프로그램 실행 중 스택에 push되어 실행이 된다. 이때, 전역 코드(Global Execution Context)는 브라우저의 시작과 동시에 실행되어 브라우저를 종료할 때까지 스택의 가장 아래에 위치한다.</p>
</li>
<li><p>함수가 호출되면, 해당 실행 컨텍스트가 스택에 push 되어 실행되며, 해당 함수의 작업이 끝나면 호출했던 부분으로 제어권이 돌아오면서 스택에서 pop 된다. 이처럼 함수가 호출(Call)될 때마다 스택에 쌓인다 하여 <strong>콜 스택(Call Stack)</strong> 이라고 부른다.</p>
</li>
<li><p><strong>참고:</strong></p>
<ul>
<li><a href="https://joshua1988.github.io/web-development/translation/javascript/how-js-works-inside-engine/" target="_blank" rel="external nofollow noopener noreferrer">자바스크립트의 동작원리: 엔진, 런타임, 호출 스택 • Captain Pangyo</a></li>
</ul>
</li>
</ul>
<h2 id="스코프-체인-Scope-Chain"><a href="#스코프-체인-Scope-Chain" class="headerlink" title="스코프 체인(Scope Chain)"></a>스코프 체인(Scope Chain)</h2><ul>
<li>내부 스코프의 렉시컬 환경에서 필요한 식별자를 찾을 수 없을 때 외부 스코프의 렉시컬 환경을 점진적으로 탐색하게 되는데, 이처럼 렉시컬 환경을 매개로 내부와 외부의 스코프가 이어진 것을 <strong>스코프 체인(Scope Chain)</strong> 이라고 부른다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">'A'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="string">'B'</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> c = <span class="string">'C'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a + b + c);</span><br><span class="line">  &#125;</span><br><span class="line">  g();</span><br><span class="line">&#125;</span><br><span class="line">f(); <span class="comment">// ABC</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>위와 같은 중첩 함수가 있을 때, 식별자 탐색 과정을 단계별로 알아보자면 다음과 같다.</strong></p>
<ol>
<li><code>g()</code>의 렉시컬 환경의 선언적 환경 레코드(Declarative Environment Record)에서 식별자 <code>c</code>를 찾는다.</li>
<li><code>g()</code>의 선언적 환경 레코드에서 식별자 <code>b</code>를 찾지만 못 찾고, <code>g()</code>의 외부 렉시컬 환경 참조(Outer Lexical Environment Reference)에 기록된 상위 함수 <code>f()</code>로 이동하여 탐색한다.</li>
<li><code>f()</code>의 렉시컬 환경의 선언적 환경 레코드에서 식별자 <code>b</code>를 찾는다.</li>
<li><code>f()</code>의 선언적 환경 레코드에서 식별자 <code>a</code>를 찾지만 못 찾고, <code>f()</code>의 외부 렉시컬 환경 참조에 기록된 전역 렉시컬 환경(Global Lexical Environment)로 이동하여 탐색한다.</li>
<li>전역 렉시컬 환경의 객체 환경 레코드(Object Environment Record)에서 식별자 <code>a</code>를 발견한다. 이때의 외부 렉시컬 환경 참조는 <code>null</code>이다.</li>
</ol>
<ul>
<li><strong>참고:</strong><ul>
<li><a href="https://poiemaweb.com/js-scope" target="_blank" rel="external nofollow noopener noreferrer">Scope | PoiemaWeb</a></li>
</ul>
</li>
</ul>
<h2 id="스코프-scope-와-실행-컨텍스트-execution-context-의-차이"><a href="#스코프-scope-와-실행-컨텍스트-execution-context-의-차이" class="headerlink" title="스코프(scope)와 실행 컨텍스트(execution context)의 차이"></a>스코프(scope)와 실행 컨텍스트(execution context)의 차이</h2><ul>
<li>스코프는 변수의 <strong>유효 범위</strong> 이며, 실행 컨텍스트는 실행되는 코드 덩어리라는 추삭적 개념.</li>
<li>스코프는 함수가 <strong>정의될 때</strong> 결정되며, 실행 컨텍스트는 함수가 <strong>실행될 때</strong> 생성된다.</li>
</ul>
<h2 id="함수의-실행-절차"><a href="#함수의-실행-절차" class="headerlink" title="함수의 실행 절차"></a>함수의 실행 절차</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  inner();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">outer();</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p><strong>위와 같은 코드가 있을 때 내부적인 실행 절차는 다음과 같다.</strong></p>
<ol>
<li>전역 실행 컨텍스트 생성</li>
<li>전역 변수 <code>a</code> 선언(호이스팅)</li>
<li>외부 함수 <code>outer</code> 선언(호이스팅)</li>
<li>변수 <code>a</code>에 1 할당</li>
<li><code>outer</code> 함수 호출 및 <code>outer</code> 실행 컨텍스트 생성</li>
<li>함수 <code>inner</code> 선언(<code>outer</code> 스코프에서 호이스팅)</li>
<li><code>outer</code> 스코프에서 <code>a</code> 탐색하지만 찾을 수 없으므로 전역 스코프에서 재탐색 후 1 출력</li>
<li>중첩 함수 <code>inner</code> 호출 및 <code>inner</code> 실행 컨텍스트 생성</li>
<li>지역 변수 <code>a</code> 선언(<code>inner</code> 스코프에서 호이스팅)</li>
<li><code>inner</code> 스코프에서 <code>a</code> 탐색 후 출력하지만 호이스팅만 된 단계이므로 <code>undefined</code> 출력</li>
<li>지역 변수 <code>a</code>에 3 할당</li>
<li><code>inner</code> 실행 컨텍스트 종료</li>
<li>제어권이 <code>outer</code> 실행 컨텍스트로 돌아오며 전역 스코프에서 변수 <code>a</code> 탐색 후 1 출력</li>
<li><code>outer</code> 실행 컨텍스트 종료</li>
<li>전역 스코프에서 변수 <code>a</code> 탐색 후 1 출력</li>
</ol>
<h2 id="가비지-컬렉션-garbage-collection"><a href="#가비지-컬렉션-garbage-collection" class="headerlink" title="가비지 컬렉션(garbage collection)"></a>가비지 컬렉션(garbage collection)</h2><ul>
<li><p>자바스크립트 엔진 내부에는 <strong>가비지 컬렉터(garbage collector)</strong> 가 쉬지 않고 동작하며, <strong>참조가 없는 객체를 메모리에서 해제한다.</strong> 그리고, 이러한 매커니즘을 가비지 컬렉션이라고 한다.</p>
</li>
<li><p>가비지 컬렉터 덕분에 메모리의 공간 확보를 직접 하지 않아도 되는 만큼 메모리에는 크게 신경 쓰지 않아도 되지만, 메모리 누수로 인해 퍼포먼스가 저하될 가능성이 없지 않기 때문에 전혀 고려하지 않아도 되는 것은 아니다.</p>
</li>
<li><p><strong>참고:</strong></p>
<ul>
<li><a href="https://ko.javascript.info/garbage-collection" target="_blank" rel="external nofollow noopener noreferrer">가비지 컬렉션</a></li>
</ul>
</li>
</ul>
<h2 id="클로저-closure"><a href="#클로저-closure" class="headerlink" title="클로저(closure)"></a>클로저(closure)</h2><ul>
<li>클로저의 주 사용 목적은 외부로부터 내부의 상태를 숨기는 <strong>캡슐화(encapsulation)</strong> 에 있다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 보통은 익명함수를 사용하지만, 편의를 위해 이름을 붙임</span></span><br><span class="line">    <span class="keyword">return</span> count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> counter = makeCounter();</span><br><span class="line"><span class="built_in">console</span>.log(counter()); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(counter()); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(counter()); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>위와 같은 클로저가 있을 때 다음과 같은 특징을 알 수 있다.</strong></p>
<ol>
<li>외부 함수 <code>makeCounter</code>는 중첩 함수 <code>f</code>의 참조를 반환한다.</li>
<li>중첩 함수 <code>f</code>는 외부 함수 <code>makeCounter</code>의 지역 변수 <code>count</code>를 참조한다.</li>
<li>전역 변수 <code>counter</code>에 함수 <code>makeCounter</code>를 할당하였으므로, 전역 변수 <code>counter</code>는 중첩 함수 <code>f</code>의 함수 객체를 참조한다.</li>
<li><code>f</code>의 함수 객체는 함수 <code>makeCounter</code>의 렉시컬 환경 컴포넌트를 참조한다.</li>
<li>결과적으로, 전역 변수 <code>counter</code>는 중첩 함수 <code>f</code>의 함수 객체를 통해 간접적으로 외부 함수 <code>makeCounter</code>의 렉시컬 환경 컴포넌트를 참조한다.</li>
</ol>
<p><strong>클로저의 핵심:</strong></p>
<ul>
<li>외부 함수를 호출하면 해당 함수의 렉시컬 환경 컴포넌트가 생성되며, 중첩 함수의 함수 객체를 생성 및 반환한다.</li>
<li>외부 함수는 클로저를 생성하는 팩토리 함수이며, 클로저의 주 기능은 중첩 함수에 담겨있다.</li>
<li>외부 함수가 속한 렉시컬 환경 컴포넌트는 클로저 내부 상태 자체이며, 외부 함수가 호출될 때마다 새로 생성된다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = makeCounter();</span><br><span class="line"><span class="built_in">console</span>.log(counter()); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(counter()); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(counter()); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> counter2 = makeCounter();</span><br><span class="line"><span class="built_in">console</span>.log(counter2()); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(counter2()); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(counter2()); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li>
<li>중첩 함수의 함수 객체가 있는 한 외부 함수가 속한 렉시컬 환경 컴포넌트는 지워지지 않으며, 외부 함수의 함수 객체가 사라져도 지워지지 않는다.</li>
<li>클로저 내부 상태(외부 함수의 지역 변수, 선언적 환경 레코드)는 외부로부터 은폐되어 있으며 중첩 함수 안에서만 읽거나 쓸 수 있다.</li>
</ul>
<p><strong>참고:</strong></p>
<ul>
<li><a href="https://opentutorials.org/course/743/6544" target="_blank" rel="external nofollow noopener noreferrer">클로저 - 생활코딩</a></li>
<li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Closures" target="_blank" rel="external nofollow noopener noreferrer">클로저 - JavaScript | MDN</a></li>
<li><a href="https://poiemaweb.com/js-closure" target="_blank" rel="external nofollow noopener noreferrer">Closure | PoiemaWeb</a></li>
</ul>
<h2 id="네임-스페이스-Name-space-오염을-줄이는-방법"><a href="#네임-스페이스-Name-space-오염을-줄이는-방법" class="headerlink" title="네임 스페이스(Name space) 오염을 줄이는 방법"></a>네임 스페이스(Name space) 오염을 줄이는 방법</h2><p>전역 변수와 전역 함수 등을 남발하게 되면 라이브러리를 쓴다거나 협업을 할 때 식별자가 충돌할 수가 있다. 따라서 전역 변수의 사용이 불가피할 경우에는 소스 코드 상단에 모아서 한눈에 파악할 수 있게 하는 것이 좋다.</p>
<p>그리고, 네임 스페이스의 오염을 최소화 하기 위한 방법으로는 다음과 같은 것들이 있다.</p>
<ol>
<li><p><strong>객체를 네임 스페이스로 활용하기</strong></p>
<ul>
<li>프로그램을 대표할만한 이름의 전역 변수를 하나 생성하여 객체를 값으로 할당하고, 프로그램에서 필요한 모든 변수와 함수를 프로퍼티로 정의한다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myApp = myApp || &#123;&#125;;</span><br><span class="line"></span><br><span class="line">myApp.name = <span class="string">'Tom'</span>;</span><br><span class="line">myApp.showName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// something</span></span><br><span class="line">&#125;;</span><br><span class="line">myApp.view = &#123;&#125;; <span class="comment">// 내부에 또 다른 네임 스페이스를 만들 수도 있다.</span></span><br><span class="line">myApp.view.draw = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// something</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>즉시 실행 함수로 감싸기</strong></p>
<ul>
<li>일시적인 처리를 수행하는 내용들을 즉시 실행 함수로 감싸면 중복된 이름이 있더라도 전역 네임 스페이스를 오염시키지 않고 실행이 가능하다.</li>
</ul>
</li>
<li><p><strong>모듈 패턴</strong></p>
<ul>
<li>모듈(module)은 여러 기능을 하나로 묶은 것으로, 클로저(closure)를 즉시 실행 함수(IIFE)로 감싼 형태다.</li>
<li>이를 통하여 내부의 변수나 함수는 은폐하고, 원하는 함수만 공개할 수 있다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Module = Module || &#123;&#125;;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">_Module</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">'NoName'</span>; <span class="comment">// 프라이빗 변수</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 프라이빗 함수</span></span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">  _Module.showName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 퍼블릭 함수</span></span><br><span class="line">    <span class="built_in">console</span>.log(getName());</span><br><span class="line">  &#125;;</span><br><span class="line">  _Module.setName = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; <span class="comment">// 퍼블릭 함수</span></span><br><span class="line">    name = x;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)(Module)</span><br><span class="line"></span><br><span class="line">Module.setName(<span class="string">'Tom'</span>);</span><br><span class="line">Module.showName(); <span class="comment">// Tom</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>

        </div>

        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/til/"># til</a>
                    
                        <a href="/tags/TIL/"># TIL</a>
                    
                        <a href="/tags/Today-I-Learned/"># Today I Learned</a>
                    
                        <a href="/tags/%EC%98%A4%EB%8A%98%EB%B0%B0%EC%9A%B4%EA%B2%83%EB%93%A4/"># 오늘배운것들</a>
                    
                        <a href="/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"># 자바스크립트</a>
                    
                        <a href="/tags/Javascript/"># Javascript</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
            
            <a class="next" rel="next" href="/2020/02/24/programming/tip-useful-site/">유용한 웹사이트 모음(마지막 업데이트 2020.02.24)</a>
            
        </section>


    </article>
    
    <div id="disqus_thread"></div>
        <script>

        /**
        *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
        *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
        /*
        var disqus_config = function () {
        this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
        };
        */
        (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        s.src = 'https://codeameba.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
        })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" target="_blank" rel="external nofollow noopener noreferrer">comments powered by Disqus.</a></noscript>

</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© 2020 codeAmeba</span>
    </div>
</footer>
    </div>
</body>
</html>
